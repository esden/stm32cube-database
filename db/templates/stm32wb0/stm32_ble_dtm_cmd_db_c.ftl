[#ftl]
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    DTM_cmd_db.c
  * @author  AMS - RF Application team
  * @date    24 October 2023
  * @brief   Autogenerated files, do not edit!!
  ******************************************************************************
[@common.optinclude name=mxTmpFolder+"/license.tmp"/][#--include License text --]
  ******************************************************************************
  */
/* USER CODE END Header */

#include <stdlib.h>
#include "stm32wb0x.h"
#include "compiler.h"
#include "app_common.h"
#include "ble_stack.h"
#include "osal.h"
#include "aci_gatt_nwk.h"
#include "aci_adv_nwk.h"
#include "aci_l2cap_nwk.h"
#include "gatt_profile.h"
#include "gap_profile.h"
#include "dtm_cmd_db.h"
#include "dtm_cmd_en.h"
#include "RADIO_utils.h"
#include "transport_layer.h"

#include <stdint.h>

/** Documentation for C struct Advertising_Set_Parameters_t */
typedef PACKED(struct) packed_Advertising_Set_Parameters_t_s {
  /** It is used to identify an advertising set.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t Advertising_Handle;
  /** The Duration[i] parameter indicates the duration for which that advertising set
   *  is enabled. The duration begins at the start of the first advertising
   *  event of this advertising set. The Controller should not start an extended
   *  advertising event that it cannot complete within the duration. Time = N *
   *  10 ms 0x00 means no advertising duration: advertising will continue until
   *  the Host disables it.
   *  Values:
   *  - 0x0000 (0 ms) : No advertising duration
   *  - 0x0001 (10 ms)  ... 0xFFFF (655350 ms)
   */
  uint16_t Duration;
  /** The Max_Extended_Advertising_Events[i] parameter, if non-zero, indicates the
   *  maximum number of extended advertising events that shall be sent prior to
   *  disabling the extended advertising set even if the Duration[i] parameter
   *  has not expired.
   *  Values:
   *  - 0x00: No maximum number of advertising events.
   *  - 0x01 ... 0xFF: Maximum number of extended advertising events.
   */
  uint8_t Max_Extended_Advertising_Events;
} packed_Advertising_Set_Parameters_t;

/** Documentation for C struct Extended_Scan_Parameters_t */
typedef PACKED(struct) packed_Extended_Scan_Parameters_t_s {
  /** The Scan_Type parameter specifies the type of scan to perform. 0: Passive
   *  Scanning. No scan request PDUs shall be sent. 1: Active Scanning. Scan
   *  request PDUs may be sent.
   *  Values:
   *  - 0x00: Passive Scanning
   *  - 0x01: Active Scanning
   */
  uint8_t Scan_Type;
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Scan_Window;
} packed_Extended_Scan_Parameters_t;

/** Documentation for C struct Extended_Create_Connection_Parameters_t */
typedef PACKED(struct) packed_Extended_Create_Connection_Parameters_t_s {
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Scan_Window;
  /** Minimum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
   */
  uint16_t Connection_Interval_Min;
  /** Maximum value for the connection interval. This shall be less than or equal to
   *  Connection_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
   */
  uint16_t Connection_Interval_Max;
  /** Peripheral latency for the connection in number of connection events
   *  Values:
   *  - 0x0000 ... 0x01F3
   */
  uint16_t Max_Latency;
  /** Supervision timeout for the LE Link. (See [Vol 6] Part B, Section 4.5.2) Time =
   *  N * 10 ms; Time Range: 100 ms to 32 s.
   *  Values:
   *  - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
   */
  uint16_t Supervision_Timeout;
  /** Informative parameter recommending the minimum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Min_CE_Length;
  /** Informative parameter recommending the maximum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)
   */
  uint16_t Max_CE_Length;
} packed_Extended_Create_Connection_Parameters_t;

/** Documentation for C struct CIS_Param_t */
typedef PACKED(struct) packed_CIS_Param_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** Number of times every CIS Data PDU should be retransmitted from the Central to
   *  the Peripheral.
   */
  uint8_t RTN_C_To_P;
  /** Number of times every CIS Data PDU should be retransmitted from the Peripheral
   *  to the Central.
   */
  uint8_t RTN_P_To_C;
} packed_CIS_Param_t;

/** Documentation for C struct CIS_Param_Test_t */
typedef PACKED(struct) packed_CIS_Param_Test_t_s {
  /** Used to identify a CIS.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t CIS_ID;
  /** Maximum number of subevents in each CIS event.
   *  Values:
   *  - 0x01 ... 0x1F
   */
  uint8_t NSE;
  /** Maximum size, in octets, of the payload from the Central's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Host.
   *  Values:
   *  - 0x0000 ... 0x0FFF
   */
  uint16_t Max_SDU_P_To_C;
  /** Maximum size, in octets, of the payload from the Central's Link Layer to the
   *  Peripheral's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_C_To_P;
  /** Maximum size, in octets, of the payload from the Peripheral's Link Layer to the
   *  Central's Link Layer.
   *  Values:
   *  - 0x0000 ... 0x00FB
   */
  uint16_t Max_PDU_P_To_C;
  /** PHY to use for transmission from the Central to the Peripheral.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_C_To_P;
  /** PHY to use for transmission from the Peripheral to the Central.
   *  Flags:
   *  - 0x01: LE_1M_PHY_BIT
   *  - 0x02: LE_2M_PHY_BIT
   *  - 0x04: LE_CODED_PHY_BIT
   */
  uint8_t PHY_P_To_C;
  /** The burst number for Central to Peripheral.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_C_To_P;
  /** The burst number for Peripheral to Central.
   *  Values:
   *  - 0x00: No data
   *  - 0x01 ... 0x0F
   */
  uint8_t BN_P_To_C;
} packed_CIS_Param_Test_t;

/** Documentation for C struct CIS_Handles_t */
typedef PACKED(struct) packed_CIS_Handles_t_s {
  /** Connection handle of a CIS.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t CIS_Connection_Handle;
  /** Connection handle of an ACL connection.
   *  Values:
   *  - 0x0000 ... 0x0EFF
   */
  uint16_t ACL_Connection_Handle;
} packed_CIS_Handles_t;

/** Documentation for C struct Subevent_Data_Parameters_t */
typedef PACKED(struct) packed_Subevent_Data_Parameters_t_s {
  /** The subevent index of the data.
   *  Values:
   *  - 0x00 ... 0x7F
   */
  uint8_t Subevent;
  /** The first response slots to be used in this subevent.
   */
  uint8_t Response_Slot_Start;
  /** The number of response slots to be used.
   */
  uint8_t Response_Slot_Count;
  /** The number of octets in the Subevent_Data parameter.
   *  Values:
   *  - 0x00 ... 0xFB
   */
  uint8_t Subevent_Data_Length;
  /** Advertising data formatted as defined in [Vol 3] Part C, Section 11.
   */
  uint8_t Subevent_Data[1];
} packed_Subevent_Data_Parameters_t;

/** Documentation for C struct Bonded_Device_Entry_t */
typedef PACKED(struct) packed_Bonded_Device_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Address_Type;
  /** Identity Address (Public or Random) of the device.
   */
  uint8_t Address[6];
} packed_Bonded_Device_Entry_t;

/** Documentation for C struct List_Entry_t */
typedef PACKED(struct) packed_List_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Peer_Address_Type;
  /** Public Device Address or Random Device Address of the device to be added to the
   *  list.
   */
  uint8_t Peer_Address[6];
} packed_List_Entry_t;

/** Documentation for C union Service_UUID_t */
typedef PACKED(union) packed_Service_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Service_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Service_UUID_128[16];
} packed_Service_UUID_t;

/** Documentation for C union Char_UUID_t */
typedef PACKED(union) packed_Char_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_UUID_t;

/** Documentation for C union Char_Desc_Uuid_t */
typedef PACKED(union) packed_Char_Desc_Uuid_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_Desc_Uuid_t;

/** Documentation for C union UUID_t */
typedef PACKED(union) packed_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t UUID_16;
  /** 128-bit UUID
   */
  uint8_t UUID_128[16];
} packed_UUID_t;

/** Documentation for C struct Gatt_Srv_Notify_Attr_t */
typedef PACKED(struct) packed_Gatt_Srv_Notify_Attr_t_s {
  /**
   */
  uint16_t Handle;
  /**
   */
  uint16_t Val_Length;
  /**
   */
  uint8_t Val[1];
} packed_Gatt_Srv_Notify_Attr_t;

typedef PACKED(struct) hci_disconnect_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Reason;
} hci_disconnect_cp0;

typedef PACKED(struct) hci_disconnect_rp0_s {
  uint8_t Status;
} hci_disconnect_rp0;

typedef PACKED(struct) hci_read_remote_version_information_cp0_s {
  uint16_t Connection_Handle;
} hci_read_remote_version_information_cp0;

typedef PACKED(struct) hci_read_remote_version_information_rp0_s {
  uint8_t Status;
} hci_read_remote_version_information_rp0;

typedef PACKED(struct) hci_set_event_mask_cp0_s {
  uint8_t Event_Mask[8];
} hci_set_event_mask_cp0;

typedef PACKED(struct) hci_set_event_mask_rp0_s {
  uint8_t Status;
} hci_set_event_mask_rp0;

typedef PACKED(struct) hci_read_connection_accept_timeout_rp0_s {
  uint8_t Status;
  uint16_t Connection_Accept_Timeout;
} hci_read_connection_accept_timeout_rp0;

typedef PACKED(struct) hci_write_connection_accept_timeout_cp0_s {
  uint16_t Connection_Accept_Timeout;
} hci_write_connection_accept_timeout_cp0;

typedef PACKED(struct) hci_write_connection_accept_timeout_rp0_s {
  uint8_t Status;
} hci_write_connection_accept_timeout_rp0;

typedef PACKED(struct) hci_read_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Type;
} hci_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_read_transmit_power_level_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  int8_t Transmit_Power_Level;
} hci_read_transmit_power_level_rp0;

typedef PACKED(struct) hci_read_afh_channel_assessment_mode_rp0_s {
  uint8_t Status;
  uint8_t AFH_Channel_Assessment_Mode;
} hci_read_afh_channel_assessment_mode_rp0;

typedef PACKED(struct) hci_write_afh_channel_assessment_mode_cp0_s {
  uint8_t AFH_Channel_Assessment_Mode;
} hci_write_afh_channel_assessment_mode_cp0;

typedef PACKED(struct) hci_write_afh_channel_assessment_mode_rp0_s {
  uint8_t Status;
} hci_write_afh_channel_assessment_mode_rp0;

typedef PACKED(struct) hci_set_event_mask_page_2_cp0_s {
  uint8_t Event_Mask_Page_2[8];
} hci_set_event_mask_page_2_cp0;

typedef PACKED(struct) hci_set_event_mask_page_2_rp0_s {
  uint8_t Status;
} hci_set_event_mask_page_2_rp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_cp0_s {
  uint16_t Connection_Handle;
} hci_read_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint16_t Authenticated_Payload_Timeout;
} hci_read_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Authenticated_Payload_Timeout;
} hci_write_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_write_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_read_local_version_information_rp0_s {
  uint8_t Status;
  uint8_t HCI_Version;
  uint16_t HCI_Revision;
  uint8_t LMP_PAL_Version;
  uint16_t Manufacturer_Name;
  uint16_t LMP_PAL_Subversion;
} hci_read_local_version_information_rp0;

typedef PACKED(struct) hci_read_local_supported_commands_rp0_s {
  uint8_t Status;
  uint8_t Supported_Commands[64];
} hci_read_local_supported_commands_rp0;

typedef PACKED(struct) hci_read_local_supported_features_rp0_s {
  uint8_t Status;
  uint8_t LMP_Features[8];
} hci_read_local_supported_features_rp0;

typedef PACKED(struct) hci_read_bd_addr_rp0_s {
  uint8_t Status;
  uint8_t BD_ADDR[6];
} hci_read_bd_addr_rp0;

typedef PACKED(struct) hci_read_rssi_cp0_s {
  uint16_t Connection_Handle;
} hci_read_rssi_cp0;

typedef PACKED(struct) hci_read_rssi_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  int8_t RSSI;
} hci_read_rssi_rp0;

typedef PACKED(struct) hci_le_set_event_mask_cp0_s {
  uint8_t LE_Event_Mask[8];
} hci_le_set_event_mask_cp0;

typedef PACKED(struct) hci_le_set_event_mask_rp0_s {
  uint8_t Status;
} hci_le_set_event_mask_rp0;

typedef PACKED(struct) hci_le_read_buffer_size_rp0_s {
  uint8_t Status;
  uint16_t HC_LE_ACL_Data_Packet_Length;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets;
} hci_le_read_buffer_size_rp0;

typedef PACKED(struct) hci_le_read_local_supported_features_rp0_s {
  uint8_t Status;
  uint8_t LE_Features[8];
} hci_le_read_local_supported_features_rp0;

typedef PACKED(struct) hci_le_set_random_address_cp0_s {
  uint8_t Random_Address[6];
} hci_le_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_random_address_rp0_s {
  uint8_t Status;
} hci_le_set_random_address_rp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_cp0_s {
  uint16_t Advertising_Interval_Min;
  uint16_t Advertising_Interval_Max;
  uint8_t Advertising_Type;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Channel_Map;
  uint8_t Advertising_Filter_Policy;
} hci_le_set_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_read_advertising_physical_channel_tx_power_rp0_s {
  uint8_t Status;
  int8_t Transmit_Power_Level;
} hci_le_read_advertising_physical_channel_tx_power_rp0;

typedef PACKED(struct) hci_le_set_advertising_data_cp0_s {
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[31];
} hci_le_set_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_scan_response_data_cp0_s {
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[31];
} hci_le_set_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_scan_response_data_rp0_s {
  uint8_t Status;
} hci_le_set_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_advertising_enable_cp0_s {
  uint8_t Advertising_Enable;
} hci_le_set_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_scan_parameters_cp0_s {
  uint8_t LE_Scan_Type;
  uint16_t LE_Scan_Interval;
  uint16_t LE_Scan_Window;
  uint8_t Own_Address_Type;
  uint8_t Scanning_Filter_Policy;
} hci_le_set_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_scan_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_scan_enable_cp0_s {
  uint8_t LE_Scan_Enable;
  uint8_t Filter_Duplicates;
} hci_le_set_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_scan_enable_rp0_s {
  uint8_t Status;
} hci_le_set_scan_enable_rp0;

typedef PACKED(struct) hci_le_create_connection_cp0_s {
  uint16_t LE_Scan_Interval;
  uint16_t LE_Scan_Window;
  uint8_t Initiator_Filter_Policy;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Own_Address_Type;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Max_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
} hci_le_create_connection_cp0;

typedef PACKED(struct) hci_le_create_connection_rp0_s {
  uint8_t Status;
} hci_le_create_connection_rp0;

typedef PACKED(struct) hci_le_create_connection_cancel_rp0_s {
  uint8_t Status;
} hci_le_create_connection_cancel_rp0;

typedef PACKED(struct) hci_le_read_filter_accept_list_size_rp0_s {
  uint8_t Status;
  uint8_t Filter_Accept_List_Size;
} hci_le_read_filter_accept_list_size_rp0;

typedef PACKED(struct) hci_le_clear_filter_accept_list_rp0_s {
  uint8_t Status;
} hci_le_clear_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_add_device_to_filter_accept_list_cp0_s {
  uint8_t Address_Type;
  uint8_t Address[6];
} hci_le_add_device_to_filter_accept_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_filter_accept_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_filter_accept_list_cp0_s {
  uint8_t Address_Type;
  uint8_t Address[6];
} hci_le_remove_device_from_filter_accept_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_filter_accept_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_filter_accept_list_rp0;

typedef PACKED(struct) hci_le_connection_update_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Max_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
} hci_le_connection_update_cp0;

typedef PACKED(struct) hci_le_connection_update_rp0_s {
  uint8_t Status;
} hci_le_connection_update_rp0;

typedef PACKED(struct) hci_le_set_host_channel_classification_cp0_s {
  uint8_t LE_Channel_Map[5];
} hci_le_set_host_channel_classification_cp0;

typedef PACKED(struct) hci_le_set_host_channel_classification_rp0_s {
  uint8_t Status;
} hci_le_set_host_channel_classification_rp0;

typedef PACKED(struct) hci_le_read_channel_map_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_channel_map_cp0;

typedef PACKED(struct) hci_le_read_channel_map_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t LE_Channel_Map[5];
} hci_le_read_channel_map_rp0;

typedef PACKED(struct) hci_le_read_remote_features_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_remote_features_cp0;

typedef PACKED(struct) hci_le_read_remote_features_rp0_s {
  uint8_t Status;
} hci_le_read_remote_features_rp0;

typedef PACKED(struct) hci_le_encrypt_cp0_s {
  uint8_t Key[16];
  uint8_t Plaintext_Data[16];
} hci_le_encrypt_cp0;

typedef PACKED(struct) hci_le_encrypt_rp0_s {
  uint8_t Status;
  uint8_t Encrypted_Data[16];
} hci_le_encrypt_rp0;

typedef PACKED(struct) hci_le_rand_rp0_s {
  uint8_t Status;
  uint8_t Random_Number[8];
} hci_le_rand_rp0;

typedef PACKED(struct) hci_le_enable_encryption_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Random_Number[8];
  uint16_t Encrypted_Diversifier;
  uint8_t Long_Term_Key[16];
} hci_le_enable_encryption_cp0;

typedef PACKED(struct) hci_le_enable_encryption_rp0_s {
  uint8_t Status;
} hci_le_enable_encryption_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Long_Term_Key[16];
} hci_le_long_term_key_request_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_reply_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_negative_reply_cp0_s {
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_negative_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_request_negative_reply_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_negative_reply_rp0;

typedef PACKED(struct) hci_le_read_supported_states_rp0_s {
  uint8_t Status;
  uint8_t LE_States[8];
} hci_le_read_supported_states_rp0;

typedef PACKED(struct) hci_le_receiver_test_cp0_s {
  uint8_t RX_Frequency;
} hci_le_receiver_test_cp0;

typedef PACKED(struct) hci_le_receiver_test_rp0_s {
  uint8_t Status;
} hci_le_receiver_test_rp0;

typedef PACKED(struct) hci_le_transmitter_test_cp0_s {
  uint8_t TX_Frequency;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
} hci_le_transmitter_test_cp0;

typedef PACKED(struct) hci_le_transmitter_test_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_rp0;

typedef PACKED(struct) hci_le_test_end_rp0_s {
  uint8_t Status;
  uint16_t Number_Of_Packets;
} hci_le_test_end_rp0;

typedef PACKED(struct) hci_le_set_data_length_cp0_s {
  uint16_t Connection_Handle;
  uint16_t TxOctets;
  uint16_t TxTime;
} hci_le_set_data_length_cp0;

typedef PACKED(struct) hci_le_set_data_length_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_data_length_rp0;

typedef PACKED(struct) hci_le_read_suggested_default_data_length_rp0_s {
  uint8_t Status;
  uint16_t SuggestedMaxTxOctets;
  uint16_t SuggestedMaxTxTime;
} hci_le_read_suggested_default_data_length_rp0;

typedef PACKED(struct) hci_le_write_suggested_default_data_length_cp0_s {
  uint16_t SuggestedMaxTxOctets;
  uint16_t SuggestedMaxTxTime;
} hci_le_write_suggested_default_data_length_cp0;

typedef PACKED(struct) hci_le_write_suggested_default_data_length_rp0_s {
  uint8_t Status;
} hci_le_write_suggested_default_data_length_rp0;

typedef PACKED(struct) hci_le_read_local_p256_public_key_rp0_s {
  uint8_t Status;
} hci_le_read_local_p256_public_key_rp0;

typedef PACKED(struct) hci_le_generate_dhkey_cp0_s {
  uint8_t Remote_P256_Public_Key[64];
} hci_le_generate_dhkey_cp0;

typedef PACKED(struct) hci_le_generate_dhkey_rp0_s {
  uint8_t Status;
} hci_le_generate_dhkey_rp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
  uint8_t Peer_IRK[16];
  uint8_t Local_IRK[16];
} hci_le_add_device_to_resolving_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_resolving_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_remove_device_from_resolving_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_resolving_list_rp0;

typedef PACKED(struct) hci_le_clear_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_clear_resolving_list_rp0;

typedef PACKED(struct) hci_le_read_resolving_list_size_rp0_s {
  uint8_t Status;
  uint8_t Resolving_List_Size;
} hci_le_read_resolving_list_size_rp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_read_peer_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_rp0_s {
  uint8_t Status;
  uint8_t Peer_Resolvable_Address[6];
} hci_le_read_peer_resolvable_address_rp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_read_local_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_rp0_s {
  uint8_t Status;
  uint8_t Local_Resolvable_Address[6];
} hci_le_read_local_resolvable_address_rp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_cp0_s {
  uint8_t Address_Resolution_Enable;
} hci_le_set_address_resolution_enable_cp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_rp0_s {
  uint8_t Status;
} hci_le_set_address_resolution_enable_rp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_cp0_s {
  uint16_t RPA_Timeout;
} hci_le_set_resolvable_private_address_timeout_cp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_rp0_s {
  uint8_t Status;
} hci_le_set_resolvable_private_address_timeout_rp0;

typedef PACKED(struct) hci_le_read_maximum_data_length_rp0_s {
  uint8_t Status;
  uint16_t supportedMaxTxOctets;
  uint16_t supportedMaxTxTime;
  uint16_t supportedMaxRxOctets;
  uint16_t supportedMaxRxTime;
} hci_le_read_maximum_data_length_rp0;

typedef PACKED(struct) hci_le_read_phy_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_phy_cp0;

typedef PACKED(struct) hci_le_read_phy_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t TX_PHY;
  uint8_t RX_PHY;
} hci_le_read_phy_rp0;

typedef PACKED(struct) hci_le_set_default_phy_cp0_s {
  uint8_t ALL_PHYS;
  uint8_t TX_PHYS;
  uint8_t RX_PHYS;
} hci_le_set_default_phy_cp0;

typedef PACKED(struct) hci_le_set_default_phy_rp0_s {
  uint8_t Status;
} hci_le_set_default_phy_rp0;

typedef PACKED(struct) hci_le_set_phy_cp0_s {
  uint16_t Connection_Handle;
  uint8_t ALL_PHYS;
  uint8_t TX_PHYS;
  uint8_t RX_PHYS;
  uint16_t PHY_options;
} hci_le_set_phy_cp0;

typedef PACKED(struct) hci_le_set_phy_rp0_s {
  uint8_t Status;
} hci_le_set_phy_rp0;

typedef PACKED(struct) hci_le_receiver_test_v2_cp0_s {
  uint8_t RX_Channel;
  uint8_t PHY;
  uint8_t Modulation_index;
} hci_le_receiver_test_v2_cp0;

typedef PACKED(struct) hci_le_receiver_test_v2_rp0_s {
  uint8_t Status;
} hci_le_receiver_test_v2_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v2_cp0_s {
  uint8_t TX_Channel;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
  uint8_t PHY;
} hci_le_transmitter_test_v2_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v2_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_v2_rp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Advertising_Random_Address[6];
} hci_le_set_advertising_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_set_random_address_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Advertising_Event_Properties;
  uint8_t Primary_Advertising_Interval_Min[3];
  uint8_t Primary_Advertising_Interval_Max[3];
  uint8_t Primary_Advertising_Channel_Map;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Filter_Policy;
  int8_t Advertising_Tx_Power;
  uint8_t Primary_Advertising_PHY;
  uint8_t Secondary_Advertising_Max_Skip;
  uint8_t Secondary_Advertising_PHY;
  uint8_t Advertising_SID;
  uint8_t Scan_Request_Notification_Enable;
} hci_le_set_extended_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_rp0_s {
  uint8_t Status;
  int8_t Selected_Tx_Power;
} hci_le_set_extended_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Fragment_Preference;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_extended_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Fragment_Preference;
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Number_of_Sets;
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} hci_le_set_extended_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_extended_advertising_enable_rp0;

typedef PACKED(struct) hci_le_read_maximum_advertising_data_length_rp0_s {
  uint8_t Status;
  uint16_t Maximum_Advertising_Data_Length;
} hci_le_read_maximum_advertising_data_length_rp0;

typedef PACKED(struct) hci_le_read_number_of_supported_advertising_sets_rp0_s {
  uint8_t Status;
  uint8_t Num_Supported_Advertising_Sets;
} hci_le_read_number_of_supported_advertising_sets_rp0;

typedef PACKED(struct) hci_le_remove_advertising_set_cp0_s {
  uint8_t Advertising_Handle;
} hci_le_remove_advertising_set_cp0;

typedef PACKED(struct) hci_le_remove_advertising_set_rp0_s {
  uint8_t Status;
} hci_le_remove_advertising_set_rp0;

typedef PACKED(struct) hci_le_clear_advertising_sets_rp0_s {
  uint8_t Status;
} hci_le_clear_advertising_sets_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Periodic_Advertising_Interval_Min;
  uint16_t Periodic_Advertising_Interval_Max;
  uint16_t Periodic_Advertising_Properties;
} hci_le_set_periodic_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} hci_le_set_periodic_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_cp0_s {
  uint8_t Own_Address_Type;
  uint8_t Scanning_Filter_Policy;
  uint8_t Scanning_PHYs;
  packed_Extended_Scan_Parameters_t Extended_Scan_Parameters[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_Extended_Scan_Parameters_t)];
} hci_le_set_extended_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_cp0_s {
  uint8_t Enable;
  uint8_t Filter_Duplicates;
  uint16_t Duration;
  uint16_t Period;
} hci_le_set_extended_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_enable_rp0;

typedef PACKED(struct) hci_le_extended_create_connection_cp0_s {
  uint8_t Initiator_Filter_Policy;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Initiating_PHYs;
  packed_Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(packed_Extended_Create_Connection_Parameters_t)];
} hci_le_extended_create_connection_cp0;

typedef PACKED(struct) hci_le_extended_create_connection_rp0_s {
  uint8_t Status;
} hci_le_extended_create_connection_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cp0_s {
  uint8_t Options;
  uint8_t Advertising_SID;
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t Sync_CTE_Type;
} hci_le_periodic_advertising_create_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cancel_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_cancel_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_cp0_s {
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_terminate_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_terminate_sync_rp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} hci_le_add_device_to_periodic_advertiser_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertiser_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} hci_le_remove_device_from_periodic_advertiser_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_clear_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} hci_le_clear_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_read_periodic_advertiser_list_size_rp0_s {
  uint8_t Status;
  uint8_t Periodic_Advertiser_List_Size;
} hci_le_read_periodic_advertiser_list_size_rp0;

typedef PACKED(struct) hci_le_read_transmit_power_rp0_s {
  uint8_t Status;
  int8_t Min_Tx_Power;
  int8_t Max_Tx_Power;
} hci_le_read_transmit_power_rp0;

typedef PACKED(struct) hci_le_read_rf_path_compensation_rp0_s {
  uint8_t Status;
  int16_t RF_TX_Path_Compensation_Value;
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_read_rf_path_compensation_rp0;

typedef PACKED(struct) hci_le_write_rf_path_compensation_cp0_s {
  int16_t RF_TX_Path_Compensation_Value;
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_write_rf_path_compensation_cp0;

typedef PACKED(struct) hci_le_write_rf_path_compensation_rp0_s {
  uint8_t Status;
} hci_le_write_rf_path_compensation_rp0;

typedef PACKED(struct) hci_le_set_privacy_mode_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
  uint8_t Privacy_Mode;
} hci_le_set_privacy_mode_cp0;

typedef PACKED(struct) hci_le_set_privacy_mode_rp0_s {
  uint8_t Status;
} hci_le_set_privacy_mode_rp0;

typedef PACKED(struct) hci_le_receiver_test_v3_cp0_s {
  uint8_t RX_Channel;
  uint8_t PHY;
  uint8_t Modulation_Index;
  uint8_t Expected_CTE_Length;
  uint8_t Expected_CTE_Type;
  uint8_t Slot_Durations;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_receiver_test_v3_cp0;

typedef PACKED(struct) hci_le_receiver_test_v3_rp0_s {
  uint8_t Status;
} hci_le_receiver_test_v3_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v3_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_v3_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t CTE_Count;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connectionless_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t CTE_Enable;
} hci_le_set_connectionless_cte_transmit_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_rp0_s {
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_enable_rp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_cp0_s {
  uint16_t Sync_Handle;
  uint8_t Sampling_Enable;
  uint8_t Slot_Durations;
  uint8_t Max_Sampled_CTEs;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} hci_le_set_connectionless_iq_sampling_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_rp0_s {
  uint8_t Status;
  uint16_t Sync_Handle;
} hci_le_set_connectionless_iq_sampling_enable_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Sampling_Enable;
  uint8_t Slot_Durations;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connection_cte_receive_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_receive_parameters_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_connection_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
  uint16_t CTE_Request_Interval;
  uint8_t Requested_CTE_Length;
  uint8_t Requested_CTE_Type;
} hci_le_connection_cte_request_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_connection_cte_request_enable_rp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
} hci_le_connection_cte_response_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_connection_cte_response_enable_rp0;

typedef PACKED(struct) hci_le_read_antenna_information_rp0_s {
  uint8_t Status;
  uint8_t Supported_Switching_Sampling_Rates;
  uint8_t Num_Antennae;
  uint8_t Max_Switching_Pattern_Length;
  uint8_t Max_CTE_Length;
} hci_le_read_antenna_information_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_cp0_s {
  uint16_t Sync_Handle;
  uint8_t Enable;
} hci_le_set_periodic_advertising_receive_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_receive_enable_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_sync_transfer_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint8_t Advertising_Handle;
} hci_le_periodic_advertising_set_info_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_set_info_transfer_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} hci_le_set_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) hci_le_read_buffer_size_v2_rp0_s {
  uint8_t Status;
  uint16_t HC_LE_ACL_Data_Packet_Length;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets;
  uint16_t ISO_Data_Packet_Length;
  uint8_t Total_Num_ISO_Data_Packets;
} hci_le_read_buffer_size_v2_rp0;

typedef PACKED(struct) hci_le_read_iso_tx_sync_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_iso_tx_sync_cp0;

typedef PACKED(struct) hci_le_read_iso_tx_sync_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint16_t Packet_Sequence_Number;
  uint32_t TX_Time_Stamp;
  uint8_t Time_Offset[3];
} hci_le_read_iso_tx_sync_rp0;

typedef PACKED(struct) hci_le_set_cig_parameters_cp0_s {
  uint8_t CIG_ID;
  uint8_t SDU_Interval_C_To_P[3];
  uint8_t SDU_Interval_P_To_C[3];
  uint8_t Worst_Case_SCA;
  uint8_t Packing;
  uint8_t Framing;
  uint16_t Max_Transport_Latency_C_To_P;
  uint16_t Max_Transport_Latency_P_To_C;
  uint8_t CIS_Count;
  packed_CIS_Param_t CIS_Param[(HCI_MAX_PAYLOAD_SIZE - 15)/sizeof(packed_CIS_Param_t)];
} hci_le_set_cig_parameters_cp0;

typedef PACKED(struct) hci_le_set_cig_parameters_rp0_s {
  uint8_t Status;
  uint8_t CIG_ID;
  uint8_t CIS_Count;
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint16_t)];
} hci_le_set_cig_parameters_rp0;

typedef PACKED(struct) hci_le_set_cig_parameters_test_cp0_s {
  uint8_t CIG_ID;
  uint8_t SDU_Interval_C_To_P[3];
  uint8_t SDU_Interval_P_To_C[3];
  uint8_t FT_C_To_P;
  uint8_t FT_P_To_C;
  uint16_t ISO_Interval;
  uint8_t Worst_Case_SCA;
  uint8_t Packing;
  uint8_t Framing;
  uint8_t CIS_Count;
  packed_CIS_Param_Test_t CIS_Param_Test[(HCI_MAX_PAYLOAD_SIZE - 15)/sizeof(packed_CIS_Param_Test_t)];
} hci_le_set_cig_parameters_test_cp0;

typedef PACKED(struct) hci_le_set_cig_parameters_test_rp0_s {
  uint8_t Status;
  uint8_t CIG_ID;
  uint8_t CIS_Count;
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint16_t)];
} hci_le_set_cig_parameters_test_rp0;

typedef PACKED(struct) hci_le_create_cis_cp0_s {
  uint8_t CIS_Count;
  packed_CIS_Handles_t CIS_Handles[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_CIS_Handles_t)];
} hci_le_create_cis_cp0;

typedef PACKED(struct) hci_le_create_cis_rp0_s {
  uint8_t Status;
} hci_le_create_cis_rp0;

typedef PACKED(struct) hci_le_remove_cig_cp0_s {
  uint8_t CIG_ID;
} hci_le_remove_cig_cp0;

typedef PACKED(struct) hci_le_remove_cig_rp0_s {
  uint8_t Status;
  uint8_t CIG_ID;
} hci_le_remove_cig_rp0;

typedef PACKED(struct) hci_le_accept_cis_request_cp0_s {
  uint16_t Connection_Handle;
} hci_le_accept_cis_request_cp0;

typedef PACKED(struct) hci_le_accept_cis_request_rp0_s {
  uint8_t Status;
} hci_le_accept_cis_request_rp0;

typedef PACKED(struct) hci_le_reject_cis_request_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Reason;
} hci_le_reject_cis_request_cp0;

typedef PACKED(struct) hci_le_reject_cis_request_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_reject_cis_request_rp0;

typedef PACKED(struct) hci_le_create_big_cp0_s {
  uint8_t BIG_Handle;
  uint8_t Advertising_Handle;
  uint8_t Num_BIS;
  uint8_t SDU_Interval[3];
  uint16_t Max_SDU;
  uint16_t Max_Transport_Latency;
  uint8_t RTN;
  uint8_t PHY;
  uint8_t Packing;
  uint8_t Framing;
  uint8_t Encryption;
  uint8_t Broadcast_Code[16];
} hci_le_create_big_cp0;

typedef PACKED(struct) hci_le_create_big_rp0_s {
  uint8_t Status;
} hci_le_create_big_rp0;

typedef PACKED(struct) hci_le_create_big_test_cp0_s {
  uint8_t BIG_Handle;
  uint8_t Advertising_Handle;
  uint8_t Num_BIS;
  uint8_t SDU_Interval[3];
  uint16_t ISO_Interval;
  uint8_t NSE;
  uint16_t Max_SDU;
  uint16_t Max_PDU;
  uint8_t PHY;
  uint8_t Packing;
  uint8_t Framing;
  uint8_t BN;
  uint8_t IRC;
  uint8_t PTO;
  uint8_t Encryption;
  uint8_t Broadcast_Code[16];
} hci_le_create_big_test_cp0;

typedef PACKED(struct) hci_le_create_big_test_rp0_s {
  uint8_t Status;
} hci_le_create_big_test_rp0;

typedef PACKED(struct) hci_le_terminate_big_cp0_s {
  uint8_t BIG_Handle;
  uint8_t Reason;
} hci_le_terminate_big_cp0;

typedef PACKED(struct) hci_le_terminate_big_rp0_s {
  uint8_t Status;
} hci_le_terminate_big_rp0;

typedef PACKED(struct) hci_le_big_create_sync_cp0_s {
  uint8_t BIG_Handle;
  uint16_t Sync_Handle;
  uint8_t Encryption;
  uint8_t Broadcast_Code[16];
  uint8_t MSE;
  uint16_t BIG_Sync_Timeout;
  uint8_t Num_BIS;
  uint8_t BIS[(HCI_MAX_PAYLOAD_SIZE - 24)/sizeof(uint8_t)];
} hci_le_big_create_sync_cp0;

typedef PACKED(struct) hci_le_big_create_sync_rp0_s {
  uint8_t Status;
} hci_le_big_create_sync_rp0;

typedef PACKED(struct) hci_le_big_terminate_sync_cp0_s {
  uint8_t BIG_Handle;
} hci_le_big_terminate_sync_cp0;

typedef PACKED(struct) hci_le_big_terminate_sync_rp0_s {
  uint8_t Status;
  uint8_t BIG_Handle;
} hci_le_big_terminate_sync_rp0;

typedef PACKED(struct) hci_le_request_peer_sca_cp0_s {
  uint16_t Connection_Handle;
} hci_le_request_peer_sca_cp0;

typedef PACKED(struct) hci_le_request_peer_sca_rp0_s {
  uint8_t Status;
} hci_le_request_peer_sca_rp0;

typedef PACKED(struct) hci_le_setup_iso_data_path_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Data_Path_Direction;
  uint8_t Data_Path_ID;
  uint8_t Codec_ID[5];
  uint8_t Controller_Delay[3];
  uint8_t Codec_Configuration_Length;
  uint8_t Codec_Configuration[(HCI_MAX_PAYLOAD_SIZE - 13)/sizeof(uint8_t)];
} hci_le_setup_iso_data_path_cp0;

typedef PACKED(struct) hci_le_setup_iso_data_path_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_setup_iso_data_path_rp0;

typedef PACKED(struct) hci_le_remove_iso_data_path_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Data_Path_Direction;
} hci_le_remove_iso_data_path_cp0;

typedef PACKED(struct) hci_le_remove_iso_data_path_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_remove_iso_data_path_rp0;

typedef PACKED(struct) hci_le_iso_transmit_test_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Payload_Type;
} hci_le_iso_transmit_test_cp0;

typedef PACKED(struct) hci_le_iso_transmit_test_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_iso_transmit_test_rp0;

typedef PACKED(struct) hci_le_iso_receive_test_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Payload_Type;
} hci_le_iso_receive_test_cp0;

typedef PACKED(struct) hci_le_iso_receive_test_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_iso_receive_test_rp0;

typedef PACKED(struct) hci_le_iso_read_test_counters_cp0_s {
  uint16_t Connection_Handle;
} hci_le_iso_read_test_counters_cp0;

typedef PACKED(struct) hci_le_iso_read_test_counters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint32_t Received_Packet_Count;
  uint32_t Missed_Packet_Count;
  uint32_t Failed_Packet_Count;
} hci_le_iso_read_test_counters_rp0;

typedef PACKED(struct) hci_le_iso_test_end_cp0_s {
  uint16_t Connection_Handle;
} hci_le_iso_test_end_cp0;

typedef PACKED(struct) hci_le_iso_test_end_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint32_t Received_Packet_Count;
  uint32_t Missed_Packet_Count;
  uint32_t Failed_Packet_Count;
} hci_le_iso_test_end_rp0;

typedef PACKED(struct) hci_le_set_host_feature_cp0_s {
  uint8_t Bit_Number;
  uint8_t Bit_Value;
} hci_le_set_host_feature_cp0;

typedef PACKED(struct) hci_le_set_host_feature_rp0_s {
  uint8_t Status;
} hci_le_set_host_feature_rp0;

typedef PACKED(struct) hci_le_read_iso_link_quality_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_iso_link_quality_cp0;

typedef PACKED(struct) hci_le_read_iso_link_quality_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint32_t Tx_UnACKed_Packets;
  uint32_t Tx_Flushed_Packets;
  uint32_t Tx_Last_Subevent_Packets;
  uint32_t Retransmitted_Packets;
  uint32_t CRC_Error_Packets;
  uint32_t Rx_Unreceived_Packets;
  uint32_t Duplicate_Packets;
} hci_le_read_iso_link_quality_rp0;

typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t PHY;
} hci_le_enhanced_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t PHY;
  int8_t Current_Transmit_Power_Level;
  int8_t Max_Transmit_Power_Level;
} hci_le_enhanced_read_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t PHY;
} hci_le_read_remote_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_rp0_s {
  uint8_t Status;
} hci_le_read_remote_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t High_Threshold;
  uint8_t High_Hysteresis;
  uint8_t Low_Threshold;
  uint8_t Low_Hysteresis;
  uint16_t Min_Time_Spent;
} hci_le_set_path_loss_reporting_parameters_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_parameters_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
} hci_le_set_path_loss_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_enable_rp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Local_Enable;
  uint8_t Remote_Enable;
} hci_le_set_transmit_power_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_transmit_power_reporting_enable_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v4_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp1_s {
  int8_t Transmit_Power_Level;
} hci_le_transmitter_test_v4_cp1;

typedef PACKED(struct) hci_le_transmitter_test_v4_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_v4_rp0;

typedef PACKED(struct) hci_le_set_data_related_address_changes_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Change_Reasons;
} hci_le_set_data_related_address_changes_cp0;

typedef PACKED(struct) hci_le_set_data_related_address_changes_rp0_s {
  uint8_t Status;
} hci_le_set_data_related_address_changes_rp0;

typedef PACKED(struct) hci_le_set_default_subrate_cp0_s {
  uint16_t Subrate_Min;
  uint16_t Subrate_Max;
  uint16_t Max_Latency;
  uint16_t Continuation_Number;
  uint16_t Supervision_Timeout;
} hci_le_set_default_subrate_cp0;

typedef PACKED(struct) hci_le_set_default_subrate_rp0_s {
  uint8_t Status;
} hci_le_set_default_subrate_rp0;

typedef PACKED(struct) hci_le_subrate_request_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Subrate_Min;
  uint16_t Subrate_Max;
  uint16_t Max_Latency;
  uint16_t Continuation_Number;
  uint16_t Supervision_Timeout;
} hci_le_subrate_request_cp0;

typedef PACKED(struct) hci_le_subrate_request_rp0_s {
  uint8_t Status;
} hci_le_subrate_request_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_v2_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Advertising_Event_Properties;
  uint8_t Primary_Advertising_Interval_Min[3];
  uint8_t Primary_Advertising_Interval_Max[3];
  uint8_t Primary_Advertising_Channel_Map;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Filter_Policy;
  int8_t Advertising_Tx_Power;
  uint8_t Primary_Advertising_PHY;
  uint8_t Secondary_Advertising_Max_Skip;
  uint8_t Secondary_Advertising_PHY;
  uint8_t Advertising_SID;
  uint8_t Scan_Request_Notification_Enable;
  uint8_t Primary_Advertising_PHY_Options;
  uint8_t Secondary_Advertising_PHY_Options;
} hci_le_set_extended_advertising_parameters_v2_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_v2_rp0_s {
  uint8_t Status;
  int8_t Selected_Tx_Power;
} hci_le_set_extended_advertising_parameters_v2_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_subevent_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Num_Subevents;
  packed_Subevent_Data_Parameters_t Subevent_Data_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Subevent_Data_Parameters_t)];
} hci_le_set_periodic_advertising_subevent_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_subevent_data_rp0_s {
  uint8_t Status;
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_subevent_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_response_data_cp0_s {
  uint16_t Sync_Handle;
  uint16_t Request_Event;
  uint8_t Request_Subevent;
  uint8_t Response_Subevent;
  uint8_t Response_Slot;
  uint8_t Response_Data_Length;
  uint8_t Response_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} hci_le_set_periodic_advertising_response_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_response_data_rp0_s {
  uint8_t Status;
  uint16_t Sync_Handle;
} hci_le_set_periodic_advertising_response_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_sync_subevent_cp0_s {
  uint16_t Sync_Handle;
  uint16_t Periodic_Advertising_Properties;
  uint8_t Num_Subevents;
  uint8_t Subevent[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_periodic_sync_subevent_cp0;

typedef PACKED(struct) hci_le_set_periodic_sync_subevent_rp0_s {
  uint8_t Status;
  uint16_t Sync_Handle;
} hci_le_set_periodic_sync_subevent_rp0;

typedef PACKED(struct) hci_le_extended_create_connection_v2_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Subevent;
  uint8_t Initiator_Filter_Policy;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Initiating_PHYs;
  packed_Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(packed_Extended_Create_Connection_Parameters_t)];
} hci_le_extended_create_connection_v2_cp0;

typedef PACKED(struct) hci_le_extended_create_connection_v2_rp0_s {
  uint8_t Status;
} hci_le_extended_create_connection_v2_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_v2_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Periodic_Advertising_Interval_Min;
  uint16_t Periodic_Advertising_Interval_Max;
  uint16_t Periodic_Advertising_Properties;
  uint8_t Num_Subevents;
  uint8_t Subevent_Interval;
  uint8_t Response_Slot_Delay;
  uint8_t Response_Slot_Spacing;
  uint8_t Num_Response_Slots;
} hci_le_set_periodic_advertising_parameters_v2_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_v2_rp0_s {
  uint8_t Status;
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_parameters_v2_rp0;

typedef PACKED(struct) aci_hal_get_fw_build_number_rp0_s {
  uint8_t Status;
  uint16_t Build_Number;
} aci_hal_get_fw_build_number_rp0;

typedef PACKED(struct) aci_hal_get_firmware_details_rp0_s {
  uint8_t Status;
  uint8_t DTM_version_major;
  uint8_t DTM_version_minor;
  uint8_t DTM_version_patch;
  uint8_t DTM_variant;
  uint16_t DTM_Build_Number;
  uint8_t BTLE_Stack_version_major;
  uint8_t BTLE_Stack_version_minor;
  uint8_t BTLE_Stack_version_patch;
  uint8_t BTLE_Stack_development;
  uint16_t BTLE_Stack_variant;
  uint16_t BTLE_Stack_Build_Number;
} aci_hal_get_firmware_details_rp0;

typedef PACKED(struct) aci_hal_get_firmware_details_v2_rp0_s {
  uint8_t Status;
  uint8_t DTM_version_major;
  uint8_t DTM_version_minor;
  uint8_t DTM_version_patch;
  uint8_t DTM_variant;
  uint16_t DTM_Build_Number;
  uint8_t BTLE_Stack_version_major;
  uint8_t BTLE_Stack_version_minor;
  uint8_t BTLE_Stack_version_patch;
  uint8_t BTLE_Stack_development;
  uint32_t BTLE_Stack_variant;
  uint16_t BTLE_Stack_Build_Number;
} aci_hal_get_firmware_details_v2_rp0;

typedef PACKED(struct) aci_hal_write_config_data_cp0_s {
  uint8_t Offset;
  uint8_t Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_write_config_data_cp0;

typedef PACKED(struct) aci_hal_write_config_data_rp0_s {
  uint8_t Status;
} aci_hal_write_config_data_rp0;

typedef PACKED(struct) aci_hal_read_config_data_cp0_s {
  uint8_t Offset;
} aci_hal_read_config_data_cp0;

typedef PACKED(struct) aci_hal_read_config_data_rp0_s {
  uint8_t Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_config_data_rp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_cp0_s {
  uint8_t En_High_Power;
  uint8_t PA_Level;
} aci_hal_set_tx_power_level_cp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_rp0_s {
  uint8_t Status;
} aci_hal_set_tx_power_level_rp0;

typedef PACKED(struct) aci_hal_le_tx_test_packet_number_rp0_s {
  uint8_t Status;
  uint32_t Number_Of_Packets;
} aci_hal_le_tx_test_packet_number_rp0;

typedef PACKED(struct) aci_hal_tone_start_cp0_s {
  uint8_t RF_Channel;
  uint8_t Offset;
} aci_hal_tone_start_cp0;

typedef PACKED(struct) aci_hal_tone_start_rp0_s {
  uint8_t Status;
} aci_hal_tone_start_rp0;

typedef PACKED(struct) aci_hal_tone_stop_rp0_s {
  uint8_t Status;
} aci_hal_tone_stop_rp0;

typedef PACKED(struct) aci_hal_get_link_status_cp0_s {
  uint8_t Bank_index;
} aci_hal_get_link_status_cp0;

typedef PACKED(struct) aci_hal_get_link_status_rp0_s {
  uint8_t Status;
  uint8_t Link_Status[8];
  uint16_t Link_Connection_Handle[16 / 2];
} aci_hal_get_link_status_rp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_cp0_s {
  uint16_t Radio_Activity_Mask;
} aci_hal_set_radio_activity_mask_cp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_rp0_s {
  uint8_t Status;
} aci_hal_set_radio_activity_mask_rp0;

typedef PACKED(struct) aci_hal_set_le_power_control_cp0_s {
  uint8_t Enable;
  uint8_t PHY;
  int8_t RSSI_Target;
  uint8_t RSSI_Hysteresis;
  int8_t Initial_TX_Power;
  uint8_t RSSI_Filtering_Coefficient;
} aci_hal_set_le_power_control_cp0;

typedef PACKED(struct) aci_hal_set_le_power_control_rp0_s {
  uint8_t Status;
} aci_hal_set_le_power_control_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_cp0_s {
  uint8_t TX_Frequency;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
  uint16_t Number_Of_Packets;
  uint8_t PHY;
} aci_hal_transmitter_test_packets_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_rp0_s {
  uint8_t Status;
} aci_hal_transmitter_test_packets_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint16_t Number_Of_Packets;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_hal_transmitter_test_packets_v2_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_rp0_s {
  uint8_t Status;
} aci_hal_transmitter_test_packets_v2_rp0;

typedef PACKED(struct) aci_hal_write_radio_reg_cp0_s {
  uint32_t Start_Address;
  uint8_t Num_Bytes;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_hal_write_radio_reg_cp0;

typedef PACKED(struct) aci_hal_write_radio_reg_rp0_s {
  uint8_t Status;
} aci_hal_write_radio_reg_rp0;

typedef PACKED(struct) aci_hal_read_radio_reg_cp0_s {
  uint32_t Start_Address;
  uint8_t Num_Bytes;
} aci_hal_read_radio_reg_cp0;

typedef PACKED(struct) aci_hal_read_radio_reg_rp0_s {
  uint8_t Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_radio_reg_rp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_cp0_s {
  uint8_t Antenna_IDs;
  uint8_t Antenna_ID_Shift;
  uint8_t Default_Antenna_ID;
  uint8_t RF_Activity_Enable;
} aci_hal_set_antenna_switch_parameters_cp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_rp0_s {
  uint8_t Status;
} aci_hal_set_antenna_switch_parameters_rp0;

typedef PACKED(struct) aci_hal_peripheral_latency_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
} aci_hal_peripheral_latency_enable_cp0;

typedef PACKED(struct) aci_hal_peripheral_latency_enable_rp0_s {
  uint8_t Status;
} aci_hal_peripheral_latency_enable_rp0;

typedef PACKED(struct) aci_hal_get_evt_fifo_max_level_rp0_s {
  uint8_t Status;
  uint16_t ISR0_FIFO_Max_Level;
  uint16_t ISR1_FIFO_Max_Level;
  uint16_t User_FIFO_Max_Level;
} aci_hal_get_evt_fifo_max_level_rp0;

typedef PACKED(struct) aci_gap_init_cp0_s {
  uint8_t Privacy_Type;
  uint8_t Identity_Address_Type;
} aci_gap_init_cp0;

typedef PACKED(struct) aci_gap_init_rp0_s {
  uint8_t Status;
} aci_gap_init_rp0;

typedef PACKED(struct) aci_gap_set_io_capability_cp0_s {
  uint8_t IO_Capability;
} aci_gap_set_io_capability_cp0;

typedef PACKED(struct) aci_gap_set_io_capability_rp0_s {
  uint8_t Status;
} aci_gap_set_io_capability_rp0;

typedef PACKED(struct) aci_gap_set_security_requirements_cp0_s {
  uint8_t Bonding_Mode;
  uint8_t MITM_Mode;
  uint8_t SC_Support;
  uint8_t KeyPress_Notification_Support;
  uint8_t Min_Encryption_Key_Size;
  uint8_t Max_Encryption_Key_Size;
  uint8_t Pairing_Response;
} aci_gap_set_security_requirements_cp0;

typedef PACKED(struct) aci_gap_set_security_requirements_rp0_s {
  uint8_t Status;
} aci_gap_set_security_requirements_rp0;

typedef PACKED(struct) aci_gap_passkey_resp_cp0_s {
  uint16_t Connection_Handle;
  uint32_t Passkey;
} aci_gap_passkey_resp_cp0;

typedef PACKED(struct) aci_gap_passkey_resp_rp0_s {
  uint8_t Status;
} aci_gap_passkey_resp_rp0;

typedef PACKED(struct) aci_gap_profile_init_cp0_s {
  uint8_t Role;
  uint8_t Privacy_Type;
} aci_gap_profile_init_cp0;

typedef PACKED(struct) aci_gap_profile_init_rp0_s {
  uint8_t Status;
  uint16_t Dev_Name_Char_Handle;
  uint16_t Appearance_Char_Handle;
  uint16_t Periph_Pref_Conn_Param_Char_Handle;
} aci_gap_profile_init_rp0;

typedef PACKED(struct) aci_gap_set_security_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Security_Level;
  uint8_t Force_Pairing;
} aci_gap_set_security_cp0;

typedef PACKED(struct) aci_gap_set_security_rp0_s {
  uint8_t Status;
} aci_gap_set_security_rp0;

typedef PACKED(struct) aci_gap_get_security_level_cp0_s {
  uint16_t Connection_Handle;
} aci_gap_get_security_level_cp0;

typedef PACKED(struct) aci_gap_get_security_level_rp0_s {
  uint8_t Status;
  uint8_t Security_Mode;
  uint8_t Security_Level;
} aci_gap_get_security_level_rp0;

typedef PACKED(struct) aci_gap_set_le_event_mask_cp0_s {
  uint8_t LE_Event_Mask[8];
} aci_gap_set_le_event_mask_cp0;

typedef PACKED(struct) aci_gap_set_le_event_mask_rp0_s {
  uint8_t Status;
} aci_gap_set_le_event_mask_rp0;

typedef PACKED(struct) aci_gap_terminate_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Reason;
} aci_gap_terminate_cp0;

typedef PACKED(struct) aci_gap_terminate_rp0_s {
  uint8_t Status;
} aci_gap_terminate_rp0;

typedef PACKED(struct) aci_gap_clear_security_db_rp0_s {
  uint8_t Status;
} aci_gap_clear_security_db_rp0;

typedef PACKED(struct) aci_gap_pairing_resp_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Accept;
} aci_gap_pairing_resp_cp0;

typedef PACKED(struct) aci_gap_pairing_resp_rp0_s {
  uint8_t Status;
} aci_gap_pairing_resp_rp0;

typedef PACKED(struct) aci_gap_create_connection_cp0_s {
  uint8_t Initiating_PHY;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_create_connection_cp0;

typedef PACKED(struct) aci_gap_create_connection_rp0_s {
  uint8_t Status;
} aci_gap_create_connection_rp0;

typedef PACKED(struct) aci_gap_terminate_proc_cp0_s {
  uint8_t Procedure_Code;
} aci_gap_terminate_proc_cp0;

typedef PACKED(struct) aci_gap_terminate_proc_rp0_s {
  uint8_t Status;
} aci_gap_terminate_proc_rp0;

typedef PACKED(struct) aci_gap_start_connection_update_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Max_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
} aci_gap_start_connection_update_cp0;

typedef PACKED(struct) aci_gap_start_connection_update_rp0_s {
  uint8_t Status;
} aci_gap_start_connection_update_rp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_cp0_s {
  uint8_t Address[6];
} aci_gap_resolve_private_addr_cp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_rp0_s {
  uint8_t Status;
  uint8_t Actual_Address[6];
} aci_gap_resolve_private_addr_rp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_cp0_s {
  uint8_t Offset;
  uint8_t Max_Num_Of_Addresses;
} aci_gap_get_bonded_devices_cp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_rp0_s {
  uint8_t Status;
  uint8_t Num_of_Addresses;
  packed_Bonded_Device_Entry_t Bonded_Device_Entry[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Bonded_Device_Entry_t)];
} aci_gap_get_bonded_devices_rp0;

typedef PACKED(struct) aci_gap_is_device_bonded_cp0_s {
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_is_device_bonded_cp0;

typedef PACKED(struct) aci_gap_is_device_bonded_rp0_s {
  uint8_t Status;
} aci_gap_is_device_bonded_rp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Confirm_Yes_No;
} aci_gap_numeric_comparison_value_confirm_yesno_cp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_rp0_s {
  uint8_t Status;
} aci_gap_numeric_comparison_value_confirm_yesno_rp0;

typedef PACKED(struct) aci_gap_passkey_input_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Input_Type;
} aci_gap_passkey_input_cp0;

typedef PACKED(struct) aci_gap_passkey_input_rp0_s {
  uint8_t Status;
} aci_gap_passkey_input_rp0;

typedef PACKED(struct) aci_gap_get_oob_data_cp0_s {
  uint8_t OOB_Data_Type;
} aci_gap_get_oob_data_cp0;

typedef PACKED(struct) aci_gap_get_oob_data_rp0_s {
  uint8_t Status;
  uint8_t Address_Type;
  uint8_t Address[6];
  uint8_t OOB_Data_Type;
  uint8_t OOB_Data_Len;
  uint8_t OOB_Data[16];
} aci_gap_get_oob_data_rp0;

typedef PACKED(struct) aci_gap_set_oob_data_cp0_s {
  uint8_t Device_Type;
  uint8_t Address_Type;
  uint8_t Address[6];
  uint8_t OOB_Data_Type;
  uint8_t OOB_Data_Len;
  uint8_t OOB_Data[16];
} aci_gap_set_oob_data_cp0;

typedef PACKED(struct) aci_gap_set_oob_data_rp0_s {
  uint8_t Status;
} aci_gap_set_oob_data_rp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} aci_gap_remove_bonded_device_cp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_rp0_s {
  uint8_t Status;
} aci_gap_remove_bonded_device_rp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Discoverable_Mode;
  uint16_t Advertising_Event_Properties;
  uint32_t Primary_Advertising_Interval_Min;
  uint32_t Primary_Advertising_Interval_Max;
  uint8_t Primary_Advertising_Channel_Map;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Filter_Policy;
  int8_t Advertising_Tx_Power;
  uint8_t Primary_Advertising_PHY;
  uint8_t Secondary_Advertising_Max_Skip;
  uint8_t Secondary_Advertising_PHY;
  uint8_t Advertising_SID;
  uint8_t Scan_Request_Notification_Enable;
} aci_gap_set_advertising_configuration_cp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_configuration_rp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Number_of_Sets;
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} aci_gap_set_advertising_enable_cp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_enable_rp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_advertising_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_scan_response_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_rp0_s {
  uint8_t Status;
} aci_gap_set_scan_response_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_cp0_s {
  uint8_t Filter_Duplicates;
  uint8_t Scanning_Filter_Policy;
  uint8_t Scanning_PHY;
  uint8_t Scan_Type;
  uint16_t Scan_Interval;
  uint16_t Scan_Window;
} aci_gap_set_scan_configuration_cp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_scan_configuration_rp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_cp0_s {
  uint8_t Initiating_PHY;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Max_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
} aci_gap_set_connection_configuration_cp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_connection_configuration_rp0;

typedef PACKED(struct) aci_gap_start_procedure_cp0_s {
  uint8_t Procedure_Code;
  uint8_t PHYs;
  uint16_t Duration;
  uint16_t Period;
} aci_gap_start_procedure_cp0;

typedef PACKED(struct) aci_gap_start_procedure_rp0_s {
  uint8_t Status;
} aci_gap_start_procedure_rp0;

typedef PACKED(struct) aci_gap_discover_name_cp0_s {
  uint8_t PHYs;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_discover_name_cp0;

typedef PACKED(struct) aci_gap_discover_name_rp0_s {
  uint8_t Status;
} aci_gap_discover_name_rp0;

typedef PACKED(struct) aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0_s {
  uint8_t Lists;
  uint8_t Clear_Lists;
  uint8_t Num_of_List_Entries;
  packed_List_Entry_t List_Entry[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_List_Entry_t)];
} aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_add_devices_to_filter_accept_and_resolving_list_rp0_s {
  uint8_t Status;
} aci_gap_add_devices_to_filter_accept_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_configure_filter_accept_and_resolving_list_cp0_s {
  uint8_t Lists;
} aci_gap_configure_filter_accept_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_configure_filter_accept_and_resolving_list_rp0_s {
  uint8_t Status;
} aci_gap_configure_filter_accept_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_cp0_s {
  uint8_t Advertising_Handle;
} aci_gap_remove_advertising_set_cp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_rp0_s {
  uint8_t Status;
} aci_gap_remove_advertising_set_rp0;

typedef PACKED(struct) aci_gap_clear_advertising_sets_rp0_s {
  uint8_t Status;
} aci_gap_clear_advertising_sets_rp0;

typedef PACKED(struct) aci_gap_create_periodic_advertising_connection_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Subevent;
  uint8_t Initiator_Filter_Policy;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Max_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
} aci_gap_create_periodic_advertising_connection_cp0;

typedef PACKED(struct) aci_gap_create_periodic_advertising_connection_rp0_s {
  uint8_t Status;
} aci_gap_create_periodic_advertising_connection_rp0;

typedef PACKED(struct) aci_gap_encrypt_adv_data_nwk_cp0_s {
  uint8_t Session_Key[16];
  uint8_t IV[8];
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 25)/sizeof(uint8_t)];
} aci_gap_encrypt_adv_data_nwk_cp0;

typedef PACKED(struct) aci_gap_encrypt_adv_data_nwk_rp0_s {
  uint8_t Status;
  uint8_t Encrypted_Data_Length;
  uint8_t Encrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_gap_encrypt_adv_data_nwk_rp0;

typedef PACKED(struct) aci_gap_decrypt_adv_data_nwk_cp0_s {
  uint8_t Session_Key[16];
  uint8_t IV[8];
  uint8_t Encrypted_Data_Length;
  uint8_t Encrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 25)/sizeof(uint8_t)];
} aci_gap_decrypt_adv_data_nwk_cp0;

typedef PACKED(struct) aci_gap_decrypt_adv_data_nwk_rp0_s {
  uint8_t Status;
  uint8_t Decrypted_Data_Length;
  uint8_t Decrypted_Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_gap_decrypt_adv_data_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_profile_init_cp0_s {
  uint8_t Characteristics;
} aci_gatt_srv_profile_init_cp0;

typedef PACKED(struct) aci_gatt_srv_profile_init_rp0_s {
  uint8_t Status;
  uint16_t Service_Changed_Handle;
} aci_gatt_srv_profile_init_rp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp0_s {
  uint8_t Service_UUID_Type;
  packed_Service_UUID_t Service_UUID;
} aci_gatt_srv_add_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp1_s {
  uint8_t Service_Type;
  uint8_t Max_Attribute_Records;
} aci_gatt_srv_add_service_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_rp0_s {
  uint8_t Status;
  uint16_t Service_Handle;
} aci_gatt_srv_add_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_cp0_s {
  uint16_t Service_Handle;
  uint16_t Included_Service_Handle;
} aci_gatt_srv_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_rp0_s {
  uint8_t Status;
  uint16_t Include_Handle;
} aci_gatt_srv_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp0_s {
  uint16_t Service_Handle;
  uint8_t Char_UUID_Type;
  packed_Char_UUID_t Char_UUID;
} aci_gatt_srv_add_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp1_s {
  uint16_t Char_Value_Length;
  uint8_t Char_Properties;
  uint8_t Security_Permissions;
  uint8_t GATT_Evt_Mask;
  uint8_t Enc_Key_Size;
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_rp0_s {
  uint8_t Status;
  uint16_t Char_Handle;
} aci_gatt_srv_add_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp0_s {
  uint16_t Char_Handle;
  uint8_t Char_Desc_Uuid_Type;
  packed_Char_Desc_Uuid_t Char_Desc_Uuid;
} aci_gatt_srv_add_char_desc_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp1_s {
  uint16_t Char_Desc_Value_Max_Len;
  uint16_t Char_Desc_Value_Length;
  uint8_t Char_Desc_Value[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_gatt_srv_add_char_desc_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp2_s {
  uint8_t Security_Permissions;
  uint8_t Access_Permissions;
  uint8_t GATT_Evt_Mask;
  uint8_t Enc_Key_Size;
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_desc_nwk_cp2;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_rp0_s {
  uint8_t Status;
  uint16_t Char_Desc_Handle;
} aci_gatt_srv_add_char_desc_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_write_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_cp0_s {
  uint16_t Char_Handle;
} aci_gatt_srv_rm_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_cp0_s {
  uint16_t Serv_Handle;
} aci_gatt_srv_rm_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_cp0_s {
  uint16_t Include_Handle;
} aci_gatt_srv_rm_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_set_event_mask_cp0_s {
  uint32_t GATT_Evt_Mask;
} aci_gatt_set_event_mask_cp0;

typedef PACKED(struct) aci_gatt_set_event_mask_rp0_s {
  uint8_t Status;
} aci_gatt_set_event_mask_rp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_cp0_s {
  uint16_t Connection_Handle;
} aci_gatt_clt_exchange_config_cp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_rp0_s {
  uint8_t Status;
} aci_gatt_clt_exchange_config_rp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_prepare_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_rp0_s {
  uint8_t Status;
} aci_gatt_clt_prepare_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint8_t Execute;
} aci_gatt_clt_execute_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_rp0_s {
  uint8_t Status;
} aci_gatt_clt_execute_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
} aci_gatt_clt_disc_all_primary_services_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_primary_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_disc_primary_service_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_primary_service_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Start_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_find_included_services_cp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_rp0_s {
  uint8_t Status;
} aci_gatt_clt_find_included_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Start_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_of_service_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_char_of_service_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Start_Handle;
  uint16_t End_Handle;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_disc_char_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_char_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Char_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_desc_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_char_desc_rp0;

typedef PACKED(struct) aci_gatt_clt_read_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
} aci_gatt_clt_read_cp0;

typedef PACKED(struct) aci_gatt_clt_read_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_rp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Start_Handle;
  uint16_t End_Handle;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_read_using_char_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_using_char_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_read_long_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
} aci_gatt_clt_read_long_cp0;

typedef PACKED(struct) aci_gatt_clt_read_long_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_long_rp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint8_t Number_of_Handles;
  uint16_t Handle[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint16_t)];
} aci_gatt_clt_read_multiple_char_value_cp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_multiple_char_value_rp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_write_long_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_long_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_clt_write_char_reliable_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_char_reliable_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_signed_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_rp0_s {
  uint8_t Status;
} aci_gatt_clt_signed_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
} aci_gatt_clt_confirm_indication_cp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_rp0_s {
  uint8_t Status;
} aci_gatt_clt_confirm_indication_rp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint8_t Security_Permissions;
} aci_gatt_srv_set_security_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_set_security_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint16_t Offset;
  uint16_t Value_Length_Requested;
} aci_gatt_srv_read_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_rp0_s {
  uint8_t Status;
  uint16_t Length;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_gatt_srv_read_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint8_t Access_Permissions;
} aci_gatt_srv_set_access_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_set_access_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_notify_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint8_t Flags;
  uint16_t Val_Length;
  uint8_t Val[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_gatt_srv_notify_cp0;

typedef PACKED(struct) aci_gatt_srv_notify_rp0_s {
  uint8_t Status;
} aci_gatt_srv_notify_rp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint16_t CID;
  uint8_t Exec;
} aci_gatt_srv_exec_write_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_exec_write_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint8_t Operation_Type;
  uint8_t Error_Code;
  uint16_t Attr_Val_Offset;
  uint16_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_authorize_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint8_t Item_Index;
} aci_gatt_srv_read_prepare_queue_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_rp0_s {
  uint8_t Status;
  uint16_t Attr_Handle;
  uint16_t Value_Offset;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_srv_read_prepare_queue_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_multiple_instance_handle_value_cp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_rp0_s {
  uint8_t Status;
} aci_gatt_srv_write_multiple_instance_handle_value_rp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0_s {
  uint8_t Status;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_multi_notify_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint8_t Flags;
  uint8_t Num_Of_Attr;
  packed_Gatt_Srv_Notify_Attr_t Gatt_Srv_Notify_Attr[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(packed_Gatt_Srv_Notify_Attr_t)];
} aci_gatt_srv_multi_notify_cp0;

typedef PACKED(struct) aci_gatt_srv_multi_notify_rp0_s {
  uint8_t Status;
} aci_gatt_srv_multi_notify_rp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_var_len_char_value_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint8_t Number_of_Handles;
  uint16_t Handle[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint16_t)];
} aci_gatt_clt_read_multiple_var_len_char_value_cp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_var_len_char_value_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_multiple_var_len_char_value_rp0;

typedef PACKED(struct) aci_gatt_clt_add_subscription_security_level_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint16_t Char_Value_Handle;
  uint8_t Sec_Level;
} aci_gatt_clt_add_subscription_security_level_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_add_subscription_security_level_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_add_subscription_security_level_nwk_rp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Peripheral_Latency;
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_parameter_update_req_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_rp0_s {
  uint8_t Status;
} aci_l2cap_connection_parameter_update_req_rp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Connection_Interval_Min;
  uint16_t Connection_Interval_Max;
  uint16_t Peripheral_Latency;
  uint16_t Timeout_Multiplier;
  uint16_t Min_CE_Length;
  uint16_t Max_CE_Length;
  uint8_t Identifier;
  uint8_t Accept;
} aci_l2cap_connection_parameter_update_resp_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_rp0_s {
  uint8_t Status;
} aci_l2cap_connection_parameter_update_resp_rp0;

typedef PACKED(struct) aci_l2cap_cos_connection_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t SPSM;
  uint16_t MTU;
  uint16_t MPS;
  uint8_t Channel_Type;
  uint8_t CID_Count;
} aci_l2cap_cos_connection_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_connection_req_rp0_s {
  uint8_t Status;
} aci_l2cap_cos_connection_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_connection_resp_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Identifier;
  uint16_t MTU;
  uint16_t MPS;
  uint16_t Result;
  uint8_t CID_Count;
} aci_l2cap_cos_connection_resp_cp0;

typedef PACKED(struct) aci_l2cap_cos_connection_resp_rp0_s {
  uint8_t Status;
  uint8_t CID_Count;
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint16_t)];
} aci_l2cap_cos_connection_resp_rp0;

typedef PACKED(struct) aci_l2cap_cos_flow_control_credits_ind_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t RX_Credits;
  uint8_t CFC_Policy;
} aci_l2cap_cos_flow_control_credits_ind_cp0;

typedef PACKED(struct) aci_l2cap_cos_flow_control_credits_ind_rp0_s {
  uint8_t Status;
  uint16_t RX_Credit_Balance;
} aci_l2cap_cos_flow_control_credits_ind_rp0;

typedef PACKED(struct) aci_l2cap_cos_disconnect_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
} aci_l2cap_cos_disconnect_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_disconnect_req_rp0_s {
  uint8_t Status;
} aci_l2cap_cos_disconnect_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_sdu_data_transmit_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t SDU_Length;
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_cos_sdu_data_transmit_cp0;

typedef PACKED(struct) aci_l2cap_cos_sdu_data_transmit_rp0_s {
  uint8_t Status;
} aci_l2cap_cos_sdu_data_transmit_rp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t MTU;
  uint16_t MPS;
  uint8_t CID_Count;
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint16_t)];
} aci_l2cap_cos_reconfigure_req_cp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_req_rp0_s {
  uint8_t Status;
} aci_l2cap_cos_reconfigure_req_rp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_resp_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Identifier;
  uint16_t Result;
} aci_l2cap_cos_reconfigure_resp_cp0;

typedef PACKED(struct) aci_l2cap_cos_reconfigure_resp_rp0_s {
  uint8_t Status;
} aci_l2cap_cos_reconfigure_resp_rp0;

typedef PACKED(struct) aci_test_tx_notification_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Handle;
  uint16_t Char_Handle;
  uint16_t Value_Length;
} aci_test_tx_notification_start_cp0;

typedef PACKED(struct) aci_test_tx_notification_start_rp0_s {
  uint8_t Status;
} aci_test_tx_notification_start_rp0;

typedef PACKED(struct) aci_test_tx_write_command_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Value_Length;
} aci_test_tx_write_command_start_cp0;

typedef PACKED(struct) aci_test_tx_write_command_start_rp0_s {
  uint8_t Status;
} aci_test_tx_write_command_start_rp0;

typedef PACKED(struct) aci_test_rx_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint8_t Notifications_WriteCmds;
} aci_test_rx_start_cp0;

typedef PACKED(struct) aci_test_rx_start_rp0_s {
  uint8_t Status;
} aci_test_rx_start_rp0;

typedef PACKED(struct) aci_test_stop_cp0_s {
  uint8_t TX_RX;
} aci_test_stop_cp0;

typedef PACKED(struct) aci_test_stop_rp0_s {
  uint8_t Status;
} aci_test_stop_rp0;

typedef PACKED(struct) aci_test_report_rp0_s {
  uint8_t Status;
  uint32_t TX_Packets;
  uint32_t RX_Packets;
  uint16_t RX_Data_Length;
  uint32_t RX_Sequence_Errors;
} aci_test_report_rp0;

typedef PACKED(struct) aci_blue_initialized_event_rp0_s {
  uint8_t Reason_Code;
} aci_blue_initialized_event_rp0;

typedef PACKED(struct) aci_blue_crash_info_event_rp0_s {
  uint8_t Crash_Type;
  uint32_t SP;
  uint32_t R0;
  uint32_t R1;
  uint32_t R2;
  uint32_t R3;
  uint32_t R12;
  uint32_t LR;
  uint32_t PC;
  uint32_t xPSR;
  uint8_t Debug_Data_Length;
  uint8_t Debug_Data[(HCI_MAX_PAYLOAD_SIZE - 38)/sizeof(uint8_t)];
} aci_blue_crash_info_event_rp0;

typedef PACKED(struct) aci_hal_le_test_end_event_rp0_s {
  uint16_t Number_Of_Packets;
} aci_hal_le_test_end_event_rp0;

typedef PACKED(struct) aci_l2cap_cos_sdu_data_rx_nwk_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t RX_Credit_Balance;
  uint16_t SDU_Length;
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_l2cap_cos_sdu_data_rx_nwk_event_rp0;

typedef PACKED(struct) aci_gatt_srv_authorize_nwk_event_rp0_s {
  uint16_t Conn_Handle;
  uint16_t CID;
  uint16_t Attr_Handle;
  uint8_t Operation_Type;
  uint16_t Attr_Val_Offset;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_nwk_event_rp0;

uint16_t hci_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_remote_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_connection_accept_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_write_connection_accept_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_afh_channel_assessment_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_write_afh_channel_assessment_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_set_event_mask_page_2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_write_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_local_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_local_supported_commands_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_bd_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_rssi_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_buffer_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_advertising_physical_channel_tx_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_connection_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_filter_accept_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_host_channel_classification_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_channel_map_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_remote_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_encrypt_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_rand_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_enable_encryption_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_long_term_key_request_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_long_term_key_request_negative_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_supported_states_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_write_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_p256_public_key_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_generate_dhkey_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_resolving_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_peer_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_address_resolution_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_resolvable_private_address_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_maximum_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_default_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_receiver_test_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_maximum_advertising_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_number_of_supported_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_extended_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_transmit_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_write_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_privacy_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_receiver_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_cte_transmit_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_iq_sampling_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connection_cte_receive_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connection_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_cte_request_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_cte_response_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_antenna_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_buffer_size_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_iso_tx_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_cig_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_cig_parameters_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_cis_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_cig_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_accept_cis_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_reject_cis_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_big_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_big_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_terminate_big_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_big_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_big_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_request_peer_sca_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_setup_iso_data_path_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_iso_data_path_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_iso_transmit_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_iso_receive_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_iso_read_test_counters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_iso_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_host_feature_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_iso_link_quality_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_enhanced_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_remote_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_path_loss_reporting_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_path_loss_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_transmit_power_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_v4_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_data_related_address_changes_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_default_subrate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_subrate_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_parameters_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_subevent_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_sync_subevent_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_extended_create_connection_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_parameters_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_fw_build_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_firmware_details_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_firmware_details_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_write_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_read_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_tx_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_le_tx_test_packet_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_tone_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_tone_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_link_status_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_radio_activity_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_le_power_control_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_transmitter_test_packets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_transmitter_test_packets_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_write_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_read_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_antenna_switch_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_peripheral_latency_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_evt_fifo_max_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_io_capability_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_security_requirements_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_passkey_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_profile_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_security_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_security_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_le_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_terminate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_clear_security_db_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_pairing_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_terminate_proc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_start_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_resolve_private_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_bonded_devices_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_is_device_bonded_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_numeric_comparison_value_confirm_yesno_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_passkey_input_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_remove_bonded_device_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_scan_response_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_scan_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_connection_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_start_procedure_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_discover_name_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_add_devices_to_filter_accept_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_configure_filter_accept_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_create_periodic_advertising_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_encrypt_adv_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_decrypt_adv_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_profile_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_char_desc_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_write_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_exchange_config_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_prepare_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_execute_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_primary_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_primary_service_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_find_included_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_char_of_service_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_char_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_char_desc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_using_char_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_long_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_multiple_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_long_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_char_reliable_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_signed_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_confirm_indication_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_set_security_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_set_access_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_exec_write_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_authorize_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_prepare_queue_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_write_multiple_instance_handle_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_multiple_instance_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_multi_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_multiple_var_len_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_add_subscription_security_level_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_connection_parameter_update_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_connection_parameter_update_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_connection_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_connection_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_flow_control_credits_ind_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_disconnect_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_sdu_data_transmit_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_reconfigure_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cos_reconfigure_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_tx_notification_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_tx_write_command_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_rx_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_report_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
const hci_command_table_type hci_command_table[] = {
#if (!defined(HCI_DISCONNECT_ENABLED) || HCI_DISCONNECT_ENABLED) && !HCI_DISCONNECT_FORCE_DISABLED
  /* hci_disconnect */
  {0x0406, hci_disconnect_process},
#endif
#if (!defined(HCI_READ_REMOTE_VERSION_INFORMATION_ENABLED) || HCI_READ_REMOTE_VERSION_INFORMATION_ENABLED) && !HCI_READ_REMOTE_VERSION_INFORMATION_FORCE_DISABLED
  /* hci_read_remote_version_information */
  {0x041d, hci_read_remote_version_information_process},
#endif
#if (!defined(HCI_SET_EVENT_MASK_ENABLED) || HCI_SET_EVENT_MASK_ENABLED) && !HCI_SET_EVENT_MASK_FORCE_DISABLED
  /* hci_set_event_mask */
  {0x0c01, hci_set_event_mask_process},
#endif
#if (!defined(HCI_READ_CONNECTION_ACCEPT_TIMEOUT_ENABLED) || HCI_READ_CONNECTION_ACCEPT_TIMEOUT_ENABLED) && !HCI_READ_CONNECTION_ACCEPT_TIMEOUT_FORCE_DISABLED
  /* hci_read_connection_accept_timeout */
  {0x0c15, hci_read_connection_accept_timeout_process},
#endif
#if (!defined(HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_ENABLED) || HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_ENABLED) && !HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_FORCE_DISABLED
  /* hci_write_connection_accept_timeout */
  {0x0c16, hci_write_connection_accept_timeout_process},
#endif
#if (!defined(HCI_READ_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_READ_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_READ_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
  /* hci_read_transmit_power_level */
  {0x0c2d, hci_read_transmit_power_level_process},
#endif
#if (!defined(HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) || HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) && !HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_FORCE_DISABLED
  /* hci_read_afh_channel_assessment_mode */
  {0x0c48, hci_read_afh_channel_assessment_mode_process},
#endif
#if (!defined(HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) || HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) && !HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_FORCE_DISABLED
  /* hci_write_afh_channel_assessment_mode */
  {0x0c49, hci_write_afh_channel_assessment_mode_process},
#endif
#if (!defined(HCI_SET_EVENT_MASK_PAGE_2_ENABLED) || HCI_SET_EVENT_MASK_PAGE_2_ENABLED) && !HCI_SET_EVENT_MASK_PAGE_2_FORCE_DISABLED
  /* hci_set_event_mask_page_2 */
  {0x0c63, hci_set_event_mask_page_2_process},
#endif
#if (!defined(HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) || HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) && !HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_FORCE_DISABLED
  /* hci_read_authenticated_payload_timeout */
  {0x0c7b, hci_read_authenticated_payload_timeout_process},
#endif
#if (!defined(HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) || HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) && !HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_FORCE_DISABLED
  /* hci_write_authenticated_payload_timeout */
  {0x0c7c, hci_write_authenticated_payload_timeout_process},
#endif
#if (!defined(HCI_READ_LOCAL_VERSION_INFORMATION_ENABLED) || HCI_READ_LOCAL_VERSION_INFORMATION_ENABLED) && !HCI_READ_LOCAL_VERSION_INFORMATION_FORCE_DISABLED
  /* hci_read_local_version_information */
  {0x1001, hci_read_local_version_information_process},
#endif
#if (!defined(HCI_READ_LOCAL_SUPPORTED_COMMANDS_ENABLED) || HCI_READ_LOCAL_SUPPORTED_COMMANDS_ENABLED) && !HCI_READ_LOCAL_SUPPORTED_COMMANDS_FORCE_DISABLED
  /* hci_read_local_supported_commands */
  {0x1002, hci_read_local_supported_commands_process},
#endif
#if (!defined(HCI_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) || HCI_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) && !HCI_READ_LOCAL_SUPPORTED_FEATURES_FORCE_DISABLED
  /* hci_read_local_supported_features */
  {0x1003, hci_read_local_supported_features_process},
#endif
#if (!defined(HCI_READ_BD_ADDR_ENABLED) || HCI_READ_BD_ADDR_ENABLED) && !HCI_READ_BD_ADDR_FORCE_DISABLED
  /* hci_read_bd_addr */
  {0x1009, hci_read_bd_addr_process},
#endif
#if (!defined(HCI_READ_RSSI_ENABLED) || HCI_READ_RSSI_ENABLED) && !HCI_READ_RSSI_FORCE_DISABLED
  /* hci_read_rssi */
  {0x1405, hci_read_rssi_process},
#endif
#if (!defined(HCI_LE_SET_EVENT_MASK_ENABLED) || HCI_LE_SET_EVENT_MASK_ENABLED) && !HCI_LE_SET_EVENT_MASK_FORCE_DISABLED
  /* hci_le_set_event_mask */
  {0x2001, hci_le_set_event_mask_process},
#endif
#if (!defined(HCI_LE_READ_BUFFER_SIZE_ENABLED) || HCI_LE_READ_BUFFER_SIZE_ENABLED) && !HCI_LE_READ_BUFFER_SIZE_FORCE_DISABLED
  /* hci_le_read_buffer_size */
  {0x2002, hci_le_read_buffer_size_process},
#endif
#if (!defined(HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) || HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) && !HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_FORCE_DISABLED
  /* hci_le_read_local_supported_features */
  {0x2003, hci_le_read_local_supported_features_process},
#endif
#if (!defined(HCI_LE_SET_RANDOM_ADDRESS_ENABLED) || HCI_LE_SET_RANDOM_ADDRESS_ENABLED) && !HCI_LE_SET_RANDOM_ADDRESS_FORCE_DISABLED
  /* hci_le_set_random_address */
  {0x2005, hci_le_set_random_address_process},
#endif
#if (!defined(HCI_LE_SET_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_ADVERTISING_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_advertising_parameters */
  {0x2006, hci_le_set_advertising_parameters_process},
#endif
#if (!defined(HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_ENABLED) || HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_ENABLED) && !HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_FORCE_DISABLED
  /* hci_le_read_advertising_physical_channel_tx_power */
  {0x2007, hci_le_read_advertising_physical_channel_tx_power_process},
#endif
#if (!defined(HCI_LE_SET_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_ADVERTISING_DATA_FORCE_DISABLED
  /* hci_le_set_advertising_data */
  {0x2008, hci_le_set_advertising_data_process},
#endif
#if (!defined(HCI_LE_SET_SCAN_RESPONSE_DATA_ENABLED) || HCI_LE_SET_SCAN_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_SCAN_RESPONSE_DATA_FORCE_DISABLED
  /* hci_le_set_scan_response_data */
  {0x2009, hci_le_set_scan_response_data_process},
#endif
#if (!defined(HCI_LE_SET_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_ADVERTISING_ENABLE_FORCE_DISABLED
  /* hci_le_set_advertising_enable */
  {0x200a, hci_le_set_advertising_enable_process},
#endif
#if (!defined(HCI_LE_SET_SCAN_PARAMETERS_ENABLED) || HCI_LE_SET_SCAN_PARAMETERS_ENABLED) && !HCI_LE_SET_SCAN_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_scan_parameters */
  {0x200b, hci_le_set_scan_parameters_process},
#endif
#if (!defined(HCI_LE_SET_SCAN_ENABLE_ENABLED) || HCI_LE_SET_SCAN_ENABLE_ENABLED) && !HCI_LE_SET_SCAN_ENABLE_FORCE_DISABLED
  /* hci_le_set_scan_enable */
  {0x200c, hci_le_set_scan_enable_process},
#endif
#if (!defined(HCI_LE_CREATE_CONNECTION_ENABLED) || HCI_LE_CREATE_CONNECTION_ENABLED) && !HCI_LE_CREATE_CONNECTION_FORCE_DISABLED
  /* hci_le_create_connection */
  {0x200d, hci_le_create_connection_process},
#endif
#if (!defined(HCI_LE_CREATE_CONNECTION_CANCEL_ENABLED) || HCI_LE_CREATE_CONNECTION_CANCEL_ENABLED) && !HCI_LE_CREATE_CONNECTION_CANCEL_FORCE_DISABLED
  /* hci_le_create_connection_cancel */
  {0x200e, hci_le_create_connection_cancel_process},
#endif
#if (!defined(HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_ENABLED) || HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_ENABLED) && !HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_FORCE_DISABLED
  /* hci_le_read_filter_accept_list_size */
  {0x200f, hci_le_read_filter_accept_list_size_process},
#endif
#if (!defined(HCI_LE_CLEAR_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_CLEAR_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_CLEAR_FILTER_ACCEPT_LIST_FORCE_DISABLED
  /* hci_le_clear_filter_accept_list */
  {0x2010, hci_le_clear_filter_accept_list_process},
#endif
#if (!defined(HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_FORCE_DISABLED
  /* hci_le_add_device_to_filter_accept_list */
  {0x2011, hci_le_add_device_to_filter_accept_list_process},
#endif
#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_FORCE_DISABLED
  /* hci_le_remove_device_from_filter_accept_list */
  {0x2012, hci_le_remove_device_from_filter_accept_list_process},
#endif
#if (!defined(HCI_LE_CONNECTION_UPDATE_ENABLED) || HCI_LE_CONNECTION_UPDATE_ENABLED) && !HCI_LE_CONNECTION_UPDATE_FORCE_DISABLED
  /* hci_le_connection_update */
  {0x2013, hci_le_connection_update_process},
#endif
#if (!defined(HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_ENABLED) || HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_ENABLED) && !HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_FORCE_DISABLED
  /* hci_le_set_host_channel_classification */
  {0x2014, hci_le_set_host_channel_classification_process},
#endif
#if (!defined(HCI_LE_READ_CHANNEL_MAP_ENABLED) || HCI_LE_READ_CHANNEL_MAP_ENABLED) && !HCI_LE_READ_CHANNEL_MAP_FORCE_DISABLED
  /* hci_le_read_channel_map */
  {0x2015, hci_le_read_channel_map_process},
#endif
#if (!defined(HCI_LE_READ_REMOTE_FEATURES_ENABLED) || HCI_LE_READ_REMOTE_FEATURES_ENABLED) && !HCI_LE_READ_REMOTE_FEATURES_FORCE_DISABLED
  /* hci_le_read_remote_features */
  {0x2016, hci_le_read_remote_features_process},
#endif
#if (!defined(HCI_LE_ENCRYPT_ENABLED) || HCI_LE_ENCRYPT_ENABLED) && !HCI_LE_ENCRYPT_FORCE_DISABLED
  /* hci_le_encrypt */
  {0x2017, hci_le_encrypt_process},
#endif
#if (!defined(HCI_LE_RAND_ENABLED) || HCI_LE_RAND_ENABLED) && !HCI_LE_RAND_FORCE_DISABLED
  /* hci_le_rand */
  {0x2018, hci_le_rand_process},
#endif
#if (!defined(HCI_LE_ENABLE_ENCRYPTION_ENABLED) || HCI_LE_ENABLE_ENCRYPTION_ENABLED) && !HCI_LE_ENABLE_ENCRYPTION_FORCE_DISABLED
  /* hci_le_enable_encryption */
  {0x2019, hci_le_enable_encryption_process},
#endif
#if (!defined(HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_ENABLED) || HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_ENABLED) && !HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_FORCE_DISABLED
  /* hci_le_long_term_key_request_reply */
  {0x201a, hci_le_long_term_key_request_reply_process},
#endif
#if (!defined(HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_ENABLED) || HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_ENABLED) && !HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_FORCE_DISABLED
  /* hci_le_long_term_key_request_negative_reply */
  {0x201b, hci_le_long_term_key_request_negative_reply_process},
#endif
#if (!defined(HCI_LE_READ_SUPPORTED_STATES_ENABLED) || HCI_LE_READ_SUPPORTED_STATES_ENABLED) && !HCI_LE_READ_SUPPORTED_STATES_FORCE_DISABLED
  /* hci_le_read_supported_states */
  {0x201c, hci_le_read_supported_states_process},
#endif
#if (!defined(HCI_LE_RECEIVER_TEST_ENABLED) || HCI_LE_RECEIVER_TEST_ENABLED) && !HCI_LE_RECEIVER_TEST_FORCE_DISABLED
  /* hci_le_receiver_test */
  {0x201d, hci_le_receiver_test_process},
#endif
#if (!defined(HCI_LE_TRANSMITTER_TEST_ENABLED) || HCI_LE_TRANSMITTER_TEST_ENABLED) && !HCI_LE_TRANSMITTER_TEST_FORCE_DISABLED
  /* hci_le_transmitter_test */
  {0x201e, hci_le_transmitter_test_process},
#endif
#if (!defined(HCI_LE_TEST_END_ENABLED) || HCI_LE_TEST_END_ENABLED) && !HCI_LE_TEST_END_FORCE_DISABLED
  /* hci_le_test_end */
  {0x201f, hci_le_test_end_process},
#endif
#if (!defined(HCI_LE_SET_DATA_LENGTH_ENABLED) || HCI_LE_SET_DATA_LENGTH_ENABLED) && !HCI_LE_SET_DATA_LENGTH_FORCE_DISABLED
  /* hci_le_set_data_length */
  {0x2022, hci_le_set_data_length_process},
#endif
#if (!defined(HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) || HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) && !HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_FORCE_DISABLED
  /* hci_le_read_suggested_default_data_length */
  {0x2023, hci_le_read_suggested_default_data_length_process},
#endif
#if (!defined(HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) || HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) && !HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_FORCE_DISABLED
  /* hci_le_write_suggested_default_data_length */
  {0x2024, hci_le_write_suggested_default_data_length_process},
#endif
#if (!defined(HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_ENABLED) || HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_ENABLED) && !HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_FORCE_DISABLED
  /* hci_le_read_local_p256_public_key */
  {0x2025, hci_le_read_local_p256_public_key_process},
#endif
#if (!defined(HCI_LE_GENERATE_DHKEY_ENABLED) || HCI_LE_GENERATE_DHKEY_ENABLED) && !HCI_LE_GENERATE_DHKEY_FORCE_DISABLED
  /* hci_le_generate_dhkey */
  {0x2026, hci_le_generate_dhkey_process},
#endif
#if (!defined(HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_FORCE_DISABLED
  /* hci_le_add_device_to_resolving_list */
  {0x2027, hci_le_add_device_to_resolving_list_process},
#endif
#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_FORCE_DISABLED
  /* hci_le_remove_device_from_resolving_list */
  {0x2028, hci_le_remove_device_from_resolving_list_process},
#endif
#if (!defined(HCI_LE_CLEAR_RESOLVING_LIST_ENABLED) || HCI_LE_CLEAR_RESOLVING_LIST_ENABLED) && !HCI_LE_CLEAR_RESOLVING_LIST_FORCE_DISABLED
  /* hci_le_clear_resolving_list */
  {0x2029, hci_le_clear_resolving_list_process},
#endif
#if (!defined(HCI_LE_READ_RESOLVING_LIST_SIZE_ENABLED) || HCI_LE_READ_RESOLVING_LIST_SIZE_ENABLED) && !HCI_LE_READ_RESOLVING_LIST_SIZE_FORCE_DISABLED
  /* hci_le_read_resolving_list_size */
  {0x202a, hci_le_read_resolving_list_size_process},
#endif
#if (!defined(HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_ENABLED) || HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_ENABLED) && !HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_FORCE_DISABLED
  /* hci_le_read_peer_resolvable_address */
  {0x202b, hci_le_read_peer_resolvable_address_process},
#endif
#if (!defined(HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_ENABLED) || HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_ENABLED) && !HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_FORCE_DISABLED
  /* hci_le_read_local_resolvable_address */
  {0x202c, hci_le_read_local_resolvable_address_process},
#endif
#if (!defined(HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_ENABLED) || HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_ENABLED) && !HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_FORCE_DISABLED
  /* hci_le_set_address_resolution_enable */
  {0x202d, hci_le_set_address_resolution_enable_process},
#endif
#if (!defined(HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_ENABLED) || HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_ENABLED) && !HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_FORCE_DISABLED
  /* hci_le_set_resolvable_private_address_timeout */
  {0x202e, hci_le_set_resolvable_private_address_timeout_process},
#endif
#if (!defined(HCI_LE_READ_MAXIMUM_DATA_LENGTH_ENABLED) || HCI_LE_READ_MAXIMUM_DATA_LENGTH_ENABLED) && !HCI_LE_READ_MAXIMUM_DATA_LENGTH_FORCE_DISABLED
  /* hci_le_read_maximum_data_length */
  {0x202f, hci_le_read_maximum_data_length_process},
#endif
#if (!defined(HCI_LE_READ_PHY_ENABLED) || HCI_LE_READ_PHY_ENABLED) && !HCI_LE_READ_PHY_FORCE_DISABLED
  /* hci_le_read_phy */
  {0x2030, hci_le_read_phy_process},
#endif
#if (!defined(HCI_LE_SET_DEFAULT_PHY_ENABLED) || HCI_LE_SET_DEFAULT_PHY_ENABLED) && !HCI_LE_SET_DEFAULT_PHY_FORCE_DISABLED
  /* hci_le_set_default_phy */
  {0x2031, hci_le_set_default_phy_process},
#endif
#if (!defined(HCI_LE_SET_PHY_ENABLED) || HCI_LE_SET_PHY_ENABLED) && !HCI_LE_SET_PHY_FORCE_DISABLED
  /* hci_le_set_phy */
  {0x2032, hci_le_set_phy_process},
#endif
#if (!defined(HCI_LE_RECEIVER_TEST_V2_ENABLED) || HCI_LE_RECEIVER_TEST_V2_ENABLED) && !HCI_LE_RECEIVER_TEST_V2_FORCE_DISABLED
  /* hci_le_receiver_test_v2 */
  {0x2033, hci_le_receiver_test_v2_process},
#endif
#if (!defined(HCI_LE_TRANSMITTER_TEST_V2_ENABLED) || HCI_LE_TRANSMITTER_TEST_V2_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V2_FORCE_DISABLED
  /* hci_le_transmitter_test_v2 */
  {0x2034, hci_le_transmitter_test_v2_process},
#endif
#if (!defined(HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_ENABLED) || HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_ENABLED) && !HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_FORCE_DISABLED
  /* hci_le_set_advertising_set_random_address */
  {0x2035, hci_le_set_advertising_set_random_address_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_extended_advertising_parameters */
  {0x2036, hci_le_set_extended_advertising_parameters_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_DATA_FORCE_DISABLED
  /* hci_le_set_extended_advertising_data */
  {0x2037, hci_le_set_extended_advertising_data_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_FORCE_DISABLED
  /* hci_le_set_extended_scan_response_data */
  {0x2038, hci_le_set_extended_scan_response_data_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_FORCE_DISABLED
  /* hci_le_set_extended_advertising_enable */
  {0x2039, hci_le_set_extended_advertising_enable_process},
#endif
#if (!defined(HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_ENABLED) || HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_ENABLED) && !HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_FORCE_DISABLED
  /* hci_le_read_maximum_advertising_data_length */
  {0x203a, hci_le_read_maximum_advertising_data_length_process},
#endif
#if (!defined(HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_ENABLED) || HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_ENABLED) && !HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_FORCE_DISABLED
  /* hci_le_read_number_of_supported_advertising_sets */
  {0x203b, hci_le_read_number_of_supported_advertising_sets_process},
#endif
#if (!defined(HCI_LE_REMOVE_ADVERTISING_SET_ENABLED) || HCI_LE_REMOVE_ADVERTISING_SET_ENABLED) && !HCI_LE_REMOVE_ADVERTISING_SET_FORCE_DISABLED
  /* hci_le_remove_advertising_set */
  {0x203c, hci_le_remove_advertising_set_process},
#endif
#if (!defined(HCI_LE_CLEAR_ADVERTISING_SETS_ENABLED) || HCI_LE_CLEAR_ADVERTISING_SETS_ENABLED) && !HCI_LE_CLEAR_ADVERTISING_SETS_FORCE_DISABLED
  /* hci_le_clear_advertising_sets */
  {0x203d, hci_le_clear_advertising_sets_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_parameters */
  {0x203e, hci_le_set_periodic_advertising_parameters_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_DATA_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_data */
  {0x203f, hci_le_set_periodic_advertising_data_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_enable */
  {0x2040, hci_le_set_periodic_advertising_enable_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_extended_scan_parameters */
  {0x2041, hci_le_set_extended_scan_parameters_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_SCAN_ENABLE_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_ENABLE_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_ENABLE_FORCE_DISABLED
  /* hci_le_set_extended_scan_enable */
  {0x2042, hci_le_set_extended_scan_enable_process},
#endif
#if (!defined(HCI_LE_EXTENDED_CREATE_CONNECTION_ENABLED) || HCI_LE_EXTENDED_CREATE_CONNECTION_ENABLED) && !HCI_LE_EXTENDED_CREATE_CONNECTION_FORCE_DISABLED
  /* hci_le_extended_create_connection */
  {0x2043, hci_le_extended_create_connection_process},
#endif
#if (!defined(HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_FORCE_DISABLED
  /* hci_le_periodic_advertising_create_sync */
  {0x2044, hci_le_periodic_advertising_create_sync_process},
#endif
#if (!defined(HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_FORCE_DISABLED
  /* hci_le_periodic_advertising_create_sync_cancel */
  {0x2045, hci_le_periodic_advertising_create_sync_cancel_process},
#endif
#if (!defined(HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_FORCE_DISABLED
  /* hci_le_periodic_advertising_terminate_sync */
  {0x2046, hci_le_periodic_advertising_terminate_sync_process},
#endif
#if (!defined(HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
  /* hci_le_add_device_to_periodic_advertiser_list */
  {0x2047, hci_le_add_device_to_periodic_advertiser_list_process},
#endif
#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
  /* hci_le_remove_device_from_periodic_advertiser_list */
  {0x2048, hci_le_remove_device_from_periodic_advertiser_list_process},
#endif
#if (!defined(HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
  /* hci_le_clear_periodic_advertiser_list */
  {0x2049, hci_le_clear_periodic_advertiser_list_process},
#endif
#if (!defined(HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_ENABLED) || HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_ENABLED) && !HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_FORCE_DISABLED
  /* hci_le_read_periodic_advertiser_list_size */
  {0x204a, hci_le_read_periodic_advertiser_list_size_process},
#endif
#if (!defined(HCI_LE_READ_TRANSMIT_POWER_ENABLED) || HCI_LE_READ_TRANSMIT_POWER_ENABLED) && !HCI_LE_READ_TRANSMIT_POWER_FORCE_DISABLED
  /* hci_le_read_transmit_power */
  {0x204b, hci_le_read_transmit_power_process},
#endif
#if (!defined(HCI_LE_READ_RF_PATH_COMPENSATION_ENABLED) || HCI_LE_READ_RF_PATH_COMPENSATION_ENABLED) && !HCI_LE_READ_RF_PATH_COMPENSATION_FORCE_DISABLED
  /* hci_le_read_rf_path_compensation */
  {0x204c, hci_le_read_rf_path_compensation_process},
#endif
#if (!defined(HCI_LE_WRITE_RF_PATH_COMPENSATION_ENABLED) || HCI_LE_WRITE_RF_PATH_COMPENSATION_ENABLED) && !HCI_LE_WRITE_RF_PATH_COMPENSATION_FORCE_DISABLED
  /* hci_le_write_rf_path_compensation */
  {0x204d, hci_le_write_rf_path_compensation_process},
#endif
#if (!defined(HCI_LE_SET_PRIVACY_MODE_ENABLED) || HCI_LE_SET_PRIVACY_MODE_ENABLED) && !HCI_LE_SET_PRIVACY_MODE_FORCE_DISABLED
  /* hci_le_set_privacy_mode */
  {0x204e, hci_le_set_privacy_mode_process},
#endif
#if (!defined(HCI_LE_RECEIVER_TEST_V3_ENABLED) || HCI_LE_RECEIVER_TEST_V3_ENABLED) && !HCI_LE_RECEIVER_TEST_V3_FORCE_DISABLED
  /* hci_le_receiver_test_v3 */
  {0x204f, hci_le_receiver_test_v3_process},
#endif
#if (!defined(HCI_LE_TRANSMITTER_TEST_V3_ENABLED) || HCI_LE_TRANSMITTER_TEST_V3_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V3_FORCE_DISABLED
  /* hci_le_transmitter_test_v3 */
  {0x2050, hci_le_transmitter_test_v3_process},
#endif
#if (!defined(HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_connectionless_cte_transmit_parameters */
  {0x2051, hci_le_set_connectionless_cte_transmit_parameters_process},
#endif
#if (!defined(HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_ENABLED) || HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_FORCE_DISABLED
  /* hci_le_set_connectionless_cte_transmit_enable */
  {0x2052, hci_le_set_connectionless_cte_transmit_enable_process},
#endif
#if (!defined(HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_ENABLED) || HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_FORCE_DISABLED
  /* hci_le_set_connectionless_iq_sampling_enable */
  {0x2053, hci_le_set_connectionless_iq_sampling_enable_process},
#endif
#if (!defined(HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_connection_cte_receive_parameters */
  {0x2054, hci_le_set_connection_cte_receive_parameters_process},
#endif
#if (!defined(HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_connection_cte_transmit_parameters */
  {0x2055, hci_le_set_connection_cte_transmit_parameters_process},
#endif
#if (!defined(HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_ENABLED) || HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_ENABLED) && !HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_FORCE_DISABLED
  /* hci_le_connection_cte_request_enable */
  {0x2056, hci_le_connection_cte_request_enable_process},
#endif
#if (!defined(HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_ENABLED) || HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_ENABLED) && !HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_FORCE_DISABLED
  /* hci_le_connection_cte_response_enable */
  {0x2057, hci_le_connection_cte_response_enable_process},
#endif
#if (!defined(HCI_LE_READ_ANTENNA_INFORMATION_ENABLED) || HCI_LE_READ_ANTENNA_INFORMATION_ENABLED) && !HCI_LE_READ_ANTENNA_INFORMATION_FORCE_DISABLED
  /* hci_le_read_antenna_information */
  {0x2058, hci_le_read_antenna_information_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_receive_enable */
  {0x2059, hci_le_set_periodic_advertising_receive_enable_process},
#endif
#if (!defined(HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_FORCE_DISABLED
  /* hci_le_periodic_advertising_sync_transfer */
  {0x205a, hci_le_periodic_advertising_sync_transfer_process},
#endif
#if (!defined(HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_FORCE_DISABLED
  /* hci_le_periodic_advertising_set_info_transfer */
  {0x205b, hci_le_periodic_advertising_set_info_transfer_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_sync_transfer_parameters */
  {0x205c, hci_le_set_periodic_advertising_sync_transfer_parameters_process},
#endif
#if (!defined(HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) || HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) && !HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_default_periodic_advertising_sync_transfer_parameters */
  {0x205d, hci_le_set_default_periodic_advertising_sync_transfer_parameters_process},
#endif
#if (!defined(HCI_LE_READ_BUFFER_SIZE_V2_ENABLED) || HCI_LE_READ_BUFFER_SIZE_V2_ENABLED) && !HCI_LE_READ_BUFFER_SIZE_V2_FORCE_DISABLED
  /* hci_le_read_buffer_size_v2 */
  {0x2060, hci_le_read_buffer_size_v2_process},
#endif
#if (!defined(HCI_LE_READ_ISO_TX_SYNC_ENABLED) || HCI_LE_READ_ISO_TX_SYNC_ENABLED) && !HCI_LE_READ_ISO_TX_SYNC_FORCE_DISABLED
  /* hci_le_read_iso_tx_sync */
  {0x2061, hci_le_read_iso_tx_sync_process},
#endif
#if (!defined(HCI_LE_SET_CIG_PARAMETERS_ENABLED) || HCI_LE_SET_CIG_PARAMETERS_ENABLED) && !HCI_LE_SET_CIG_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_cig_parameters */
  {0x2062, hci_le_set_cig_parameters_process},
#endif
#if (!defined(HCI_LE_SET_CIG_PARAMETERS_TEST_ENABLED) || HCI_LE_SET_CIG_PARAMETERS_TEST_ENABLED) && !HCI_LE_SET_CIG_PARAMETERS_TEST_FORCE_DISABLED
  /* hci_le_set_cig_parameters_test */
  {0x2063, hci_le_set_cig_parameters_test_process},
#endif
#if (!defined(HCI_LE_CREATE_CIS_ENABLED) || HCI_LE_CREATE_CIS_ENABLED) && !HCI_LE_CREATE_CIS_FORCE_DISABLED
  /* hci_le_create_cis */
  {0x2064, hci_le_create_cis_process},
#endif
#if (!defined(HCI_LE_REMOVE_CIG_ENABLED) || HCI_LE_REMOVE_CIG_ENABLED) && !HCI_LE_REMOVE_CIG_FORCE_DISABLED
  /* hci_le_remove_cig */
  {0x2065, hci_le_remove_cig_process},
#endif
#if (!defined(HCI_LE_ACCEPT_CIS_REQUEST_ENABLED) || HCI_LE_ACCEPT_CIS_REQUEST_ENABLED) && !HCI_LE_ACCEPT_CIS_REQUEST_FORCE_DISABLED
  /* hci_le_accept_cis_request */
  {0x2066, hci_le_accept_cis_request_process},
#endif
#if (!defined(HCI_LE_REJECT_CIS_REQUEST_ENABLED) || HCI_LE_REJECT_CIS_REQUEST_ENABLED) && !HCI_LE_REJECT_CIS_REQUEST_FORCE_DISABLED
  /* hci_le_reject_cis_request */
  {0x2067, hci_le_reject_cis_request_process},
#endif
#if (!defined(HCI_LE_CREATE_BIG_ENABLED) || HCI_LE_CREATE_BIG_ENABLED) && !HCI_LE_CREATE_BIG_FORCE_DISABLED
  /* hci_le_create_big */
  {0x2068, hci_le_create_big_process},
#endif
#if (!defined(HCI_LE_CREATE_BIG_TEST_ENABLED) || HCI_LE_CREATE_BIG_TEST_ENABLED) && !HCI_LE_CREATE_BIG_TEST_FORCE_DISABLED
  /* hci_le_create_big_test */
  {0x2069, hci_le_create_big_test_process},
#endif
#if (!defined(HCI_LE_TERMINATE_BIG_ENABLED) || HCI_LE_TERMINATE_BIG_ENABLED) && !HCI_LE_TERMINATE_BIG_FORCE_DISABLED
  /* hci_le_terminate_big */
  {0x206a, hci_le_terminate_big_process},
#endif
#if (!defined(HCI_LE_BIG_CREATE_SYNC_ENABLED) || HCI_LE_BIG_CREATE_SYNC_ENABLED) && !HCI_LE_BIG_CREATE_SYNC_FORCE_DISABLED
  /* hci_le_big_create_sync */
  {0x206b, hci_le_big_create_sync_process},
#endif
#if (!defined(HCI_LE_BIG_TERMINATE_SYNC_ENABLED) || HCI_LE_BIG_TERMINATE_SYNC_ENABLED) && !HCI_LE_BIG_TERMINATE_SYNC_FORCE_DISABLED
  /* hci_le_big_terminate_sync */
  {0x206c, hci_le_big_terminate_sync_process},
#endif
#if (!defined(HCI_LE_REQUEST_PEER_SCA_ENABLED) || HCI_LE_REQUEST_PEER_SCA_ENABLED) && !HCI_LE_REQUEST_PEER_SCA_FORCE_DISABLED
  /* hci_le_request_peer_sca */
  {0x206d, hci_le_request_peer_sca_process},
#endif
#if (!defined(HCI_LE_SETUP_ISO_DATA_PATH_ENABLED) || HCI_LE_SETUP_ISO_DATA_PATH_ENABLED) && !HCI_LE_SETUP_ISO_DATA_PATH_FORCE_DISABLED
  /* hci_le_setup_iso_data_path */
  {0x206e, hci_le_setup_iso_data_path_process},
#endif
#if (!defined(HCI_LE_REMOVE_ISO_DATA_PATH_ENABLED) || HCI_LE_REMOVE_ISO_DATA_PATH_ENABLED) && !HCI_LE_REMOVE_ISO_DATA_PATH_FORCE_DISABLED
  /* hci_le_remove_iso_data_path */
  {0x206f, hci_le_remove_iso_data_path_process},
#endif
#if (!defined(HCI_LE_ISO_TRANSMIT_TEST_ENABLED) || HCI_LE_ISO_TRANSMIT_TEST_ENABLED) && !HCI_LE_ISO_TRANSMIT_TEST_FORCE_DISABLED
  /* hci_le_iso_transmit_test */
  {0x2070, hci_le_iso_transmit_test_process},
#endif
#if (!defined(HCI_LE_ISO_RECEIVE_TEST_ENABLED) || HCI_LE_ISO_RECEIVE_TEST_ENABLED) && !HCI_LE_ISO_RECEIVE_TEST_FORCE_DISABLED
  /* hci_le_iso_receive_test */
  {0x2071, hci_le_iso_receive_test_process},
#endif
#if (!defined(HCI_LE_ISO_READ_TEST_COUNTERS_ENABLED) || HCI_LE_ISO_READ_TEST_COUNTERS_ENABLED) && !HCI_LE_ISO_READ_TEST_COUNTERS_FORCE_DISABLED
  /* hci_le_iso_read_test_counters */
  {0x2072, hci_le_iso_read_test_counters_process},
#endif
#if (!defined(HCI_LE_ISO_TEST_END_ENABLED) || HCI_LE_ISO_TEST_END_ENABLED) && !HCI_LE_ISO_TEST_END_FORCE_DISABLED
  /* hci_le_iso_test_end */
  {0x2073, hci_le_iso_test_end_process},
#endif
#if (!defined(HCI_LE_SET_HOST_FEATURE_ENABLED) || HCI_LE_SET_HOST_FEATURE_ENABLED) && !HCI_LE_SET_HOST_FEATURE_FORCE_DISABLED
  /* hci_le_set_host_feature */
  {0x2074, hci_le_set_host_feature_process},
#endif
#if (!defined(HCI_LE_READ_ISO_LINK_QUALITY_ENABLED) || HCI_LE_READ_ISO_LINK_QUALITY_ENABLED) && !HCI_LE_READ_ISO_LINK_QUALITY_FORCE_DISABLED
  /* hci_le_read_iso_link_quality */
  {0x2075, hci_le_read_iso_link_quality_process},
#endif
#if (!defined(HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
  /* hci_le_enhanced_read_transmit_power_level */
  {0x2076, hci_le_enhanced_read_transmit_power_level_process},
#endif
#if (!defined(HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
  /* hci_le_read_remote_transmit_power_level */
  {0x2077, hci_le_read_remote_transmit_power_level_process},
#endif
#if (!defined(HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_ENABLED) || HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_ENABLED) && !HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_FORCE_DISABLED
  /* hci_le_set_path_loss_reporting_parameters */
  {0x2078, hci_le_set_path_loss_reporting_parameters_process},
#endif
#if (!defined(HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_ENABLED) || HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_ENABLED) && !HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_FORCE_DISABLED
  /* hci_le_set_path_loss_reporting_enable */
  {0x2079, hci_le_set_path_loss_reporting_enable_process},
#endif
#if (!defined(HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_ENABLED) || HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_ENABLED) && !HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_FORCE_DISABLED
  /* hci_le_set_transmit_power_reporting_enable */
  {0x207a, hci_le_set_transmit_power_reporting_enable_process},
#endif
#if (!defined(HCI_LE_TRANSMITTER_TEST_V4_ENABLED) || HCI_LE_TRANSMITTER_TEST_V4_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V4_FORCE_DISABLED
  /* hci_le_transmitter_test_v4 */
  {0x207b, hci_le_transmitter_test_v4_process},
#endif
#if (!defined(HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_ENABLED) || HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_ENABLED) && !HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_FORCE_DISABLED
  /* hci_le_set_data_related_address_changes */
  {0x207c, hci_le_set_data_related_address_changes_process},
#endif
#if (!defined(HCI_LE_SET_DEFAULT_SUBRATE_ENABLED) || HCI_LE_SET_DEFAULT_SUBRATE_ENABLED) && !HCI_LE_SET_DEFAULT_SUBRATE_FORCE_DISABLED
  /* hci_le_set_default_subrate */
  {0x207d, hci_le_set_default_subrate_process},
#endif
#if (!defined(HCI_LE_SUBRATE_REQUEST_ENABLED) || HCI_LE_SUBRATE_REQUEST_ENABLED) && !HCI_LE_SUBRATE_REQUEST_FORCE_DISABLED
  /* hci_le_subrate_request */
  {0x207e, hci_le_subrate_request_process},
#endif
#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_FORCE_DISABLED
  /* hci_le_set_extended_advertising_parameters_v2 */
  {0x207f, hci_le_set_extended_advertising_parameters_v2_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_subevent_data */
  {0x2082, hci_le_set_periodic_advertising_subevent_data_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_response_data */
  {0x2083, hci_le_set_periodic_advertising_response_data_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_ENABLED) || HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_ENABLED) && !HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_FORCE_DISABLED
  /* hci_le_set_periodic_sync_subevent */
  {0x2084, hci_le_set_periodic_sync_subevent_process},
#endif
#if (!defined(HCI_LE_EXTENDED_CREATE_CONNECTION_V2_ENABLED) || HCI_LE_EXTENDED_CREATE_CONNECTION_V2_ENABLED) && !HCI_LE_EXTENDED_CREATE_CONNECTION_V2_FORCE_DISABLED
  /* hci_le_extended_create_connection_v2 */
  {0x2085, hci_le_extended_create_connection_v2_process},
#endif
#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_FORCE_DISABLED
  /* hci_le_set_periodic_advertising_parameters_v2 */
  {0x2086, hci_le_set_periodic_advertising_parameters_v2_process},
#endif
#if (!defined(ACI_HAL_GET_FW_BUILD_NUMBER_ENABLED) || ACI_HAL_GET_FW_BUILD_NUMBER_ENABLED) && !ACI_HAL_GET_FW_BUILD_NUMBER_FORCE_DISABLED
  /* aci_hal_get_fw_build_number */
  {0xfc00, aci_hal_get_fw_build_number_process},
#endif
#if (!defined(ACI_HAL_GET_FIRMWARE_DETAILS_ENABLED) || ACI_HAL_GET_FIRMWARE_DETAILS_ENABLED) && !ACI_HAL_GET_FIRMWARE_DETAILS_FORCE_DISABLED
  /* aci_hal_get_firmware_details */
  {0xfc01, aci_hal_get_firmware_details_process},
#endif
#if (!defined(ACI_HAL_GET_FIRMWARE_DETAILS_V2_ENABLED) || ACI_HAL_GET_FIRMWARE_DETAILS_V2_ENABLED) && !ACI_HAL_GET_FIRMWARE_DETAILS_V2_FORCE_DISABLED
  /* aci_hal_get_firmware_details_v2 */
  {0xfc02, aci_hal_get_firmware_details_v2_process},
#endif
#if (!defined(ACI_HAL_WRITE_CONFIG_DATA_ENABLED) || ACI_HAL_WRITE_CONFIG_DATA_ENABLED) && !ACI_HAL_WRITE_CONFIG_DATA_FORCE_DISABLED
  /* aci_hal_write_config_data */
  {0xfc0c, aci_hal_write_config_data_process},
#endif
#if (!defined(ACI_HAL_READ_CONFIG_DATA_ENABLED) || ACI_HAL_READ_CONFIG_DATA_ENABLED) && !ACI_HAL_READ_CONFIG_DATA_FORCE_DISABLED
  /* aci_hal_read_config_data */
  {0xfc0d, aci_hal_read_config_data_process},
#endif
#if (!defined(ACI_HAL_SET_TX_POWER_LEVEL_ENABLED) || ACI_HAL_SET_TX_POWER_LEVEL_ENABLED) && !ACI_HAL_SET_TX_POWER_LEVEL_FORCE_DISABLED
  /* aci_hal_set_tx_power_level */
  {0xfc0f, aci_hal_set_tx_power_level_process},
#endif
#if (!defined(ACI_HAL_LE_TX_TEST_PACKET_NUMBER_ENABLED) || ACI_HAL_LE_TX_TEST_PACKET_NUMBER_ENABLED) && !ACI_HAL_LE_TX_TEST_PACKET_NUMBER_FORCE_DISABLED
  /* aci_hal_le_tx_test_packet_number */
  {0xfc14, aci_hal_le_tx_test_packet_number_process},
#endif
#if (!defined(ACI_HAL_TONE_START_ENABLED) || ACI_HAL_TONE_START_ENABLED) && !ACI_HAL_TONE_START_FORCE_DISABLED
  /* aci_hal_tone_start */
  {0xfc15, aci_hal_tone_start_process},
#endif
#if (!defined(ACI_HAL_TONE_STOP_ENABLED) || ACI_HAL_TONE_STOP_ENABLED) && !ACI_HAL_TONE_STOP_FORCE_DISABLED
  /* aci_hal_tone_stop */
  {0xfc16, aci_hal_tone_stop_process},
#endif
#if (!defined(ACI_HAL_GET_LINK_STATUS_ENABLED) || ACI_HAL_GET_LINK_STATUS_ENABLED) && !ACI_HAL_GET_LINK_STATUS_FORCE_DISABLED
  /* aci_hal_get_link_status */
  {0xfc17, aci_hal_get_link_status_process},
#endif
#if (!defined(ACI_HAL_SET_RADIO_ACTIVITY_MASK_ENABLED) || ACI_HAL_SET_RADIO_ACTIVITY_MASK_ENABLED) && !ACI_HAL_SET_RADIO_ACTIVITY_MASK_FORCE_DISABLED
  /* aci_hal_set_radio_activity_mask */
  {0xfc18, aci_hal_set_radio_activity_mask_process},
#endif
#if (!defined(ACI_HAL_SET_LE_POWER_CONTROL_ENABLED) || ACI_HAL_SET_LE_POWER_CONTROL_ENABLED) && !ACI_HAL_SET_LE_POWER_CONTROL_FORCE_DISABLED
  /* aci_hal_set_le_power_control */
  {0xfc1c, aci_hal_set_le_power_control_process},
#endif
#if (!defined(ACI_HAL_TRANSMITTER_TEST_PACKETS_ENABLED) || ACI_HAL_TRANSMITTER_TEST_PACKETS_ENABLED) && !ACI_HAL_TRANSMITTER_TEST_PACKETS_FORCE_DISABLED
  /* aci_hal_transmitter_test_packets */
  {0xfc2b, aci_hal_transmitter_test_packets_process},
#endif
#if (!defined(ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_ENABLED) || ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_ENABLED) && !ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_FORCE_DISABLED
  /* aci_hal_transmitter_test_packets_v2 */
  {0xfc2c, aci_hal_transmitter_test_packets_v2_process},
#endif
#if (!defined(ACI_HAL_WRITE_RADIO_REG_ENABLED) || ACI_HAL_WRITE_RADIO_REG_ENABLED) && !ACI_HAL_WRITE_RADIO_REG_FORCE_DISABLED
  /* aci_hal_write_radio_reg */
  {0xfc35, aci_hal_write_radio_reg_process},
#endif
#if (!defined(ACI_HAL_READ_RADIO_REG_ENABLED) || ACI_HAL_READ_RADIO_REG_ENABLED) && !ACI_HAL_READ_RADIO_REG_FORCE_DISABLED
  /* aci_hal_read_radio_reg */
  {0xfc36, aci_hal_read_radio_reg_process},
#endif
#if (!defined(ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_ENABLED) || ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_ENABLED) && !ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_FORCE_DISABLED
  /* aci_hal_set_antenna_switch_parameters */
  {0xfc37, aci_hal_set_antenna_switch_parameters_process},
#endif
#if (!defined(ACI_HAL_PERIPHERAL_LATENCY_ENABLE_ENABLED) || ACI_HAL_PERIPHERAL_LATENCY_ENABLE_ENABLED) && !ACI_HAL_PERIPHERAL_LATENCY_ENABLE_FORCE_DISABLED
  /* aci_hal_peripheral_latency_enable */
  {0xfc38, aci_hal_peripheral_latency_enable_process},
#endif
#if (!defined(ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_ENABLED) || ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_ENABLED) && !ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_FORCE_DISABLED
  /* aci_hal_get_evt_fifo_max_level */
  {0xfc60, aci_hal_get_evt_fifo_max_level_process},
#endif

#if BLESTACK_CONTROLLER_ONLY==0

#if (!defined(ACI_GAP_INIT_ENABLED) || ACI_GAP_INIT_ENABLED) && !ACI_GAP_INIT_FORCE_DISABLED
  /* aci_gap_init */
  {0xfc81, aci_gap_init_process},
#endif
#if (!defined(ACI_GAP_SET_IO_CAPABILITY_ENABLED) || ACI_GAP_SET_IO_CAPABILITY_ENABLED) && !ACI_GAP_SET_IO_CAPABILITY_FORCE_DISABLED
  /* aci_gap_set_io_capability */
  {0xfc85, aci_gap_set_io_capability_process},
#endif
#if (!defined(ACI_GAP_SET_SECURITY_REQUIREMENTS_ENABLED) || ACI_GAP_SET_SECURITY_REQUIREMENTS_ENABLED) && !ACI_GAP_SET_SECURITY_REQUIREMENTS_FORCE_DISABLED
  /* aci_gap_set_security_requirements */
  {0xfc86, aci_gap_set_security_requirements_process},
#endif
#if (!defined(ACI_GAP_PASSKEY_RESP_ENABLED) || ACI_GAP_PASSKEY_RESP_ENABLED) && !ACI_GAP_PASSKEY_RESP_FORCE_DISABLED
  /* aci_gap_passkey_resp */
  {0xfc88, aci_gap_passkey_resp_process},
#endif
#if (!defined(ACI_GAP_PROFILE_INIT_ENABLED) || ACI_GAP_PROFILE_INIT_ENABLED) && !ACI_GAP_PROFILE_INIT_FORCE_DISABLED
  /* aci_gap_profile_init */
  {0xfc8a, aci_gap_profile_init_process},
#endif
#if (!defined(ACI_GAP_SET_SECURITY_ENABLED) || ACI_GAP_SET_SECURITY_ENABLED) && !ACI_GAP_SET_SECURITY_FORCE_DISABLED
  /* aci_gap_set_security */
  {0xfc8d, aci_gap_set_security_process},
#endif
#if (!defined(ACI_GAP_GET_SECURITY_LEVEL_ENABLED) || ACI_GAP_GET_SECURITY_LEVEL_ENABLED) && !ACI_GAP_GET_SECURITY_LEVEL_FORCE_DISABLED
  /* aci_gap_get_security_level */
  {0xfc90, aci_gap_get_security_level_process},
#endif
#if (!defined(ACI_GAP_SET_LE_EVENT_MASK_ENABLED) || ACI_GAP_SET_LE_EVENT_MASK_ENABLED) && !ACI_GAP_SET_LE_EVENT_MASK_FORCE_DISABLED
  /* aci_gap_set_le_event_mask */
  {0xfc92, aci_gap_set_le_event_mask_process},
#endif
#if (!defined(ACI_GAP_TERMINATE_ENABLED) || ACI_GAP_TERMINATE_ENABLED) && !ACI_GAP_TERMINATE_FORCE_DISABLED
  /* aci_gap_terminate */
  {0xfc93, aci_gap_terminate_process},
#endif
#if (!defined(ACI_GAP_CLEAR_SECURITY_DB_ENABLED) || ACI_GAP_CLEAR_SECURITY_DB_ENABLED) && !ACI_GAP_CLEAR_SECURITY_DB_FORCE_DISABLED
  /* aci_gap_clear_security_db */
  {0xfc94, aci_gap_clear_security_db_process},
#endif
#if (!defined(ACI_GAP_PAIRING_RESP_ENABLED) || ACI_GAP_PAIRING_RESP_ENABLED) && !ACI_GAP_PAIRING_RESP_FORCE_DISABLED
  /* aci_gap_pairing_resp */
  {0xfc96, aci_gap_pairing_resp_process},
#endif
#if (!defined(ACI_GAP_CREATE_CONNECTION_ENABLED) || ACI_GAP_CREATE_CONNECTION_ENABLED) && !ACI_GAP_CREATE_CONNECTION_FORCE_DISABLED
  /* aci_gap_create_connection */
  {0xfc9c, aci_gap_create_connection_process},
#endif
#if (!defined(ACI_GAP_TERMINATE_PROC_ENABLED) || ACI_GAP_TERMINATE_PROC_ENABLED) && !ACI_GAP_TERMINATE_PROC_FORCE_DISABLED
  /* aci_gap_terminate_proc */
  {0xfc9d, aci_gap_terminate_proc_process},
#endif
#if (!defined(ACI_GAP_START_CONNECTION_UPDATE_ENABLED) || ACI_GAP_START_CONNECTION_UPDATE_ENABLED) && !ACI_GAP_START_CONNECTION_UPDATE_FORCE_DISABLED
  /* aci_gap_start_connection_update */
  {0xfc9e, aci_gap_start_connection_update_process},
#endif
#if (!defined(ACI_GAP_RESOLVE_PRIVATE_ADDR_ENABLED) || ACI_GAP_RESOLVE_PRIVATE_ADDR_ENABLED) && !ACI_GAP_RESOLVE_PRIVATE_ADDR_FORCE_DISABLED
  /* aci_gap_resolve_private_addr */
  {0xfca0, aci_gap_resolve_private_addr_process},
#endif
#if (!defined(ACI_GAP_GET_BONDED_DEVICES_ENABLED) || ACI_GAP_GET_BONDED_DEVICES_ENABLED) && !ACI_GAP_GET_BONDED_DEVICES_FORCE_DISABLED
  /* aci_gap_get_bonded_devices */
  {0xfca3, aci_gap_get_bonded_devices_process},
#endif
#if (!defined(ACI_GAP_IS_DEVICE_BONDED_ENABLED) || ACI_GAP_IS_DEVICE_BONDED_ENABLED) && !ACI_GAP_IS_DEVICE_BONDED_FORCE_DISABLED
  /* aci_gap_is_device_bonded */
  {0xfca4, aci_gap_is_device_bonded_process},
#endif
#if (!defined(ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_ENABLED) || ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_ENABLED) && !ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_FORCE_DISABLED
  /* aci_gap_numeric_comparison_value_confirm_yesno */
  {0xfca5, aci_gap_numeric_comparison_value_confirm_yesno_process},
#endif
#if (!defined(ACI_GAP_PASSKEY_INPUT_ENABLED) || ACI_GAP_PASSKEY_INPUT_ENABLED) && !ACI_GAP_PASSKEY_INPUT_FORCE_DISABLED
  /* aci_gap_passkey_input */
  {0xfca6, aci_gap_passkey_input_process},
#endif
#if (!defined(ACI_GAP_GET_OOB_DATA_ENABLED) || ACI_GAP_GET_OOB_DATA_ENABLED) && !ACI_GAP_GET_OOB_DATA_FORCE_DISABLED
  /* aci_gap_get_oob_data */
  {0xfca7, aci_gap_get_oob_data_process},
#endif
#if (!defined(ACI_GAP_SET_OOB_DATA_ENABLED) || ACI_GAP_SET_OOB_DATA_ENABLED) && !ACI_GAP_SET_OOB_DATA_FORCE_DISABLED
  /* aci_gap_set_oob_data */
  {0xfca8, aci_gap_set_oob_data_process},
#endif
#if (!defined(ACI_GAP_REMOVE_BONDED_DEVICE_ENABLED) || ACI_GAP_REMOVE_BONDED_DEVICE_ENABLED) && !ACI_GAP_REMOVE_BONDED_DEVICE_FORCE_DISABLED
  /* aci_gap_remove_bonded_device */
  {0xfcaa, aci_gap_remove_bonded_device_process},
#endif
#if (!defined(ACI_GAP_SET_ADVERTISING_CONFIGURATION_ENABLED) || ACI_GAP_SET_ADVERTISING_CONFIGURATION_ENABLED) && !ACI_GAP_SET_ADVERTISING_CONFIGURATION_FORCE_DISABLED
  /* aci_gap_set_advertising_configuration */
  {0xfcab, aci_gap_set_advertising_configuration_process},
#endif
#if (!defined(ACI_GAP_SET_ADVERTISING_ENABLE_ENABLED) || ACI_GAP_SET_ADVERTISING_ENABLE_ENABLED) && !ACI_GAP_SET_ADVERTISING_ENABLE_FORCE_DISABLED
  /* aci_gap_set_advertising_enable */
  {0xfcac, aci_gap_set_advertising_enable_process},
#endif
#if (!defined(ACI_GAP_SET_ADVERTISING_DATA_NWK_ENABLED) || ACI_GAP_SET_ADVERTISING_DATA_NWK_ENABLED) && !ACI_GAP_SET_ADVERTISING_DATA_NWK_FORCE_DISABLED
  /* aci_gap_set_advertising_data_nwk */
  {0xfcad, aci_gap_set_advertising_data_nwk_process},
#endif
#if (!defined(ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_ENABLED) || ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_ENABLED) && !ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_FORCE_DISABLED
  /* aci_gap_set_scan_response_data_nwk */
  {0xfcae, aci_gap_set_scan_response_data_nwk_process},
#endif
#if (!defined(ACI_GAP_SET_SCAN_CONFIGURATION_ENABLED) || ACI_GAP_SET_SCAN_CONFIGURATION_ENABLED) && !ACI_GAP_SET_SCAN_CONFIGURATION_FORCE_DISABLED
  /* aci_gap_set_scan_configuration */
  {0xfcaf, aci_gap_set_scan_configuration_process},
#endif
#if (!defined(ACI_GAP_SET_CONNECTION_CONFIGURATION_ENABLED) || ACI_GAP_SET_CONNECTION_CONFIGURATION_ENABLED) && !ACI_GAP_SET_CONNECTION_CONFIGURATION_FORCE_DISABLED
  /* aci_gap_set_connection_configuration */
  {0xfcb0, aci_gap_set_connection_configuration_process},
#endif
#if (!defined(ACI_GAP_START_PROCEDURE_ENABLED) || ACI_GAP_START_PROCEDURE_ENABLED) && !ACI_GAP_START_PROCEDURE_FORCE_DISABLED
  /* aci_gap_start_procedure */
  {0xfcb1, aci_gap_start_procedure_process},
#endif
#if (!defined(ACI_GAP_DISCOVER_NAME_ENABLED) || ACI_GAP_DISCOVER_NAME_ENABLED) && !ACI_GAP_DISCOVER_NAME_FORCE_DISABLED
  /* aci_gap_discover_name */
  {0xfcb2, aci_gap_discover_name_process},
#endif
#if (!defined(ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) || ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) && !ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_FORCE_DISABLED
  /* aci_gap_add_devices_to_filter_accept_and_resolving_list */
  {0xfcb3, aci_gap_add_devices_to_filter_accept_and_resolving_list_process},
#endif
#if (!defined(ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) || ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) && !ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_FORCE_DISABLED
  /* aci_gap_configure_filter_accept_and_resolving_list */
  {0xfcb4, aci_gap_configure_filter_accept_and_resolving_list_process},
#endif
#if (!defined(ACI_GAP_REMOVE_ADVERTISING_SET_ENABLED) || ACI_GAP_REMOVE_ADVERTISING_SET_ENABLED) && !ACI_GAP_REMOVE_ADVERTISING_SET_FORCE_DISABLED
  /* aci_gap_remove_advertising_set */
  {0xfcba, aci_gap_remove_advertising_set_process},
#endif
#if (!defined(ACI_GAP_CLEAR_ADVERTISING_SETS_ENABLED) || ACI_GAP_CLEAR_ADVERTISING_SETS_ENABLED) && !ACI_GAP_CLEAR_ADVERTISING_SETS_FORCE_DISABLED
  /* aci_gap_clear_advertising_sets */
  {0xfcbb, aci_gap_clear_advertising_sets_process},
#endif
#if (!defined(ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_ENABLED) || ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_ENABLED) && !ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_FORCE_DISABLED
  /* aci_gap_create_periodic_advertising_connection */
  {0xfcca, aci_gap_create_periodic_advertising_connection_process},
#endif
#if (!defined(ACI_GAP_ENCRYPT_ADV_DATA_NWK_ENABLED) || ACI_GAP_ENCRYPT_ADV_DATA_NWK_ENABLED) && !ACI_GAP_ENCRYPT_ADV_DATA_NWK_FORCE_DISABLED
  /* aci_gap_encrypt_adv_data_nwk */
  {0xfccb, aci_gap_encrypt_adv_data_nwk_process},
#endif
#if (!defined(ACI_GAP_DECRYPT_ADV_DATA_NWK_ENABLED) || ACI_GAP_DECRYPT_ADV_DATA_NWK_ENABLED) && !ACI_GAP_DECRYPT_ADV_DATA_NWK_FORCE_DISABLED
  /* aci_gap_decrypt_adv_data_nwk */
  {0xfccc, aci_gap_decrypt_adv_data_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_PROFILE_INIT_ENABLED) || ACI_GATT_SRV_PROFILE_INIT_ENABLED) && !ACI_GATT_SRV_PROFILE_INIT_FORCE_DISABLED
  /* aci_gatt_srv_profile_init */
  {0xfd01, aci_gatt_srv_profile_init_process},
#endif
#if (!defined(ACI_GATT_SRV_ADD_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_ADD_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_ADD_SERVICE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_add_service_nwk */
  {0xfd02, aci_gatt_srv_add_service_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_INCLUDE_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_INCLUDE_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_INCLUDE_SERVICE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_include_service_nwk */
  {0xfd03, aci_gatt_srv_include_service_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_ADD_CHAR_NWK_ENABLED) || ACI_GATT_SRV_ADD_CHAR_NWK_ENABLED) && !ACI_GATT_SRV_ADD_CHAR_NWK_FORCE_DISABLED
  /* aci_gatt_srv_add_char_nwk */
  {0xfd04, aci_gatt_srv_add_char_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_ADD_CHAR_DESC_NWK_ENABLED) || ACI_GATT_SRV_ADD_CHAR_DESC_NWK_ENABLED) && !ACI_GATT_SRV_ADD_CHAR_DESC_NWK_FORCE_DISABLED
  /* aci_gatt_srv_add_char_desc_nwk */
  {0xfd05, aci_gatt_srv_add_char_desc_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_write_handle_value_nwk */
  {0xfd06, aci_gatt_srv_write_handle_value_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_RM_CHAR_NWK_ENABLED) || ACI_GATT_SRV_RM_CHAR_NWK_ENABLED) && !ACI_GATT_SRV_RM_CHAR_NWK_FORCE_DISABLED
  /* aci_gatt_srv_rm_char_nwk */
  {0xfd07, aci_gatt_srv_rm_char_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_RM_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_RM_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_RM_SERVICE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_rm_service_nwk */
  {0xfd08, aci_gatt_srv_rm_service_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_rm_include_service_nwk */
  {0xfd09, aci_gatt_srv_rm_include_service_nwk_process},
#endif
#if (!defined(ACI_GATT_SET_EVENT_MASK_ENABLED) || ACI_GATT_SET_EVENT_MASK_ENABLED) && !ACI_GATT_SET_EVENT_MASK_FORCE_DISABLED
  /* aci_gatt_set_event_mask */
  {0xfd0a, aci_gatt_set_event_mask_process},
#endif
#if (!defined(ACI_GATT_CLT_EXCHANGE_CONFIG_ENABLED) || ACI_GATT_CLT_EXCHANGE_CONFIG_ENABLED) && !ACI_GATT_CLT_EXCHANGE_CONFIG_FORCE_DISABLED
  /* aci_gatt_clt_exchange_config */
  {0xfd0b, aci_gatt_clt_exchange_config_process},
#endif
#if (!defined(ACI_GATT_CLT_PREPARE_WRITE_REQ_ENABLED) || ACI_GATT_CLT_PREPARE_WRITE_REQ_ENABLED) && !ACI_GATT_CLT_PREPARE_WRITE_REQ_FORCE_DISABLED
  /* aci_gatt_clt_prepare_write_req */
  {0xfd10, aci_gatt_clt_prepare_write_req_process},
#endif
#if (!defined(ACI_GATT_CLT_EXECUTE_WRITE_REQ_ENABLED) || ACI_GATT_CLT_EXECUTE_WRITE_REQ_ENABLED) && !ACI_GATT_CLT_EXECUTE_WRITE_REQ_FORCE_DISABLED
  /* aci_gatt_clt_execute_write_req */
  {0xfd11, aci_gatt_clt_execute_write_req_process},
#endif
#if (!defined(ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_ENABLED) || ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_ENABLED) && !ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_FORCE_DISABLED
  /* aci_gatt_clt_disc_all_primary_services */
  {0xfd12, aci_gatt_clt_disc_all_primary_services_process},
#endif
#if (!defined(ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_ENABLED) || ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_ENABLED) && !ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_FORCE_DISABLED
  /* aci_gatt_clt_disc_primary_service_by_uuid */
  {0xfd13, aci_gatt_clt_disc_primary_service_by_uuid_process},
#endif
#if (!defined(ACI_GATT_CLT_FIND_INCLUDED_SERVICES_ENABLED) || ACI_GATT_CLT_FIND_INCLUDED_SERVICES_ENABLED) && !ACI_GATT_CLT_FIND_INCLUDED_SERVICES_FORCE_DISABLED
  /* aci_gatt_clt_find_included_services */
  {0xfd14, aci_gatt_clt_find_included_services_process},
#endif
#if (!defined(ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_ENABLED) || ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_ENABLED) && !ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_FORCE_DISABLED
  /* aci_gatt_clt_disc_all_char_of_service */
  {0xfd15, aci_gatt_clt_disc_all_char_of_service_process},
#endif
#if (!defined(ACI_GATT_CLT_DISC_CHAR_BY_UUID_ENABLED) || ACI_GATT_CLT_DISC_CHAR_BY_UUID_ENABLED) && !ACI_GATT_CLT_DISC_CHAR_BY_UUID_FORCE_DISABLED
  /* aci_gatt_clt_disc_char_by_uuid */
  {0xfd16, aci_gatt_clt_disc_char_by_uuid_process},
#endif
#if (!defined(ACI_GATT_CLT_DISC_ALL_CHAR_DESC_ENABLED) || ACI_GATT_CLT_DISC_ALL_CHAR_DESC_ENABLED) && !ACI_GATT_CLT_DISC_ALL_CHAR_DESC_FORCE_DISABLED
  /* aci_gatt_clt_disc_all_char_desc */
  {0xfd17, aci_gatt_clt_disc_all_char_desc_process},
#endif
#if (!defined(ACI_GATT_CLT_READ_ENABLED) || ACI_GATT_CLT_READ_ENABLED) && !ACI_GATT_CLT_READ_FORCE_DISABLED
  /* aci_gatt_clt_read */
  {0xfd18, aci_gatt_clt_read_process},
#endif
#if (!defined(ACI_GATT_CLT_READ_USING_CHAR_UUID_ENABLED) || ACI_GATT_CLT_READ_USING_CHAR_UUID_ENABLED) && !ACI_GATT_CLT_READ_USING_CHAR_UUID_FORCE_DISABLED
  /* aci_gatt_clt_read_using_char_uuid */
  {0xfd19, aci_gatt_clt_read_using_char_uuid_process},
#endif
#if (!defined(ACI_GATT_CLT_READ_LONG_ENABLED) || ACI_GATT_CLT_READ_LONG_ENABLED) && !ACI_GATT_CLT_READ_LONG_FORCE_DISABLED
  /* aci_gatt_clt_read_long */
  {0xfd1a, aci_gatt_clt_read_long_process},
#endif
#if (!defined(ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_ENABLED) || ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_ENABLED) && !ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_FORCE_DISABLED
  /* aci_gatt_clt_read_multiple_char_value */
  {0xfd1b, aci_gatt_clt_read_multiple_char_value_process},
#endif
#if (!defined(ACI_GATT_CLT_WRITE_NWK_ENABLED) || ACI_GATT_CLT_WRITE_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_NWK_FORCE_DISABLED
  /* aci_gatt_clt_write_nwk */
  {0xfd1c, aci_gatt_clt_write_nwk_process},
#endif
#if (!defined(ACI_GATT_CLT_WRITE_LONG_NWK_ENABLED) || ACI_GATT_CLT_WRITE_LONG_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_LONG_NWK_FORCE_DISABLED
  /* aci_gatt_clt_write_long_nwk */
  {0xfd1d, aci_gatt_clt_write_long_nwk_process},
#endif
#if (!defined(ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_ENABLED) || ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_FORCE_DISABLED
  /* aci_gatt_clt_write_char_reliable_nwk */
  {0xfd1e, aci_gatt_clt_write_char_reliable_nwk_process},
#endif
#if (!defined(ACI_GATT_CLT_WRITE_WITHOUT_RESP_ENABLED) || ACI_GATT_CLT_WRITE_WITHOUT_RESP_ENABLED) && !ACI_GATT_CLT_WRITE_WITHOUT_RESP_FORCE_DISABLED
  /* aci_gatt_clt_write_without_resp */
  {0xfd23, aci_gatt_clt_write_without_resp_process},
#endif
#if (!defined(ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_ENABLED) || ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_ENABLED) && !ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_FORCE_DISABLED
  /* aci_gatt_clt_signed_write_without_resp */
  {0xfd24, aci_gatt_clt_signed_write_without_resp_process},
#endif
#if (!defined(ACI_GATT_CLT_CONFIRM_INDICATION_ENABLED) || ACI_GATT_CLT_CONFIRM_INDICATION_ENABLED) && !ACI_GATT_CLT_CONFIRM_INDICATION_FORCE_DISABLED
  /* aci_gatt_clt_confirm_indication */
  {0xfd25, aci_gatt_clt_confirm_indication_process},
#endif
#if (!defined(ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_ENABLED) || ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_ENABLED) && !ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_FORCE_DISABLED
  /* aci_gatt_srv_set_security_permission_nwk */
  {0xfd28, aci_gatt_srv_set_security_permission_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_read_handle_value_nwk */
  {0xfd2a, aci_gatt_srv_read_handle_value_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_ENABLED) || ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_ENABLED) && !ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_FORCE_DISABLED
  /* aci_gatt_srv_set_access_permission_nwk */
  {0xfd2e, aci_gatt_srv_set_access_permission_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_NOTIFY_ENABLED) || ACI_GATT_SRV_NOTIFY_ENABLED) && !ACI_GATT_SRV_NOTIFY_FORCE_DISABLED
  /* aci_gatt_srv_notify */
  {0xfd2f, aci_gatt_srv_notify_process},
#endif
#if (!defined(ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_ENABLED) || ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_ENABLED) && !ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_FORCE_DISABLED
  /* aci_gatt_srv_exec_write_resp_nwk */
  {0xfd31, aci_gatt_srv_exec_write_resp_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_AUTHORIZE_RESP_NWK_ENABLED) || ACI_GATT_SRV_AUTHORIZE_RESP_NWK_ENABLED) && !ACI_GATT_SRV_AUTHORIZE_RESP_NWK_FORCE_DISABLED
  /* aci_gatt_srv_authorize_resp_nwk */
  {0xfd33, aci_gatt_srv_authorize_resp_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_ENABLED) || ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_read_prepare_queue_nwk */
  {0xfd35, aci_gatt_srv_read_prepare_queue_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_ENABLED) || ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_ENABLED) && !ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_FORCE_DISABLED
  /* aci_gatt_srv_write_multiple_instance_handle_value */
  {0xfd36, aci_gatt_srv_write_multiple_instance_handle_value_process},
#endif
#if (!defined(ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_FORCE_DISABLED
  /* aci_gatt_srv_read_multiple_instance_handle_value_nwk */
  {0xfd37, aci_gatt_srv_read_multiple_instance_handle_value_nwk_process},
#endif
#if (!defined(ACI_GATT_SRV_MULTI_NOTIFY_ENABLED) || ACI_GATT_SRV_MULTI_NOTIFY_ENABLED) && !ACI_GATT_SRV_MULTI_NOTIFY_FORCE_DISABLED
  /* aci_gatt_srv_multi_notify */
  {0xfd38, aci_gatt_srv_multi_notify_process},
#endif
#if (!defined(ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_ENABLED) || ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_ENABLED) && !ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_FORCE_DISABLED
  /* aci_gatt_clt_read_multiple_var_len_char_value */
  {0xfd39, aci_gatt_clt_read_multiple_var_len_char_value_process},
#endif
#if (!defined(ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_ENABLED) || ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_ENABLED) && !ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_FORCE_DISABLED
  /* aci_gatt_clt_add_subscription_security_level_nwk */
  {0xfd3a, aci_gatt_clt_add_subscription_security_level_nwk_process},
#endif
#if (!defined(ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_ENABLED) || ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_ENABLED) && !ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_FORCE_DISABLED
  /* aci_l2cap_connection_parameter_update_req */
  {0xfd81, aci_l2cap_connection_parameter_update_req_process},
#endif
#if (!defined(ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_ENABLED) || ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_ENABLED) && !ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_FORCE_DISABLED
  /* aci_l2cap_connection_parameter_update_resp */
  {0xfd82, aci_l2cap_connection_parameter_update_resp_process},
#endif
#if (!defined(ACI_L2CAP_COS_CONNECTION_REQ_ENABLED) || ACI_L2CAP_COS_CONNECTION_REQ_ENABLED) && !ACI_L2CAP_COS_CONNECTION_REQ_FORCE_DISABLED
  /* aci_l2cap_cos_connection_req */
  {0xfd83, aci_l2cap_cos_connection_req_process},
#endif
#if (!defined(ACI_L2CAP_COS_CONNECTION_RESP_ENABLED) || ACI_L2CAP_COS_CONNECTION_RESP_ENABLED) && !ACI_L2CAP_COS_CONNECTION_RESP_FORCE_DISABLED
  /* aci_l2cap_cos_connection_resp */
  {0xfd84, aci_l2cap_cos_connection_resp_process},
#endif
#if (!defined(ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_ENABLED) || ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_ENABLED) && !ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_FORCE_DISABLED
  /* aci_l2cap_cos_flow_control_credits_ind */
  {0xfd85, aci_l2cap_cos_flow_control_credits_ind_process},
#endif
#if (!defined(ACI_L2CAP_COS_DISCONNECT_REQ_ENABLED) || ACI_L2CAP_COS_DISCONNECT_REQ_ENABLED) && !ACI_L2CAP_COS_DISCONNECT_REQ_FORCE_DISABLED
  /* aci_l2cap_cos_disconnect_req */
  {0xfd86, aci_l2cap_cos_disconnect_req_process},
#endif
#if (!defined(ACI_L2CAP_COS_SDU_DATA_TRANSMIT_ENABLED) || ACI_L2CAP_COS_SDU_DATA_TRANSMIT_ENABLED) && !ACI_L2CAP_COS_SDU_DATA_TRANSMIT_FORCE_DISABLED
  /* aci_l2cap_cos_sdu_data_transmit */
  {0xfd87, aci_l2cap_cos_sdu_data_transmit_process},
#endif
#if (!defined(ACI_L2CAP_COS_RECONFIGURE_REQ_ENABLED) || ACI_L2CAP_COS_RECONFIGURE_REQ_ENABLED) && !ACI_L2CAP_COS_RECONFIGURE_REQ_FORCE_DISABLED
  /* aci_l2cap_cos_reconfigure_req */
  {0xfd8a, aci_l2cap_cos_reconfigure_req_process},
#endif
#if (!defined(ACI_L2CAP_COS_RECONFIGURE_RESP_ENABLED) || ACI_L2CAP_COS_RECONFIGURE_RESP_ENABLED) && !ACI_L2CAP_COS_RECONFIGURE_RESP_FORCE_DISABLED
  /* aci_l2cap_cos_reconfigure_resp */
  {0xfd8b, aci_l2cap_cos_reconfigure_resp_process},
#endif
#if (!defined(ACI_TEST_TX_NOTIFICATION_START_ENABLED) || ACI_TEST_TX_NOTIFICATION_START_ENABLED) && !ACI_TEST_TX_NOTIFICATION_START_FORCE_DISABLED
  /* aci_test_tx_notification_start */
  {0xfe00, aci_test_tx_notification_start_process},
#endif
#if (!defined(ACI_TEST_TX_WRITE_COMMAND_START_ENABLED) || ACI_TEST_TX_WRITE_COMMAND_START_ENABLED) && !ACI_TEST_TX_WRITE_COMMAND_START_FORCE_DISABLED
  /* aci_test_tx_write_command_start */
  {0xfe01, aci_test_tx_write_command_start_process},
#endif
#if (!defined(ACI_TEST_RX_START_ENABLED) || ACI_TEST_RX_START_ENABLED) && !ACI_TEST_RX_START_FORCE_DISABLED
  /* aci_test_rx_start */
  {0xfe02, aci_test_rx_start_process},
#endif
#if (!defined(ACI_TEST_STOP_ENABLED) || ACI_TEST_STOP_ENABLED) && !ACI_TEST_STOP_FORCE_DISABLED
  /* aci_test_stop */
  {0xfe03, aci_test_stop_process},
#endif
#if (!defined(ACI_TEST_REPORT_ENABLED) || ACI_TEST_REPORT_ENABLED) && !ACI_TEST_REPORT_FORCE_DISABLED
  /* aci_test_report */
  {0xfe04, aci_test_report_process},
#endif

#endif /* BLESTACK_CONTROLLER_ONLY==0 */
  {0, NULL}
};

#if (!defined(HCI_DISCONNECT_ENABLED) || HCI_DISCONNECT_ENABLED) && !HCI_DISCONNECT_FORCE_DISABLED
/* tBleStatus hci_disconnect(uint16_t Connection_Handle,
                          uint8_t Reason);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_disconnect_cp0 *cp0 = (hci_disconnect_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = hci_disconnect(cp0->Connection_Handle /* 2 */,
                           cp0->Reason /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x06;
  buffer_out[6] = 0x04;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_REMOTE_VERSION_INFORMATION_ENABLED) || HCI_READ_REMOTE_VERSION_INFORMATION_ENABLED) && !HCI_READ_REMOTE_VERSION_INFORMATION_FORCE_DISABLED
/* tBleStatus hci_read_remote_version_information(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_read_remote_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_remote_version_information_cp0 *cp0 = (hci_read_remote_version_information_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_read_remote_version_information(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1d;
  buffer_out[6] = 0x04;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_SET_EVENT_MASK_ENABLED) || HCI_SET_EVENT_MASK_ENABLED) && !HCI_SET_EVENT_MASK_FORCE_DISABLED
/* tBleStatus hci_set_event_mask(uint8_t Event_Mask[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_set_event_mask_cp0 *cp0 = (hci_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    goto fail;
  }

  *status = hci_set_event_mask(cp0->Event_Mask /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_CONNECTION_ACCEPT_TIMEOUT_ENABLED) || HCI_READ_CONNECTION_ACCEPT_TIMEOUT_ENABLED) && !HCI_READ_CONNECTION_ACCEPT_TIMEOUT_FORCE_DISABLED
/* tBleStatus hci_read_connection_accept_timeout(uint16_t *Connection_Accept_Timeout);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t hci_read_connection_accept_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  hci_read_connection_accept_timeout_rp0 *rp0 = (hci_read_connection_accept_timeout_rp0 *) (buffer_out + 6);
  uint16_t Connection_Accept_Timeout = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_connection_accept_timeout(&Connection_Accept_Timeout);
fail:
  rp0->Connection_Accept_Timeout = Connection_Accept_Timeout;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x15;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_ENABLED) || HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_ENABLED) && !HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT_FORCE_DISABLED
/* tBleStatus hci_write_connection_accept_timeout(uint16_t Connection_Accept_Timeout);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_write_connection_accept_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_write_connection_accept_timeout_cp0 *cp0 = (hci_write_connection_accept_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_write_connection_accept_timeout(cp0->Connection_Accept_Timeout /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x16;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_READ_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_READ_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
/* tBleStatus hci_read_transmit_power_level(uint16_t Connection_Handle,
                                         uint8_t Type,
                                         int8_t *Transmit_Power_Level);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_transmit_power_level_cp0 *cp0 = (hci_read_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_read_transmit_power_level_rp0 *rp0 = (hci_read_transmit_power_level_rp0 *) (buffer_out + 6);
  int8_t Transmit_Power_Level = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_read_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                              cp0->Type /* 1 */,
                                              &Transmit_Power_Level);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Transmit_Power_Level = Transmit_Power_Level;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2d;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) || HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) && !HCI_READ_AFH_CHANNEL_ASSESSMENT_MODE_FORCE_DISABLED
/* tBleStatus hci_read_afh_channel_assessment_mode(uint8_t *AFH_Channel_Assessment_Mode);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_read_afh_channel_assessment_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_read_afh_channel_assessment_mode_rp0 *rp0 = (hci_read_afh_channel_assessment_mode_rp0 *) (buffer_out + 6);
  uint8_t AFH_Channel_Assessment_Mode = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_afh_channel_assessment_mode(&AFH_Channel_Assessment_Mode);
fail:
  rp0->AFH_Channel_Assessment_Mode = AFH_Channel_Assessment_Mode;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x48;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) || HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED) && !HCI_WRITE_AFH_CHANNEL_ASSESSMENT_MODE_FORCE_DISABLED
/* tBleStatus hci_write_afh_channel_assessment_mode(uint8_t AFH_Channel_Assessment_Mode);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_write_afh_channel_assessment_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_write_afh_channel_assessment_mode_cp0 *cp0 = (hci_write_afh_channel_assessment_mode_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = hci_write_afh_channel_assessment_mode(cp0->AFH_Channel_Assessment_Mode /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x49;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_SET_EVENT_MASK_PAGE_2_ENABLED) || HCI_SET_EVENT_MASK_PAGE_2_ENABLED) && !HCI_SET_EVENT_MASK_PAGE_2_FORCE_DISABLED
/* tBleStatus hci_set_event_mask_page_2(uint8_t Event_Mask_Page_2[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_set_event_mask_page_2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_set_event_mask_page_2_cp0 *cp0 = (hci_set_event_mask_page_2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    goto fail;
  }

  *status = hci_set_event_mask_page_2(cp0->Event_Mask_Page_2 /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x63;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) || HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) && !HCI_READ_AUTHENTICATED_PAYLOAD_TIMEOUT_FORCE_DISABLED
/* tBleStatus hci_read_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                  uint16_t *Authenticated_Payload_Timeout);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_read_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_authenticated_payload_timeout_cp0 *cp0 = (hci_read_authenticated_payload_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_read_authenticated_payload_timeout_rp0 *rp0 = (hci_read_authenticated_payload_timeout_rp0 *) (buffer_out + 6);
  uint16_t Authenticated_Payload_Timeout = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_read_authenticated_payload_timeout(cp0->Connection_Handle /* 2 */,
                                                       &Authenticated_Payload_Timeout);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Authenticated_Payload_Timeout = Authenticated_Payload_Timeout;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7b;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) || HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_ENABLED) && !HCI_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT_FORCE_DISABLED
/* tBleStatus hci_write_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                   uint16_t Authenticated_Payload_Timeout);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_write_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_write_authenticated_payload_timeout_cp0 *cp0 = (hci_write_authenticated_payload_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_write_authenticated_payload_timeout_rp0 *rp0 = (hci_write_authenticated_payload_timeout_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  rp0->Status = hci_write_authenticated_payload_timeout(cp0->Connection_Handle /* 2 */,
                                                        cp0->Authenticated_Payload_Timeout /* 2 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7c;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_LOCAL_VERSION_INFORMATION_ENABLED) || HCI_READ_LOCAL_VERSION_INFORMATION_ENABLED) && !HCI_READ_LOCAL_VERSION_INFORMATION_FORCE_DISABLED
/* tBleStatus hci_read_local_version_information(uint8_t *HCI_Version,
                                              uint16_t *HCI_Revision,
                                              uint8_t *LMP_PAL_Version,
                                              uint16_t *Manufacturer_Name,
                                              uint16_t *LMP_PAL_Subversion);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 2 + 1 + 2 + 2 */
uint16_t hci_read_local_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 2 + 1 + 2 + 2;
  /* Output params */
  hci_read_local_version_information_rp0 *rp0 = (hci_read_local_version_information_rp0 *) (buffer_out + 6);
  uint8_t HCI_Version = 0;
  uint16_t HCI_Revision = 0;
  uint8_t LMP_PAL_Version = 0;
  uint16_t Manufacturer_Name = 0;
  uint16_t LMP_PAL_Subversion = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 2 + 1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_local_version_information(&HCI_Version,
                                                   &HCI_Revision,
                                                   &LMP_PAL_Version,
                                                   &Manufacturer_Name,
                                                   &LMP_PAL_Subversion);
fail:
  rp0->HCI_Version = HCI_Version;
  rp0->HCI_Revision = HCI_Revision;
  rp0->LMP_PAL_Version = LMP_PAL_Version;
  rp0->Manufacturer_Name = Manufacturer_Name;
  rp0->LMP_PAL_Subversion = LMP_PAL_Subversion;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_LOCAL_SUPPORTED_COMMANDS_ENABLED) || HCI_READ_LOCAL_SUPPORTED_COMMANDS_ENABLED) && !HCI_READ_LOCAL_SUPPORTED_COMMANDS_FORCE_DISABLED
/* tBleStatus hci_read_local_supported_commands(uint8_t Supported_Commands[64]);
 */
/* Command len: 0 */
/* Response len: 1 + 64 */
uint16_t hci_read_local_supported_commands_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 64;
  /* Output params */
  hci_read_local_supported_commands_rp0 *rp0 = (hci_read_local_supported_commands_rp0 *) (buffer_out + 6);
  uint8_t Supported_Commands[64] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 64 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_local_supported_commands(Supported_Commands);
fail:
  Osal_MemCpy((void *) rp0->Supported_Commands,(const void *) Supported_Commands, 64);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) || HCI_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) && !HCI_READ_LOCAL_SUPPORTED_FEATURES_FORCE_DISABLED
/* tBleStatus hci_read_local_supported_features(uint8_t LMP_Features[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_read_local_supported_features_rp0 *rp0 = (hci_read_local_supported_features_rp0 *) (buffer_out + 6);
  uint8_t LMP_Features[8] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_local_supported_features(LMP_Features);
fail:
  Osal_MemCpy((void *) rp0->LMP_Features,(const void *) LMP_Features, 8);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_BD_ADDR_ENABLED) || HCI_READ_BD_ADDR_ENABLED) && !HCI_READ_BD_ADDR_FORCE_DISABLED
/* tBleStatus hci_read_bd_addr(uint8_t BD_ADDR[6]);
 */
/* Command len: 0 */
/* Response len: 1 + 6 */
uint16_t hci_read_bd_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 6;
  /* Output params */
  hci_read_bd_addr_rp0 *rp0 = (hci_read_bd_addr_rp0 *) (buffer_out + 6);
  uint8_t BD_ADDR[6] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_read_bd_addr(BD_ADDR);
fail:
  Osal_MemCpy((void *) rp0->BD_ADDR,(const void *) BD_ADDR, 6);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_READ_RSSI_ENABLED) || HCI_READ_RSSI_ENABLED) && !HCI_READ_RSSI_FORCE_DISABLED
/* tBleStatus hci_read_rssi(uint16_t Connection_Handle,
                         int8_t *RSSI);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_read_rssi_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_rssi_cp0 *cp0 = (hci_read_rssi_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_read_rssi_rp0 *rp0 = (hci_read_rssi_rp0 *) (buffer_out + 6);
  int8_t RSSI = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_read_rssi(cp0->Connection_Handle /* 2 */,
                              &RSSI);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->RSSI = RSSI;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x14;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EVENT_MASK_ENABLED) || HCI_LE_SET_EVENT_MASK_ENABLED) && !HCI_LE_SET_EVENT_MASK_FORCE_DISABLED
/* tBleStatus hci_le_set_event_mask(uint8_t LE_Event_Mask[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_le_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_event_mask_cp0 *cp0 = (hci_le_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    goto fail;
  }

  *status = hci_le_set_event_mask(cp0->LE_Event_Mask /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_BUFFER_SIZE_ENABLED) || HCI_LE_READ_BUFFER_SIZE_ENABLED) && !HCI_LE_READ_BUFFER_SIZE_FORCE_DISABLED
/* tBleStatus hci_le_read_buffer_size(uint16_t *HC_LE_ACL_Data_Packet_Length,
                                   uint8_t *HC_Total_Num_LE_ACL_Data_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_le_read_buffer_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_le_read_buffer_size_rp0 *rp0 = (hci_le_read_buffer_size_rp0 *) (buffer_out + 6);
  uint16_t HC_LE_ACL_Data_Packet_Length = 0;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_buffer_size(&HC_LE_ACL_Data_Packet_Length,
                                        &HC_Total_Num_LE_ACL_Data_Packets);
fail:
  rp0->HC_LE_ACL_Data_Packet_Length = HC_LE_ACL_Data_Packet_Length;
  rp0->HC_Total_Num_LE_ACL_Data_Packets = HC_Total_Num_LE_ACL_Data_Packets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) || HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_ENABLED) && !HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_FORCE_DISABLED
/* tBleStatus hci_le_read_local_supported_features(uint8_t LE_Features[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_read_local_supported_features_rp0 *rp0 = (hci_le_read_local_supported_features_rp0 *) (buffer_out + 6);
  uint8_t LE_Features[8] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_local_supported_features(LE_Features);
fail:
  Osal_MemCpy((void *) rp0->LE_Features,(const void *) LE_Features, 8);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_RANDOM_ADDRESS_ENABLED) || HCI_LE_SET_RANDOM_ADDRESS_ENABLED) && !HCI_LE_SET_RANDOM_ADDRESS_FORCE_DISABLED
/* tBleStatus hci_le_set_random_address(uint8_t Random_Address[6]);
 */
/* Command len: 6 */
/* Response len: 1 */
uint16_t hci_le_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_random_address_cp0 *cp0 = (hci_le_set_random_address_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 6)
  {
    goto fail;
  }

  *status = hci_le_set_random_address(cp0->Random_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_ADVERTISING_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_advertising_parameters(uint16_t Advertising_Interval_Min,
                                             uint16_t Advertising_Interval_Max,
                                             uint8_t Advertising_Type,
                                             uint8_t Own_Address_Type,
                                             uint8_t Peer_Address_Type,
                                             uint8_t Peer_Address[6],
                                             uint8_t Advertising_Channel_Map,
                                             uint8_t Advertising_Filter_Policy);
 */
/* Command len: 2 + 2 + 1 + 1 + 1 + 6 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_parameters_cp0 *cp0 = (hci_le_set_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 1 + 6 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_advertising_parameters(cp0->Advertising_Interval_Min /* 2 */,
                                              cp0->Advertising_Interval_Max /* 2 */,
                                              cp0->Advertising_Type /* 1 */,
                                              cp0->Own_Address_Type /* 1 */,
                                              cp0->Peer_Address_Type /* 1 */,
                                              cp0->Peer_Address /* 6 */,
                                              cp0->Advertising_Channel_Map /* 1 */,
                                              cp0->Advertising_Filter_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x06;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_ENABLED) || HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_ENABLED) && !HCI_LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER_FORCE_DISABLED
/* tBleStatus hci_le_read_advertising_physical_channel_tx_power(int8_t *Transmit_Power_Level);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_advertising_physical_channel_tx_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_advertising_physical_channel_tx_power_rp0 *rp0 = (hci_le_read_advertising_physical_channel_tx_power_rp0 *) (buffer_out + 6);
  int8_t Transmit_Power_Level = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_advertising_physical_channel_tx_power(&Transmit_Power_Level);
fail:
  rp0->Transmit_Power_Level = Transmit_Power_Level;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_ADVERTISING_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_advertising_data(uint8_t Advertising_Data_Length,
                                       uint8_t Advertising_Data[31]);
 */
/* Command len: 1 + 31 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 31)
  {
    goto fail;
  }

  *status = hci_le_set_advertising_data(cp0->Advertising_Data_Length /* 1 */,
                                        cp0->Advertising_Data /* 31 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x08;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_SCAN_RESPONSE_DATA_ENABLED) || HCI_LE_SET_SCAN_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_SCAN_RESPONSE_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_scan_response_data(uint8_t Scan_Response_Data_Length,
                                         uint8_t Scan_Response_Data[31]);
 */
/* Command len: 1 + 31 */
/* Response len: 1 */
uint16_t hci_le_set_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 31)
  {
    goto fail;
  }

  *status = hci_le_set_scan_response_data(cp0->Scan_Response_Data_Length /* 1 */,
                                          cp0->Scan_Response_Data /* 31 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_ADVERTISING_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_advertising_enable(uint8_t Advertising_Enable);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_enable_cp0 *cp0 = (hci_le_set_advertising_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = hci_le_set_advertising_enable(cp0->Advertising_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_SCAN_PARAMETERS_ENABLED) || HCI_LE_SET_SCAN_PARAMETERS_ENABLED) && !HCI_LE_SET_SCAN_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_scan_parameters(uint8_t LE_Scan_Type,
                                      uint16_t LE_Scan_Interval,
                                      uint16_t LE_Scan_Window,
                                      uint8_t Own_Address_Type,
                                      uint8_t Scanning_Filter_Policy);
 */
/* Command len: 1 + 2 + 2 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_scan_parameters(cp0->LE_Scan_Type /* 1 */,
                                       cp0->LE_Scan_Interval /* 2 */,
                                       cp0->LE_Scan_Window /* 2 */,
                                       cp0->Own_Address_Type /* 1 */,
                                       cp0->Scanning_Filter_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_SCAN_ENABLE_ENABLED) || HCI_LE_SET_SCAN_ENABLE_ENABLED) && !HCI_LE_SET_SCAN_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_scan_enable(uint8_t LE_Scan_Enable,
                                  uint8_t Filter_Duplicates);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_scan_enable(cp0->LE_Scan_Enable /* 1 */,
                                   cp0->Filter_Duplicates /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CREATE_CONNECTION_ENABLED) || HCI_LE_CREATE_CONNECTION_ENABLED) && !HCI_LE_CREATE_CONNECTION_FORCE_DISABLED
/* tBleStatus hci_le_create_connection(uint16_t LE_Scan_Interval,
                                    uint16_t LE_Scan_Window,
                                    uint8_t Initiator_Filter_Policy,
                                    uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6],
                                    uint8_t Own_Address_Type,
                                    uint16_t Connection_Interval_Min,
                                    uint16_t Connection_Interval_Max,
                                    uint16_t Max_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Min_CE_Length,
                                    uint16_t Max_CE_Length);
 */
/* Command len: 2 + 2 + 1 + 1 + 6 + 1 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_create_connection_cp0 *cp0 = (hci_le_create_connection_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 6 + 1 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_create_connection(cp0->LE_Scan_Interval /* 2 */,
                                     cp0->LE_Scan_Window /* 2 */,
                                     cp0->Initiator_Filter_Policy /* 1 */,
                                     cp0->Peer_Address_Type /* 1 */,
                                     cp0->Peer_Address /* 6 */,
                                     cp0->Own_Address_Type /* 1 */,
                                     cp0->Connection_Interval_Min /* 2 */,
                                     cp0->Connection_Interval_Max /* 2 */,
                                     cp0->Max_Latency /* 2 */,
                                     cp0->Supervision_Timeout /* 2 */,
                                     cp0->Min_CE_Length /* 2 */,
                                     cp0->Max_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0d;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CREATE_CONNECTION_CANCEL_ENABLED) || HCI_LE_CREATE_CONNECTION_CANCEL_ENABLED) && !HCI_LE_CREATE_CONNECTION_CANCEL_FORCE_DISABLED
/* tBleStatus hci_le_create_connection_cancel(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_create_connection_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_create_connection_cancel();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_ENABLED) || HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_ENABLED) && !HCI_LE_READ_FILTER_ACCEPT_LIST_SIZE_FORCE_DISABLED
/* tBleStatus hci_le_read_filter_accept_list_size(uint8_t *Filter_Accept_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_filter_accept_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_filter_accept_list_size_rp0 *rp0 = (hci_le_read_filter_accept_list_size_rp0 *) (buffer_out + 6);
  uint8_t Filter_Accept_List_Size = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_filter_accept_list_size(&Filter_Accept_List_Size);
fail:
  rp0->Filter_Accept_List_Size = Filter_Accept_List_Size;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CLEAR_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_CLEAR_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_CLEAR_FILTER_ACCEPT_LIST_FORCE_DISABLED
/* tBleStatus hci_le_clear_filter_accept_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_clear_filter_accept_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x10;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST_FORCE_DISABLED
/* tBleStatus hci_le_add_device_to_filter_accept_list(uint8_t Address_Type,
                                                   uint8_t Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_filter_accept_list_cp0 *cp0 = (hci_le_add_device_to_filter_accept_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = hci_le_add_device_to_filter_accept_list(cp0->Address_Type /* 1 */,
                                                    cp0->Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x11;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST_FORCE_DISABLED
/* tBleStatus hci_le_remove_device_from_filter_accept_list(uint8_t Address_Type,
                                                        uint8_t Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_filter_accept_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_filter_accept_list_cp0 *cp0 = (hci_le_remove_device_from_filter_accept_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = hci_le_remove_device_from_filter_accept_list(cp0->Address_Type /* 1 */,
                                                         cp0->Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x12;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CONNECTION_UPDATE_ENABLED) || HCI_LE_CONNECTION_UPDATE_ENABLED) && !HCI_LE_CONNECTION_UPDATE_FORCE_DISABLED
/* tBleStatus hci_le_connection_update(uint16_t Connection_Handle,
                                    uint16_t Connection_Interval_Min,
                                    uint16_t Connection_Interval_Max,
                                    uint16_t Max_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Min_CE_Length,
                                    uint16_t Max_CE_Length);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_update_cp0 *cp0 = (hci_le_connection_update_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_connection_update(cp0->Connection_Handle /* 2 */,
                                     cp0->Connection_Interval_Min /* 2 */,
                                     cp0->Connection_Interval_Max /* 2 */,
                                     cp0->Max_Latency /* 2 */,
                                     cp0->Supervision_Timeout /* 2 */,
                                     cp0->Min_CE_Length /* 2 */,
                                     cp0->Max_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x13;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_ENABLED) || HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_ENABLED) && !HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_FORCE_DISABLED
/* tBleStatus hci_le_set_host_channel_classification(uint8_t LE_Channel_Map[5]);
 */
/* Command len: 5 */
/* Response len: 1 */
uint16_t hci_le_set_host_channel_classification_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_host_channel_classification_cp0 *cp0 = (hci_le_set_host_channel_classification_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 5)
  {
    goto fail;
  }

  *status = hci_le_set_host_channel_classification(cp0->LE_Channel_Map /* 5 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x14;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_CHANNEL_MAP_ENABLED) || HCI_LE_READ_CHANNEL_MAP_ENABLED) && !HCI_LE_READ_CHANNEL_MAP_FORCE_DISABLED
/* tBleStatus hci_le_read_channel_map(uint16_t Connection_Handle,
                                   uint8_t LE_Channel_Map[5]);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 5 */
uint16_t hci_le_read_channel_map_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_channel_map_cp0 *cp0 = (hci_le_read_channel_map_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 5;
  /* Output params */
  hci_le_read_channel_map_rp0 *rp0 = (hci_le_read_channel_map_rp0 *) (buffer_out + 6);
  uint8_t LE_Channel_Map[5] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 5 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_channel_map(cp0->Connection_Handle /* 2 */,
                                        LE_Channel_Map);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  Osal_MemCpy((void *) rp0->LE_Channel_Map,(const void *) LE_Channel_Map, 5);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x15;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_REMOTE_FEATURES_ENABLED) || HCI_LE_READ_REMOTE_FEATURES_ENABLED) && !HCI_LE_READ_REMOTE_FEATURES_FORCE_DISABLED
/* tBleStatus hci_le_read_remote_features(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_read_remote_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_remote_features_cp0 *cp0 = (hci_le_read_remote_features_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_le_read_remote_features(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x16;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ENCRYPT_ENABLED) || HCI_LE_ENCRYPT_ENABLED) && !HCI_LE_ENCRYPT_FORCE_DISABLED
/* tBleStatus hci_le_encrypt(uint8_t Key[16],
                          uint8_t Plaintext_Data[16],
                          uint8_t Encrypted_Data[16]);
 */
/* Command len: 16 + 16 */
/* Response len: 1 + 16 */
uint16_t hci_le_encrypt_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_encrypt_cp0 *cp0 = (hci_le_encrypt_cp0 *)(buffer_in + (0));

  int output_size = 1 + 16;
  /* Output params */
  hci_le_encrypt_rp0 *rp0 = (hci_le_encrypt_rp0 *) (buffer_out + 6);
  uint8_t Encrypted_Data[16] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 16 + 6)) { return 0; }
  if(buffer_in_length != 16 + 16)
  {
    goto fail;
  }

  rp0->Status = hci_le_encrypt(cp0->Key /* 16 */,
                               cp0->Plaintext_Data /* 16 */,
                               Encrypted_Data);
fail:
  Osal_MemCpy((void *) rp0->Encrypted_Data,(const void *) Encrypted_Data, 16);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x17;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_RAND_ENABLED) || HCI_LE_RAND_ENABLED) && !HCI_LE_RAND_FORCE_DISABLED
/* tBleStatus hci_le_rand(uint8_t Random_Number[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_rand_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_rand_rp0 *rp0 = (hci_le_rand_rp0 *) (buffer_out + 6);
  uint8_t Random_Number[8] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_rand(Random_Number);
fail:
  Osal_MemCpy((void *) rp0->Random_Number,(const void *) Random_Number, 8);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x18;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ENABLE_ENCRYPTION_ENABLED) || HCI_LE_ENABLE_ENCRYPTION_ENABLED) && !HCI_LE_ENABLE_ENCRYPTION_FORCE_DISABLED
/* tBleStatus hci_le_enable_encryption(uint16_t Connection_Handle,
                                    uint8_t Random_Number[8],
                                    uint16_t Encrypted_Diversifier,
                                    uint8_t Long_Term_Key[16]);
 */
/* Command len: 2 + 8 + 2 + 16 */
/* Response len: 1 */
uint16_t hci_le_enable_encryption_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_enable_encryption_cp0 *cp0 = (hci_le_enable_encryption_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 8 + 2 + 16)
  {
    goto fail;
  }

  *status = hci_le_enable_encryption(cp0->Connection_Handle /* 2 */,
                                     cp0->Random_Number /* 8 */,
                                     cp0->Encrypted_Diversifier /* 2 */,
                                     cp0->Long_Term_Key /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x19;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_ENABLED) || HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_ENABLED) && !HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_FORCE_DISABLED
/* tBleStatus hci_le_long_term_key_request_reply(uint16_t Connection_Handle,
                                              uint8_t Long_Term_Key[16]);
 */
/* Command len: 2 + 16 */
/* Response len: 1 + 2 */
uint16_t hci_le_long_term_key_request_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_long_term_key_request_reply_cp0 *cp0 = (hci_le_long_term_key_request_reply_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_long_term_key_request_reply_rp0 *rp0 = (hci_le_long_term_key_request_reply_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 16)
  {
    goto fail;
  }

  rp0->Status = hci_le_long_term_key_request_reply(cp0->Connection_Handle /* 2 */,
                                                   cp0->Long_Term_Key /* 16 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_ENABLED) || HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_ENABLED) && !HCI_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY_FORCE_DISABLED
/* tBleStatus hci_le_long_term_key_request_negative_reply(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_long_term_key_request_negative_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_long_term_key_request_negative_reply_cp0 *cp0 = (hci_le_long_term_key_request_negative_reply_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_long_term_key_request_negative_reply_rp0 *rp0 = (hci_le_long_term_key_request_negative_reply_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_long_term_key_request_negative_reply(cp0->Connection_Handle /* 2 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_SUPPORTED_STATES_ENABLED) || HCI_LE_READ_SUPPORTED_STATES_ENABLED) && !HCI_LE_READ_SUPPORTED_STATES_FORCE_DISABLED
/* tBleStatus hci_le_read_supported_states(uint8_t LE_States[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_read_supported_states_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_read_supported_states_rp0 *rp0 = (hci_le_read_supported_states_rp0 *) (buffer_out + 6);
  uint8_t LE_States[8] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_supported_states(LE_States);
fail:
  Osal_MemCpy((void *) rp0->LE_States,(const void *) LE_States, 8);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_RECEIVER_TEST_ENABLED) || HCI_LE_RECEIVER_TEST_ENABLED) && !HCI_LE_RECEIVER_TEST_FORCE_DISABLED
/* tBleStatus hci_le_receiver_test(uint8_t RX_Frequency);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_receiver_test_cp0 *cp0 = (hci_le_receiver_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = hci_le_receiver_test(cp0->RX_Frequency /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TRANSMITTER_TEST_ENABLED) || HCI_LE_TRANSMITTER_TEST_ENABLED) && !HCI_LE_TRANSMITTER_TEST_FORCE_DISABLED
/* tBleStatus hci_le_transmitter_test(uint8_t TX_Frequency,
                                   uint8_t Length_Of_Test_Data,
                                   uint8_t Packet_Payload);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_cp0 *cp0 = (hci_le_transmitter_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_transmitter_test(cp0->TX_Frequency /* 1 */,
                                    cp0->Length_Of_Test_Data /* 1 */,
                                    cp0->Packet_Payload /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TEST_END_ENABLED) || HCI_LE_TEST_END_ENABLED) && !HCI_LE_TEST_END_FORCE_DISABLED
/* tBleStatus hci_le_test_end(uint16_t *Number_Of_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t hci_le_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  hci_le_test_end_rp0 *rp0 = (hci_le_test_end_rp0 *) (buffer_out + 6);
  uint16_t Number_Of_Packets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_test_end(&Number_Of_Packets);
fail:
  rp0->Number_Of_Packets = Number_Of_Packets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_DATA_LENGTH_ENABLED) || HCI_LE_SET_DATA_LENGTH_ENABLED) && !HCI_LE_SET_DATA_LENGTH_FORCE_DISABLED
/* tBleStatus hci_le_set_data_length(uint16_t Connection_Handle,
                                  uint16_t TxOctets,
                                  uint16_t TxTime);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_data_length_cp0 *cp0 = (hci_le_set_data_length_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_data_length_rp0 *rp0 = (hci_le_set_data_length_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_data_length(cp0->Connection_Handle /* 2 */,
                                       cp0->TxOctets /* 2 */,
                                       cp0->TxTime /* 2 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x22;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) || HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) && !HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_FORCE_DISABLED
/* tBleStatus hci_le_read_suggested_default_data_length(uint16_t *SuggestedMaxTxOctets,
                                                     uint16_t *SuggestedMaxTxTime);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_le_read_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_le_read_suggested_default_data_length_rp0 *rp0 = (hci_le_read_suggested_default_data_length_rp0 *) (buffer_out + 6);
  uint16_t SuggestedMaxTxOctets = 0;
  uint16_t SuggestedMaxTxTime = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_suggested_default_data_length(&SuggestedMaxTxOctets,
                                                          &SuggestedMaxTxTime);
fail:
  rp0->SuggestedMaxTxOctets = SuggestedMaxTxOctets;
  rp0->SuggestedMaxTxTime = SuggestedMaxTxTime;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x23;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) || HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_ENABLED) && !HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_FORCE_DISABLED
/* tBleStatus hci_le_write_suggested_default_data_length(uint16_t SuggestedMaxTxOctets,
                                                      uint16_t SuggestedMaxTxTime);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_write_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_write_suggested_default_data_length_cp0 *cp0 = (hci_le_write_suggested_default_data_length_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_write_suggested_default_data_length(cp0->SuggestedMaxTxOctets /* 2 */,
                                                       cp0->SuggestedMaxTxTime /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x24;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_ENABLED) || HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_ENABLED) && !HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_FORCE_DISABLED
/* tBleStatus hci_le_read_local_p256_public_key(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_read_local_p256_public_key_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_read_local_p256_public_key();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x25;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_GENERATE_DHKEY_ENABLED) || HCI_LE_GENERATE_DHKEY_ENABLED) && !HCI_LE_GENERATE_DHKEY_FORCE_DISABLED
/* tBleStatus hci_le_generate_dhkey(uint8_t Remote_P256_Public_Key[64]);
 */
/* Command len: 64 */
/* Response len: 1 */
uint16_t hci_le_generate_dhkey_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_generate_dhkey_cp0 *cp0 = (hci_le_generate_dhkey_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 64)
  {
    goto fail;
  }

  *status = hci_le_generate_dhkey(cp0->Remote_P256_Public_Key /* 64 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x26;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_FORCE_DISABLED
/* tBleStatus hci_le_add_device_to_resolving_list(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_IRK[16],
                                               uint8_t Local_IRK[16]);
 */
/* Command len: 1 + 6 + 16 + 16 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_resolving_list_cp0 *cp0 = (hci_le_add_device_to_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 16 + 16)
  {
    goto fail;
  }

  *status = hci_le_add_device_to_resolving_list(cp0->Peer_Identity_Address_Type /* 1 */,
                                                cp0->Peer_Identity_Address /* 6 */,
                                                cp0->Peer_IRK /* 16 */,
                                                cp0->Local_IRK /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x27;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_FORCE_DISABLED
/* tBleStatus hci_le_remove_device_from_resolving_list(uint8_t Peer_Identity_Address_Type,
                                                    uint8_t Peer_Identity_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_resolving_list_cp0 *cp0 = (hci_le_remove_device_from_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = hci_le_remove_device_from_resolving_list(cp0->Peer_Identity_Address_Type /* 1 */,
                                                     cp0->Peer_Identity_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x28;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CLEAR_RESOLVING_LIST_ENABLED) || HCI_LE_CLEAR_RESOLVING_LIST_ENABLED) && !HCI_LE_CLEAR_RESOLVING_LIST_FORCE_DISABLED
/* tBleStatus hci_le_clear_resolving_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_clear_resolving_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x29;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_RESOLVING_LIST_SIZE_ENABLED) || HCI_LE_READ_RESOLVING_LIST_SIZE_ENABLED) && !HCI_LE_READ_RESOLVING_LIST_SIZE_FORCE_DISABLED
/* tBleStatus hci_le_read_resolving_list_size(uint8_t *Resolving_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_resolving_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_resolving_list_size_rp0 *rp0 = (hci_le_read_resolving_list_size_rp0 *) (buffer_out + 6);
  uint8_t Resolving_List_Size = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_resolving_list_size(&Resolving_List_Size);
fail:
  rp0->Resolving_List_Size = Resolving_List_Size;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_ENABLED) || HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_ENABLED) && !HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_FORCE_DISABLED
/* tBleStatus hci_le_read_peer_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_Resolvable_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 + 6 */
uint16_t hci_le_read_peer_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_peer_resolvable_address_cp0 *cp0 = (hci_le_read_peer_resolvable_address_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  hci_le_read_peer_resolvable_address_rp0 *rp0 = (hci_le_read_peer_resolvable_address_rp0 *) (buffer_out + 6);
  uint8_t Peer_Resolvable_Address[6] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_peer_resolvable_address(cp0->Peer_Identity_Address_Type /* 1 */,
                                                    cp0->Peer_Identity_Address /* 6 */,
                                                    Peer_Resolvable_Address);
fail:
  Osal_MemCpy((void *) rp0->Peer_Resolvable_Address,(const void *) Peer_Resolvable_Address, 6);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_ENABLED) || HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_ENABLED) && !HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_FORCE_DISABLED
/* tBleStatus hci_le_read_local_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                                uint8_t Peer_Identity_Address[6],
                                                uint8_t Local_Resolvable_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 + 6 */
uint16_t hci_le_read_local_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_local_resolvable_address_cp0 *cp0 = (hci_le_read_local_resolvable_address_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  hci_le_read_local_resolvable_address_rp0 *rp0 = (hci_le_read_local_resolvable_address_rp0 *) (buffer_out + 6);
  uint8_t Local_Resolvable_Address[6] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_local_resolvable_address(cp0->Peer_Identity_Address_Type /* 1 */,
                                                     cp0->Peer_Identity_Address /* 6 */,
                                                     Local_Resolvable_Address);
fail:
  Osal_MemCpy((void *) rp0->Local_Resolvable_Address,(const void *) Local_Resolvable_Address, 6);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_ENABLED) || HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_ENABLED) && !HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_address_resolution_enable(uint8_t Address_Resolution_Enable);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_set_address_resolution_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_address_resolution_enable_cp0 *cp0 = (hci_le_set_address_resolution_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = hci_le_set_address_resolution_enable(cp0->Address_Resolution_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_ENABLED) || HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_ENABLED) && !HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_FORCE_DISABLED
/* tBleStatus hci_le_set_resolvable_private_address_timeout(uint16_t RPA_Timeout);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_set_resolvable_private_address_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_resolvable_private_address_timeout_cp0 *cp0 = (hci_le_set_resolvable_private_address_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_le_set_resolvable_private_address_timeout(cp0->RPA_Timeout /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_MAXIMUM_DATA_LENGTH_ENABLED) || HCI_LE_READ_MAXIMUM_DATA_LENGTH_ENABLED) && !HCI_LE_READ_MAXIMUM_DATA_LENGTH_FORCE_DISABLED
/* tBleStatus hci_le_read_maximum_data_length(uint16_t *supportedMaxTxOctets,
                                           uint16_t *supportedMaxTxTime,
                                           uint16_t *supportedMaxRxOctets,
                                           uint16_t *supportedMaxRxTime);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 + 2 + 2 */
uint16_t hci_le_read_maximum_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2 + 2 + 2;
  /* Output params */
  hci_le_read_maximum_data_length_rp0 *rp0 = (hci_le_read_maximum_data_length_rp0 *) (buffer_out + 6);
  uint16_t supportedMaxTxOctets = 0;
  uint16_t supportedMaxTxTime = 0;
  uint16_t supportedMaxRxOctets = 0;
  uint16_t supportedMaxRxTime = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_maximum_data_length(&supportedMaxTxOctets,
                                                &supportedMaxTxTime,
                                                &supportedMaxRxOctets,
                                                &supportedMaxRxTime);
fail:
  rp0->supportedMaxTxOctets = supportedMaxTxOctets;
  rp0->supportedMaxTxTime = supportedMaxTxTime;
  rp0->supportedMaxRxOctets = supportedMaxRxOctets;
  rp0->supportedMaxRxTime = supportedMaxRxTime;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_PHY_ENABLED) || HCI_LE_READ_PHY_ENABLED) && !HCI_LE_READ_PHY_FORCE_DISABLED
/* tBleStatus hci_le_read_phy(uint16_t Connection_Handle,
                           uint8_t *TX_PHY,
                           uint8_t *RX_PHY);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 1 + 1 */
uint16_t hci_le_read_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_phy_cp0 *cp0 = (hci_le_read_phy_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1 + 1;
  /* Output params */
  hci_le_read_phy_rp0 *rp0 = (hci_le_read_phy_rp0 *) (buffer_out + 6);
  uint8_t TX_PHY = 0;
  uint8_t RX_PHY = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_phy(cp0->Connection_Handle /* 2 */,
                                &TX_PHY,
                                &RX_PHY);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->TX_PHY = TX_PHY;
  rp0->RX_PHY = RX_PHY;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x30;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_DEFAULT_PHY_ENABLED) || HCI_LE_SET_DEFAULT_PHY_ENABLED) && !HCI_LE_SET_DEFAULT_PHY_FORCE_DISABLED
/* tBleStatus hci_le_set_default_phy(uint8_t ALL_PHYS,
                                  uint8_t TX_PHYS,
                                  uint8_t RX_PHYS);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_default_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_default_phy_cp0 *cp0 = (hci_le_set_default_phy_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_default_phy(cp0->ALL_PHYS /* 1 */,
                                   cp0->TX_PHYS /* 1 */,
                                   cp0->RX_PHYS /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x31;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PHY_ENABLED) || HCI_LE_SET_PHY_ENABLED) && !HCI_LE_SET_PHY_FORCE_DISABLED
/* tBleStatus hci_le_set_phy(uint16_t Connection_Handle,
                          uint8_t ALL_PHYS,
                          uint8_t TX_PHYS,
                          uint8_t RX_PHYS,
                          uint16_t PHY_options);
 */
/* Command len: 2 + 1 + 1 + 1 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_phy_cp0 *cp0 = (hci_le_set_phy_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 2)
  {
    goto fail;
  }

  *status = hci_le_set_phy(cp0->Connection_Handle /* 2 */,
                           cp0->ALL_PHYS /* 1 */,
                           cp0->TX_PHYS /* 1 */,
                           cp0->RX_PHYS /* 1 */,
                           cp0->PHY_options /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x32;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_RECEIVER_TEST_V2_ENABLED) || HCI_LE_RECEIVER_TEST_V2_ENABLED) && !HCI_LE_RECEIVER_TEST_V2_FORCE_DISABLED
/* tBleStatus hci_le_receiver_test_v2(uint8_t RX_Channel,
                                   uint8_t PHY,
                                   uint8_t Modulation_index);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_receiver_test_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_receiver_test_v2_cp0 *cp0 = (hci_le_receiver_test_v2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_receiver_test_v2(cp0->RX_Channel /* 1 */,
                                    cp0->PHY /* 1 */,
                                    cp0->Modulation_index /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x33;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TRANSMITTER_TEST_V2_ENABLED) || HCI_LE_TRANSMITTER_TEST_V2_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V2_FORCE_DISABLED
/* tBleStatus hci_le_transmitter_test_v2(uint8_t TX_Channel,
                                      uint8_t Length_Of_Test_Data,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY);
 */
/* Command len: 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_v2_cp0 *cp0 = (hci_le_transmitter_test_v2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_transmitter_test_v2(cp0->TX_Channel /* 1 */,
                                       cp0->Length_Of_Test_Data /* 1 */,
                                       cp0->Packet_Payload /* 1 */,
                                       cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x34;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_ENABLED) || HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_ENABLED) && !HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS_FORCE_DISABLED
/* tBleStatus hci_le_set_advertising_set_random_address(uint8_t Advertising_Handle,
                                                     uint8_t Advertising_Random_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_set_random_address_cp0 *cp0 = (hci_le_set_advertising_set_random_address_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = hci_le_set_advertising_set_random_address(cp0->Advertising_Handle /* 1 */,
                                                      cp0->Advertising_Random_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Advertising_Event_Properties,
                                                      uint8_t Primary_Advertising_Interval_Min[3],
                                                      uint8_t Primary_Advertising_Interval_Max[3],
                                                      uint8_t Primary_Advertising_Channel_Map,
                                                      uint8_t Own_Address_Type,
                                                      uint8_t Peer_Address_Type,
                                                      uint8_t Peer_Address[6],
                                                      uint8_t Advertising_Filter_Policy,
                                                      int8_t Advertising_Tx_Power,
                                                      uint8_t Primary_Advertising_PHY,
                                                      uint8_t Secondary_Advertising_Max_Skip,
                                                      uint8_t Secondary_Advertising_PHY,
                                                      uint8_t Advertising_SID,
                                                      uint8_t Scan_Request_Notification_Enable,
                                                      int8_t *Selected_Tx_Power);
 */
/* Command len: 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_set_extended_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_parameters_cp0 *cp0 = (hci_le_set_extended_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_set_extended_advertising_parameters_rp0 *rp0 = (hci_le_set_extended_advertising_parameters_rp0 *) (buffer_out + 6);
  int8_t Selected_Tx_Power = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_extended_advertising_parameters(cp0->Advertising_Handle /* 1 */,
                                                           cp0->Advertising_Event_Properties /* 2 */,
                                                           cp0->Primary_Advertising_Interval_Min /* 3 */,
                                                           cp0->Primary_Advertising_Interval_Max /* 3 */,
                                                           cp0->Primary_Advertising_Channel_Map /* 1 */,
                                                           cp0->Own_Address_Type /* 1 */,
                                                           cp0->Peer_Address_Type /* 1 */,
                                                           cp0->Peer_Address /* 6 */,
                                                           cp0->Advertising_Filter_Policy /* 1 */,
                                                           cp0->Advertising_Tx_Power /* 1 */,
                                                           cp0->Primary_Advertising_PHY /* 1 */,
                                                           cp0->Secondary_Advertising_Max_Skip /* 1 */,
                                                           cp0->Secondary_Advertising_PHY /* 1 */,
                                                           cp0->Advertising_SID /* 1 */,
                                                           cp0->Scan_Request_Notification_Enable /* 1 */,
                                                           &Selected_Tx_Power);
fail:
  rp0->Selected_Tx_Power = Selected_Tx_Power;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_advertising_data(uint8_t Advertising_Handle,
                                                uint8_t Operation,
                                                uint8_t Fragment_Preference,
                                                uint8_t Advertising_Data_Length,
                                                uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_data_cp0 *cp0 = (hci_le_set_extended_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_set_extended_advertising_data(cp0->Advertising_Handle /* 1 */,
                                                 cp0->Operation /* 1 */,
                                                 cp0->Fragment_Preference /* 1 */,
                                                 cp0->Advertising_Data_Length /* 1 */,
                                                 cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_scan_response_data(uint8_t Advertising_Handle,
                                                  uint8_t Operation,
                                                  uint8_t Fragment_Preference,
                                                  uint8_t Scan_Response_Data_Length,
                                                  uint8_t Scan_Response_Data[]);
 */
/* Command len: 1 + 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_response_data_cp0 *cp0 = (hci_le_set_extended_scan_response_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_set_extended_scan_response_data(cp0->Advertising_Handle /* 1 */,
                                                   cp0->Operation /* 1 */,
                                                   cp0->Fragment_Preference /* 1 */,
                                                   cp0->Scan_Response_Data_Length /* 1 */,
                                                   cp0->Scan_Response_Data /* cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x38;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE_FORCE_DISABLED
tBleStatus hci_le_set_extended_advertising_enable_preprocess(uint8_t Enable,
                                                             uint8_t Number_of_Sets,
                                                             Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/* tBleStatus hci_le_set_extended_advertising_enable(uint8_t Enable,
                                                  uint8_t Number_of_Sets,
                                                  Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
 */
/* Command len: 1 + 1 + struct_length */
/* Response len: 1 */
uint16_t hci_le_set_extended_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_enable_cp0 *cp0 = (hci_le_set_extended_advertising_enable_cp0 *)(buffer_in + (0));
  Advertising_Set_Parameters_t Advertising_Set_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->Number_of_Sets > HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t))
  {
    cp0->Number_of_Sets = 0;
    goto fail;
  }
  for (i = 0; i < cp0->Number_of_Sets; i++) {
    packed_Advertising_Set_Parameters_t *Advertising_Set_Parameters_tmp = (packed_Advertising_Set_Parameters_t *)(((uint8_t *)cp0->Advertising_Set_Parameters) + struct_length);
    Advertising_Set_Parameters[i].Advertising_Handle = Advertising_Set_Parameters_tmp->Advertising_Handle;
    struct_length += 1;
    Advertising_Set_Parameters[i].Duration = Advertising_Set_Parameters_tmp->Duration;
    struct_length += 2;
    Advertising_Set_Parameters[i].Max_Extended_Advertising_Events = Advertising_Set_Parameters_tmp->Max_Extended_Advertising_Events;
    struct_length += 1;
  }
  if(buffer_in_length != 1 + 1 + struct_length)
  {
    goto fail;
  }

  *status = hci_le_set_extended_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                              cp0->Number_of_Sets /* 1 */,
                                                              Advertising_Set_Parameters /* struct_length */);
  if(*status)
    goto fail;

  *status = hci_le_set_extended_advertising_enable(cp0->Enable /* 1 */,
                                                   cp0->Number_of_Sets /* 1 */,
                                                   Advertising_Set_Parameters /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x39;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_ENABLED) || HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_ENABLED) && !HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH_FORCE_DISABLED
/* tBleStatus hci_le_read_maximum_advertising_data_length(uint16_t *Maximum_Advertising_Data_Length);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t hci_le_read_maximum_advertising_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  hci_le_read_maximum_advertising_data_length_rp0 *rp0 = (hci_le_read_maximum_advertising_data_length_rp0 *) (buffer_out + 6);
  uint16_t Maximum_Advertising_Data_Length = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_maximum_advertising_data_length(&Maximum_Advertising_Data_Length);
fail:
  rp0->Maximum_Advertising_Data_Length = Maximum_Advertising_Data_Length;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_ENABLED) || HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_ENABLED) && !HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS_FORCE_DISABLED
/* tBleStatus hci_le_read_number_of_supported_advertising_sets(uint8_t *Num_Supported_Advertising_Sets);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_number_of_supported_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_number_of_supported_advertising_sets_rp0 *rp0 = (hci_le_read_number_of_supported_advertising_sets_rp0 *) (buffer_out + 6);
  uint8_t Num_Supported_Advertising_Sets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_number_of_supported_advertising_sets(&Num_Supported_Advertising_Sets);
fail:
  rp0->Num_Supported_Advertising_Sets = Num_Supported_Advertising_Sets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_ADVERTISING_SET_ENABLED) || HCI_LE_REMOVE_ADVERTISING_SET_ENABLED) && !HCI_LE_REMOVE_ADVERTISING_SET_FORCE_DISABLED
/* tBleStatus hci_le_remove_advertising_set(uint8_t Advertising_Handle);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_advertising_set_cp0 *cp0 = (hci_le_remove_advertising_set_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = hci_le_remove_advertising_set(cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CLEAR_ADVERTISING_SETS_ENABLED) || HCI_LE_CLEAR_ADVERTISING_SETS_ENABLED) && !HCI_LE_CLEAR_ADVERTISING_SETS_FORCE_DISABLED
/* tBleStatus hci_le_clear_advertising_sets(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_clear_advertising_sets();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Periodic_Advertising_Interval_Min,
                                                      uint16_t Periodic_Advertising_Interval_Max,
                                                      uint16_t Periodic_Advertising_Properties);
 */
/* Command len: 1 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_parameters_cp0 *cp0 = (hci_le_set_periodic_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_parameters(cp0->Advertising_Handle /* 1 */,
                                                       cp0->Periodic_Advertising_Interval_Min /* 2 */,
                                                       cp0->Periodic_Advertising_Interval_Max /* 2 */,
                                                       cp0->Periodic_Advertising_Properties /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_data(uint8_t Advertising_Handle,
                                                uint8_t Operation,
                                                uint8_t Advertising_Data_Length,
                                                uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_data_cp0 *cp0 = (hci_le_set_periodic_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_data(cp0->Advertising_Handle /* 1 */,
                                                 cp0->Operation /* 1 */,
                                                 cp0->Advertising_Data_Length /* 1 */,
                                                 cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE_FORCE_DISABLED
tBleStatus hci_le_set_periodic_advertising_enable_preprocess(uint8_t Enable,
                                                             uint8_t Advertising_Handle);
/* tBleStatus hci_le_set_periodic_advertising_enable(uint8_t Enable,
                                                  uint8_t Advertising_Handle);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_enable_cp0 *cp0 = (hci_le_set_periodic_advertising_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                              cp0->Advertising_Handle /* 1 */);
  if(*status)
    goto fail;

  *status = hci_le_set_periodic_advertising_enable(cp0->Enable /* 1 */,
                                                   cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x40;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_scan_parameters(uint8_t Own_Address_Type,
                                               uint8_t Scanning_Filter_Policy,
                                               uint8_t Scanning_PHYs,
                                               Extended_Scan_Parameters_t Extended_Scan_Parameters[]);
 */
/* Command len: 1 + 1 + 1 + struct_length */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_parameters_cp0 *cp0 = (hci_le_set_extended_scan_parameters_cp0 *)(buffer_in + (0));
  Extended_Scan_Parameters_t Extended_Scan_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Scan_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  int len = 0;

  for (i = 0; i < sizeof( cp0->Scanning_PHYs)*8; i++) {
    if((cp0->Scanning_PHYs >> i) & 0x01){
      len++;
    }
  }
  if(len > HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Scan_Parameters_t))
  {
    len = 0;
    goto fail;
  }
  for (i = 0; i < len; i++) {
    packed_Extended_Scan_Parameters_t *Extended_Scan_Parameters_tmp = (packed_Extended_Scan_Parameters_t *)(((uint8_t *)cp0->Extended_Scan_Parameters) + struct_length);
    Extended_Scan_Parameters[i].Scan_Type = Extended_Scan_Parameters_tmp->Scan_Type;
    struct_length += 1;
    Extended_Scan_Parameters[i].Scan_Interval = Extended_Scan_Parameters_tmp->Scan_Interval;
    struct_length += 2;
    Extended_Scan_Parameters[i].Scan_Window = Extended_Scan_Parameters_tmp->Scan_Window;
    struct_length += 2;
  }
  if(buffer_in_length != 1 + 1 + 1 + struct_length)
  {
    goto fail;
  }

  *status = hci_le_set_extended_scan_parameters(cp0->Own_Address_Type /* 1 */,
                                                cp0->Scanning_Filter_Policy /* 1 */,
                                                cp0->Scanning_PHYs /* 1 */,
                                                Extended_Scan_Parameters /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x41;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_SCAN_ENABLE_ENABLED) || HCI_LE_SET_EXTENDED_SCAN_ENABLE_ENABLED) && !HCI_LE_SET_EXTENDED_SCAN_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_scan_enable(uint8_t Enable,
                                           uint8_t Filter_Duplicates,
                                           uint16_t Duration,
                                           uint16_t Period);
 */
/* Command len: 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_enable_cp0 *cp0 = (hci_le_set_extended_scan_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_set_extended_scan_enable(cp0->Enable /* 1 */,
                                            cp0->Filter_Duplicates /* 1 */,
                                            cp0->Duration /* 2 */,
                                            cp0->Period /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x42;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_EXTENDED_CREATE_CONNECTION_ENABLED) || HCI_LE_EXTENDED_CREATE_CONNECTION_ENABLED) && !HCI_LE_EXTENDED_CREATE_CONNECTION_FORCE_DISABLED
/* tBleStatus hci_le_extended_create_connection(uint8_t Initiator_Filter_Policy,
                                                uint8_t Own_Address_Type,
                                                uint8_t Peer_Address_Type,
                                                uint8_t Peer_Address[6],
                                                uint8_t Initiating_PHYs,
                                                Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[]);
 */
/* Command len: 1 + 1 + 1 + 6 + 1 + struct_length */
/* Response len: 1 */
uint16_t hci_le_extended_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_extended_create_connection_cp0 *cp0 = (hci_le_extended_create_connection_cp0 *)(buffer_in + (0));
  Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Create_Connection_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  int len = 0;

  for (i = 0; i < sizeof( cp0->Initiating_PHYs)*8; i++) {
    if((cp0->Initiating_PHYs >> i) & 0x01){
      len++;
    }
  }
  if(len > HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Create_Connection_Parameters_t))
  {
    len = 0;
    goto fail;
  }
  for (i = 0; i < len; i++) {
    packed_Extended_Create_Connection_Parameters_t *Extended_Create_Connection_Parameters_tmp = (packed_Extended_Create_Connection_Parameters_t *)(((uint8_t *)cp0->Extended_Create_Connection_Parameters) + struct_length);
    Extended_Create_Connection_Parameters[i].Scan_Interval = Extended_Create_Connection_Parameters_tmp->Scan_Interval;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Scan_Window = Extended_Create_Connection_Parameters_tmp->Scan_Window;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Connection_Interval_Min = Extended_Create_Connection_Parameters_tmp->Connection_Interval_Min;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Connection_Interval_Max = Extended_Create_Connection_Parameters_tmp->Connection_Interval_Max;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Max_Latency = Extended_Create_Connection_Parameters_tmp->Max_Latency;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Supervision_Timeout = Extended_Create_Connection_Parameters_tmp->Supervision_Timeout;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Min_CE_Length = Extended_Create_Connection_Parameters_tmp->Min_CE_Length;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Max_CE_Length = Extended_Create_Connection_Parameters_tmp->Max_CE_Length;
    struct_length += 2;
  }
  if(buffer_in_length != 1 + 1 + 1 + 6 + 1 + struct_length)
  {
    goto fail;
  }

  *status = hci_le_extended_create_connection(cp0->Initiator_Filter_Policy /* 1 */,
                                              cp0->Own_Address_Type /* 1 */,
                                              cp0->Peer_Address_Type /* 1 */,
                                              cp0->Peer_Address /* 6 */,
                                              cp0->Initiating_PHYs /* 1 */,
                                              Extended_Create_Connection_Parameters /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x43;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_FORCE_DISABLED
/* tBleStatus hci_le_periodic_advertising_create_sync(uint8_t Options,
                                                   uint8_t Advertising_SID,
                                                   uint8_t Advertiser_Address_Type,
                                                   uint8_t Advertiser_Address[6],
                                                   uint16_t Skip,
                                                   uint16_t Sync_Timeout,
                                                   uint8_t Sync_CTE_Type);
 */
/* Command len: 1 + 1 + 1 + 6 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_create_sync_cp0 *cp0 = (hci_le_periodic_advertising_create_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 6 + 2 + 2 + 1)
  {
    goto fail;
  }

  *status = hci_le_periodic_advertising_create_sync(cp0->Options /* 1 */,
                                                    cp0->Advertising_SID /* 1 */,
                                                    cp0->Advertiser_Address_Type /* 1 */,
                                                    cp0->Advertiser_Address /* 6 */,
                                                    cp0->Skip /* 2 */,
                                                    cp0->Sync_Timeout /* 2 */,
                                                    cp0->Sync_CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x44;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL_FORCE_DISABLED
/* tBleStatus hci_le_periodic_advertising_create_sync_cancel(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_periodic_advertising_create_sync_cancel();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x45;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC_FORCE_DISABLED
/* tBleStatus hci_le_periodic_advertising_terminate_sync(uint16_t Sync_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_terminate_sync_cp0 *cp0 = (hci_le_periodic_advertising_terminate_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_le_periodic_advertising_terminate_sync(cp0->Sync_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x46;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
/* tBleStatus hci_le_add_device_to_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                         uint8_t Advertiser_Address[6],
                                                         uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_periodic_advertiser_list_cp0 *cp0 = (hci_le_add_device_to_periodic_advertiser_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    goto fail;
  }

  *status = hci_le_add_device_to_periodic_advertiser_list(cp0->Advertiser_Address_Type /* 1 */,
                                                          cp0->Advertiser_Address /* 6 */,
                                                          cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x47;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
/* tBleStatus hci_le_remove_device_from_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                              uint8_t Advertiser_Address[6],
                                                              uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_periodic_advertiser_list_cp0 *cp0 = (hci_le_remove_device_from_periodic_advertiser_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    goto fail;
  }

  *status = hci_le_remove_device_from_periodic_advertiser_list(cp0->Advertiser_Address_Type /* 1 */,
                                                               cp0->Advertiser_Address /* 6 */,
                                                               cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x48;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_ENABLED) || HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_ENABLED) && !HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST_FORCE_DISABLED
/* tBleStatus hci_le_clear_periodic_advertiser_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = hci_le_clear_periodic_advertiser_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x49;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_ENABLED) || HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_ENABLED) && !HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE_FORCE_DISABLED
/* tBleStatus hci_le_read_periodic_advertiser_list_size(uint8_t *Periodic_Advertiser_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_periodic_advertiser_list_size_rp0 *rp0 = (hci_le_read_periodic_advertiser_list_size_rp0 *) (buffer_out + 6);
  uint8_t Periodic_Advertiser_List_Size = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_periodic_advertiser_list_size(&Periodic_Advertiser_List_Size);
fail:
  rp0->Periodic_Advertiser_List_Size = Periodic_Advertiser_List_Size;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_TRANSMIT_POWER_ENABLED) || HCI_LE_READ_TRANSMIT_POWER_ENABLED) && !HCI_LE_READ_TRANSMIT_POWER_FORCE_DISABLED
/* tBleStatus hci_le_read_transmit_power(int8_t *Min_Tx_Power,
                                      int8_t *Max_Tx_Power);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 */
uint16_t hci_le_read_transmit_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1;
  /* Output params */
  hci_le_read_transmit_power_rp0 *rp0 = (hci_le_read_transmit_power_rp0 *) (buffer_out + 6);
  int8_t Min_Tx_Power = 0;
  int8_t Max_Tx_Power = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_transmit_power(&Min_Tx_Power,
                                           &Max_Tx_Power);
fail:
  rp0->Min_Tx_Power = Min_Tx_Power;
  rp0->Max_Tx_Power = Max_Tx_Power;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_RF_PATH_COMPENSATION_ENABLED) || HCI_LE_READ_RF_PATH_COMPENSATION_ENABLED) && !HCI_LE_READ_RF_PATH_COMPENSATION_FORCE_DISABLED
/* tBleStatus hci_le_read_rf_path_compensation(int16_t *RF_TX_Path_Compensation_Value,
                                            int16_t *RF_RX_Path_Compensation_Value);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_le_read_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_le_read_rf_path_compensation_rp0 *rp0 = (hci_le_read_rf_path_compensation_rp0 *) (buffer_out + 6);
  int16_t RF_TX_Path_Compensation_Value = 0;
  int16_t RF_RX_Path_Compensation_Value = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_rf_path_compensation(&RF_TX_Path_Compensation_Value,
                                                 &RF_RX_Path_Compensation_Value);
fail:
  rp0->RF_TX_Path_Compensation_Value = RF_TX_Path_Compensation_Value;
  rp0->RF_RX_Path_Compensation_Value = RF_RX_Path_Compensation_Value;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_WRITE_RF_PATH_COMPENSATION_ENABLED) || HCI_LE_WRITE_RF_PATH_COMPENSATION_ENABLED) && !HCI_LE_WRITE_RF_PATH_COMPENSATION_FORCE_DISABLED
/* tBleStatus hci_le_write_rf_path_compensation(int16_t RF_TX_Path_Compensation_Value,
                                             int16_t RF_RX_Path_Compensation_Value);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_write_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_write_rf_path_compensation_cp0 *cp0 = (hci_le_write_rf_path_compensation_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_write_rf_path_compensation(cp0->RF_TX_Path_Compensation_Value /* 2 */,
                                              cp0->RF_RX_Path_Compensation_Value /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PRIVACY_MODE_ENABLED) || HCI_LE_SET_PRIVACY_MODE_ENABLED) && !HCI_LE_SET_PRIVACY_MODE_FORCE_DISABLED
/* tBleStatus hci_le_set_privacy_mode(uint8_t Peer_Identity_Address_Type,
                                   uint8_t Peer_Identity_Address[6],
                                   uint8_t Privacy_Mode);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_privacy_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_privacy_mode_cp0 *cp0 = (hci_le_set_privacy_mode_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_privacy_mode(cp0->Peer_Identity_Address_Type /* 1 */,
                                    cp0->Peer_Identity_Address /* 6 */,
                                    cp0->Privacy_Mode /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_RECEIVER_TEST_V3_ENABLED) || HCI_LE_RECEIVER_TEST_V3_ENABLED) && !HCI_LE_RECEIVER_TEST_V3_FORCE_DISABLED
/* tBleStatus hci_le_receiver_test_v3(uint8_t RX_Channel,
                                   uint8_t PHY,
                                   uint8_t Modulation_Index,
                                   uint8_t Expected_CTE_Length,
                                   uint8_t Expected_CTE_Type,
                                   uint8_t Slot_Durations,
                                   uint8_t Switching_Pattern_Length,
                                   uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_receiver_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_receiver_test_v3_cp0 *cp0 = (hci_le_receiver_test_v3_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_receiver_test_v3(cp0->RX_Channel /* 1 */,
                                    cp0->PHY /* 1 */,
                                    cp0->Modulation_Index /* 1 */,
                                    cp0->Expected_CTE_Length /* 1 */,
                                    cp0->Expected_CTE_Type /* 1 */,
                                    cp0->Slot_Durations /* 1 */,
                                    cp0->Switching_Pattern_Length /* 1 */,
                                    cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TRANSMITTER_TEST_V3_ENABLED) || HCI_LE_TRANSMITTER_TEST_V3_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V3_FORCE_DISABLED
/* tBleStatus hci_le_transmitter_test_v3(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_v3_cp0 *cp0 = (hci_le_transmitter_test_v3_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_transmitter_test_v3(cp0->TX_Channel /* 1 */,
                                       cp0->Test_Data_Length /* 1 */,
                                       cp0->Packet_Payload /* 1 */,
                                       cp0->PHY /* 1 */,
                                       cp0->CTE_Length /* 1 */,
                                       cp0->CTE_Type /* 1 */,
                                       cp0->Switching_Pattern_Length /* 1 */,
                                       cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x50;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_connectionless_cte_transmit_parameters(uint8_t Advertising_Handle,
                                                             uint8_t CTE_Length,
                                                             uint8_t CTE_Type,
                                                             uint8_t CTE_Count,
                                                             uint8_t Switching_Pattern_Length,
                                                             uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_connectionless_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_cte_transmit_parameters_cp0 *cp0 = (hci_le_set_connectionless_cte_transmit_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_set_connectionless_cte_transmit_parameters(cp0->Advertising_Handle /* 1 */,
                                                              cp0->CTE_Length /* 1 */,
                                                              cp0->CTE_Type /* 1 */,
                                                              cp0->CTE_Count /* 1 */,
                                                              cp0->Switching_Pattern_Length /* 1 */,
                                                              cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x51;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_ENABLED) || HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_connectionless_cte_transmit_enable(uint8_t Advertising_Handle,
                                                         uint8_t CTE_Enable);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_connectionless_cte_transmit_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_cte_transmit_enable_cp0 *cp0 = (hci_le_set_connectionless_cte_transmit_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_connectionless_cte_transmit_enable(cp0->Advertising_Handle /* 1 */,
                                                          cp0->CTE_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x52;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_ENABLED) || HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_ENABLED) && !HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_connectionless_iq_sampling_enable(uint16_t Sync_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Max_Sampled_CTEs,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connectionless_iq_sampling_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_iq_sampling_enable_cp0 *cp0 = (hci_le_set_connectionless_iq_sampling_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connectionless_iq_sampling_enable_rp0 *rp0 = (hci_le_set_connectionless_iq_sampling_enable_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_set_connectionless_iq_sampling_enable(cp0->Sync_Handle /* 2 */,
                                                             cp0->Sampling_Enable /* 1 */,
                                                             cp0->Slot_Durations /* 1 */,
                                                             cp0->Max_Sampled_CTEs /* 1 */,
                                                             cp0->Switching_Pattern_Length /* 1 */,
                                                             cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  rp0->Sync_Handle = cp0->Sync_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x53;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_connection_cte_receive_parameters(uint16_t Connection_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connection_cte_receive_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connection_cte_receive_parameters_cp0 *cp0 = (hci_le_set_connection_cte_receive_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connection_cte_receive_parameters_rp0 *rp0 = (hci_le_set_connection_cte_receive_parameters_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_set_connection_cte_receive_parameters(cp0->Connection_Handle /* 2 */,
                                                             cp0->Sampling_Enable /* 1 */,
                                                             cp0->Slot_Durations /* 1 */,
                                                             cp0->Switching_Pattern_Length /* 1 */,
                                                             cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x54;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_ENABLED) || HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_ENABLED) && !HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_connection_cte_transmit_parameters(uint16_t Connection_Handle,
                                                         uint8_t CTE_Type,
                                                         uint8_t Switching_Pattern_Length,
                                                         uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connection_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connection_cte_transmit_parameters_cp0 *cp0 = (hci_le_set_connection_cte_transmit_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connection_cte_transmit_parameters_rp0 *rp0 = (hci_le_set_connection_cte_transmit_parameters_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_set_connection_cte_transmit_parameters(cp0->Connection_Handle /* 2 */,
                                                              cp0->CTE_Type /* 1 */,
                                                              cp0->Switching_Pattern_Length /* 1 */,
                                                              cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x55;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_ENABLED) || HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_ENABLED) && !HCI_LE_CONNECTION_CTE_REQUEST_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_connection_cte_request_enable(uint16_t Connection_Handle,
                                                uint8_t Enable,
                                                uint16_t CTE_Request_Interval,
                                                uint8_t Requested_CTE_Length,
                                                uint8_t Requested_CTE_Type);
 */
/* Command len: 2 + 1 + 2 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_connection_cte_request_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_cte_request_enable_cp0 *cp0 = (hci_le_connection_cte_request_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_connection_cte_request_enable_rp0 *rp0 = (hci_le_connection_cte_request_enable_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_connection_cte_request_enable(cp0->Connection_Handle /* 2 */,
                                                     cp0->Enable /* 1 */,
                                                     cp0->CTE_Request_Interval /* 2 */,
                                                     cp0->Requested_CTE_Length /* 1 */,
                                                     cp0->Requested_CTE_Type /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x56;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_ENABLED) || HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_ENABLED) && !HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_connection_cte_response_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_connection_cte_response_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_cte_response_enable_cp0 *cp0 = (hci_le_connection_cte_response_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_connection_cte_response_enable_rp0 *rp0 = (hci_le_connection_cte_response_enable_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_connection_cte_response_enable(cp0->Connection_Handle /* 2 */,
                                                      cp0->Enable /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x57;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_ANTENNA_INFORMATION_ENABLED) || HCI_LE_READ_ANTENNA_INFORMATION_ENABLED) && !HCI_LE_READ_ANTENNA_INFORMATION_FORCE_DISABLED
/* tBleStatus hci_le_read_antenna_information(uint8_t *Supported_Switching_Sampling_Rates,
                                           uint8_t *Num_Antennae,
                                           uint8_t *Max_Switching_Pattern_Length,
                                           uint8_t *Max_CTE_Length);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 + 1 + 1 */
uint16_t hci_le_read_antenna_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1 + 1 + 1;
  /* Output params */
  hci_le_read_antenna_information_rp0 *rp0 = (hci_le_read_antenna_information_rp0 *) (buffer_out + 6);
  uint8_t Supported_Switching_Sampling_Rates = 0;
  uint8_t Num_Antennae = 0;
  uint8_t Max_Switching_Pattern_Length = 0;
  uint8_t Max_CTE_Length = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_antenna_information(&Supported_Switching_Sampling_Rates,
                                                &Num_Antennae,
                                                &Max_Switching_Pattern_Length,
                                                &Max_CTE_Length);
fail:
  rp0->Supported_Switching_Sampling_Rates = Supported_Switching_Sampling_Rates;
  rp0->Num_Antennae = Num_Antennae;
  rp0->Max_Switching_Pattern_Length = Max_Switching_Pattern_Length;
  rp0->Max_CTE_Length = Max_CTE_Length;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x58;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_receive_enable(uint16_t Sync_Handle,
                                                          uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_receive_enable_cp0 *cp0 = (hci_le_set_periodic_advertising_receive_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_receive_enable(cp0->Sync_Handle /* 2 */,
                                                           cp0->Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x59;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_FORCE_DISABLED
/* tBleStatus hci_le_periodic_advertising_sync_transfer(uint16_t Connection_Handle,
                                                     uint16_t Service_Data,
                                                     uint16_t Sync_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_sync_transfer_cp0 *cp0 = (hci_le_periodic_advertising_sync_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_periodic_advertising_sync_transfer_rp0 *rp0 = (hci_le_periodic_advertising_sync_transfer_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_periodic_advertising_sync_transfer(cp0->Connection_Handle /* 2 */,
                                                          cp0->Service_Data /* 2 */,
                                                          cp0->Sync_Handle /* 2 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_ENABLED) || HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_ENABLED) && !HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER_FORCE_DISABLED
/* tBleStatus hci_le_periodic_advertising_set_info_transfer(uint16_t Connection_Handle,
                                                         uint16_t Service_Data,
                                                         uint8_t Advertising_Handle);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_set_info_transfer_cp0 *cp0 = (hci_le_periodic_advertising_set_info_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_periodic_advertising_set_info_transfer_rp0 *rp0 = (hci_le_periodic_advertising_set_info_transfer_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_periodic_advertising_set_info_transfer(cp0->Connection_Handle /* 2 */,
                                                              cp0->Service_Data /* 2 */,
                                                              cp0->Advertising_Handle /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_sync_transfer_parameters(uint16_t Connection_Handle,
                                                                    uint8_t Mode,
                                                                    uint16_t Skip,
                                                                    uint16_t Sync_Timeout,
                                                                    uint8_t CTE_Type);
 */
/* Command len: 2 + 1 + 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_periodic_advertising_sync_transfer_parameters_rp0 *rp0 = (hci_le_set_periodic_advertising_sync_transfer_parameters_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_advertising_sync_transfer_parameters(cp0->Connection_Handle /* 2 */,
                                                                         cp0->Mode /* 1 */,
                                                                         cp0->Skip /* 2 */,
                                                                         cp0->Sync_Timeout /* 2 */,
                                                                         cp0->CTE_Type /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) || HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_ENABLED) && !HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_default_periodic_advertising_sync_transfer_parameters(uint8_t Mode,
                                                                            uint16_t Skip,
                                                                            uint16_t Sync_Timeout,
                                                                            uint8_t CTE_Type);
 */
/* Command len: 1 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_default_periodic_advertising_sync_transfer_parameters(cp0->Mode /* 1 */,
                                                                             cp0->Skip /* 2 */,
                                                                             cp0->Sync_Timeout /* 2 */,
                                                                             cp0->CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_BUFFER_SIZE_V2_ENABLED) || HCI_LE_READ_BUFFER_SIZE_V2_ENABLED) && !HCI_LE_READ_BUFFER_SIZE_V2_FORCE_DISABLED
/* tBleStatus hci_le_read_buffer_size_v2(uint16_t *HC_LE_ACL_Data_Packet_Length,
                                      uint8_t *HC_Total_Num_LE_ACL_Data_Packets,
                                      uint16_t *ISO_Data_Packet_Length,
                                      uint8_t *Total_Num_ISO_Data_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 1 + 2 + 1 */
uint16_t hci_le_read_buffer_size_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 1 + 2 + 1;
  /* Output params */
  hci_le_read_buffer_size_v2_rp0 *rp0 = (hci_le_read_buffer_size_v2_rp0 *) (buffer_out + 6);
  uint16_t HC_LE_ACL_Data_Packet_Length = 0;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets = 0;
  uint16_t ISO_Data_Packet_Length = 0;
  uint8_t Total_Num_ISO_Data_Packets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_buffer_size_v2(&HC_LE_ACL_Data_Packet_Length,
                                           &HC_Total_Num_LE_ACL_Data_Packets,
                                           &ISO_Data_Packet_Length,
                                           &Total_Num_ISO_Data_Packets);
fail:
  rp0->HC_LE_ACL_Data_Packet_Length = HC_LE_ACL_Data_Packet_Length;
  rp0->HC_Total_Num_LE_ACL_Data_Packets = HC_Total_Num_LE_ACL_Data_Packets;
  rp0->ISO_Data_Packet_Length = ISO_Data_Packet_Length;
  rp0->Total_Num_ISO_Data_Packets = Total_Num_ISO_Data_Packets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x60;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_ISO_TX_SYNC_ENABLED) || HCI_LE_READ_ISO_TX_SYNC_ENABLED) && !HCI_LE_READ_ISO_TX_SYNC_FORCE_DISABLED
/* tBleStatus hci_le_read_iso_tx_sync(uint16_t Connection_Handle,
                                   uint16_t *Packet_Sequence_Number,
                                   uint32_t *TX_Time_Stamp,
                                   uint8_t Time_Offset[3]);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 2 + 4 + 3 */
uint16_t hci_le_read_iso_tx_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_iso_tx_sync_cp0 *cp0 = (hci_le_read_iso_tx_sync_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 2 + 4 + 3;
  /* Output params */
  hci_le_read_iso_tx_sync_rp0 *rp0 = (hci_le_read_iso_tx_sync_rp0 *) (buffer_out + 6);
  uint16_t Packet_Sequence_Number = 0;
  uint32_t TX_Time_Stamp = 0;
  uint8_t Time_Offset[3] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 4 + 3 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_iso_tx_sync(cp0->Connection_Handle /* 2 */,
                                        &Packet_Sequence_Number,
                                        &TX_Time_Stamp,
                                        Time_Offset);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Packet_Sequence_Number = Packet_Sequence_Number;
  rp0->TX_Time_Stamp = TX_Time_Stamp;
  Osal_MemCpy((void *) rp0->Time_Offset,(const void *) Time_Offset, 3);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x61;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CIG_PARAMETERS_ENABLED) || HCI_LE_SET_CIG_PARAMETERS_ENABLED) && !HCI_LE_SET_CIG_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_cig_parameters(uint8_t CIG_ID,
                                     uint8_t SDU_Interval_C_To_P[3],
                                     uint8_t SDU_Interval_P_To_C[3],
                                     uint8_t Worst_Case_SCA,
                                     uint8_t Packing,
                                     uint8_t Framing,
                                     uint16_t Max_Transport_Latency_C_To_P,
                                     uint16_t Max_Transport_Latency_P_To_C,
                                     uint8_t CIS_Count,
                                     CIS_Param_t CIS_Param[],
                                     uint16_t Connection_Handle[]);
 */
/* Command len: 1 + 3 + 3 + 1 + 1 + 1 + 2 + 2 + 1 + struct_length */
/* Response len: 1 + 1 + 1 + rp0->CIS_Count * (sizeof(uint16_t)) */
uint16_t hci_le_set_cig_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_cig_parameters_cp0 *cp0 = (hci_le_set_cig_parameters_cp0 *)(buffer_in + (0));
  CIS_Param_t CIS_Param[HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Param_t)];

  int output_size = 0;
  /* Output params */
  hci_le_set_cig_parameters_rp0 *rp0 = (hci_le_set_cig_parameters_rp0 *) (buffer_out + 6);
  uint16_t Connection_Handle[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  int i;
  int struct_length = 0;
  if(cp0->CIS_Count > HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Param_t))
  {
    cp0->CIS_Count = 0;
    goto fail;
  }
  for (i = 0; i < cp0->CIS_Count; i++) {
    packed_CIS_Param_t *CIS_Param_tmp = (packed_CIS_Param_t *)(((uint8_t *)cp0->CIS_Param) + struct_length);
    CIS_Param[i].CIS_ID = CIS_Param_tmp->CIS_ID;
    struct_length += 1;
    CIS_Param[i].Max_SDU_C_To_P = CIS_Param_tmp->Max_SDU_C_To_P;
    struct_length += 2;
    CIS_Param[i].Max_SDU_P_To_C = CIS_Param_tmp->Max_SDU_P_To_C;
    struct_length += 2;
    CIS_Param[i].PHY_C_To_P = CIS_Param_tmp->PHY_C_To_P;
    struct_length += 1;
    CIS_Param[i].PHY_P_To_C = CIS_Param_tmp->PHY_P_To_C;
    struct_length += 1;
    CIS_Param[i].RTN_C_To_P = CIS_Param_tmp->RTN_C_To_P;
    struct_length += 1;
    CIS_Param[i].RTN_P_To_C = CIS_Param_tmp->RTN_P_To_C;
    struct_length += 1;
  }
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 3 + 3 + 1 + 1 + 1 + 2 + 2 + 1 + struct_length)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_cig_parameters(cp0->CIG_ID /* 1 */,
                                          cp0->SDU_Interval_C_To_P /* 3 */,
                                          cp0->SDU_Interval_P_To_C /* 3 */,
                                          cp0->Worst_Case_SCA /* 1 */,
                                          cp0->Packing /* 1 */,
                                          cp0->Framing /* 1 */,
                                          cp0->Max_Transport_Latency_C_To_P /* 2 */,
                                          cp0->Max_Transport_Latency_P_To_C /* 2 */,
                                          cp0->CIS_Count /* 1 */,
                                          CIS_Param /* struct_length */,
                                          Connection_Handle);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->CIG_ID = cp0->CIG_ID;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->CIS_Count = cp0->CIS_Count;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->CIS_Count * (sizeof(uint16_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Connection_Handle,(const void *) Connection_Handle, rp0->CIS_Count * (sizeof(uint16_t)));
  output_size += rp0->CIS_Count * (sizeof(uint16_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x62;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_CIG_PARAMETERS_TEST_ENABLED) || HCI_LE_SET_CIG_PARAMETERS_TEST_ENABLED) && !HCI_LE_SET_CIG_PARAMETERS_TEST_FORCE_DISABLED
/* tBleStatus hci_le_set_cig_parameters_test(uint8_t CIG_ID,
                                          uint8_t SDU_Interval_C_To_P[3],
                                          uint8_t SDU_Interval_P_To_C[3],
                                          uint8_t FT_C_To_P,
                                          uint8_t FT_P_To_C,
                                          uint16_t ISO_Interval,
                                          uint8_t Worst_Case_SCA,
                                          uint8_t Packing,
                                          uint8_t Framing,
                                          uint8_t CIS_Count,
                                          CIS_Param_Test_t CIS_Param_Test[],
                                          uint16_t Connection_Handle[]);
 */
/* Command len: 1 + 3 + 3 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + struct_length */
/* Response len: 1 + 1 + 1 + rp0->CIS_Count * (sizeof(uint16_t)) */
uint16_t hci_le_set_cig_parameters_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_cig_parameters_test_cp0 *cp0 = (hci_le_set_cig_parameters_test_cp0 *)(buffer_in + (0));
  CIS_Param_Test_t CIS_Param_Test[HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Param_Test_t)];

  int output_size = 0;
  /* Output params */
  hci_le_set_cig_parameters_test_rp0 *rp0 = (hci_le_set_cig_parameters_test_rp0 *) (buffer_out + 6);
  uint16_t Connection_Handle[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  int i;
  int struct_length = 0;
  if(cp0->CIS_Count > HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Param_Test_t))
  {
    cp0->CIS_Count = 0;
    goto fail;
  }
  for (i = 0; i < cp0->CIS_Count; i++) {
    packed_CIS_Param_Test_t *CIS_Param_Test_tmp = (packed_CIS_Param_Test_t *)(((uint8_t *)cp0->CIS_Param_Test) + struct_length);
    CIS_Param_Test[i].CIS_ID = CIS_Param_Test_tmp->CIS_ID;
    struct_length += 1;
    CIS_Param_Test[i].NSE = CIS_Param_Test_tmp->NSE;
    struct_length += 1;
    CIS_Param_Test[i].Max_SDU_C_To_P = CIS_Param_Test_tmp->Max_SDU_C_To_P;
    struct_length += 2;
    CIS_Param_Test[i].Max_SDU_P_To_C = CIS_Param_Test_tmp->Max_SDU_P_To_C;
    struct_length += 2;
    CIS_Param_Test[i].Max_PDU_C_To_P = CIS_Param_Test_tmp->Max_PDU_C_To_P;
    struct_length += 2;
    CIS_Param_Test[i].Max_PDU_P_To_C = CIS_Param_Test_tmp->Max_PDU_P_To_C;
    struct_length += 2;
    CIS_Param_Test[i].PHY_C_To_P = CIS_Param_Test_tmp->PHY_C_To_P;
    struct_length += 1;
    CIS_Param_Test[i].PHY_P_To_C = CIS_Param_Test_tmp->PHY_P_To_C;
    struct_length += 1;
    CIS_Param_Test[i].BN_C_To_P = CIS_Param_Test_tmp->BN_C_To_P;
    struct_length += 1;
    CIS_Param_Test[i].BN_P_To_C = CIS_Param_Test_tmp->BN_P_To_C;
    struct_length += 1;
  }
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 3 + 3 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + struct_length)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_cig_parameters_test(cp0->CIG_ID /* 1 */,
                                               cp0->SDU_Interval_C_To_P /* 3 */,
                                               cp0->SDU_Interval_P_To_C /* 3 */,
                                               cp0->FT_C_To_P /* 1 */,
                                               cp0->FT_P_To_C /* 1 */,
                                               cp0->ISO_Interval /* 2 */,
                                               cp0->Worst_Case_SCA /* 1 */,
                                               cp0->Packing /* 1 */,
                                               cp0->Framing /* 1 */,
                                               cp0->CIS_Count /* 1 */,
                                               CIS_Param_Test /* struct_length */,
                                               Connection_Handle);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->CIG_ID = cp0->CIG_ID;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->CIS_Count = cp0->CIS_Count;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->CIS_Count * (sizeof(uint16_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Connection_Handle,(const void *) Connection_Handle, rp0->CIS_Count * (sizeof(uint16_t)));
  output_size += rp0->CIS_Count * (sizeof(uint16_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x63;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CREATE_CIS_ENABLED) || HCI_LE_CREATE_CIS_ENABLED) && !HCI_LE_CREATE_CIS_FORCE_DISABLED
/* tBleStatus hci_le_create_cis(uint8_t CIS_Count,
                             CIS_Handles_t CIS_Handles[]);
 */
/* Command len: 1 + struct_length */
/* Response len: 1 */
uint16_t hci_le_create_cis_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_create_cis_cp0 *cp0 = (hci_le_create_cis_cp0 *)(buffer_in + (0));
  CIS_Handles_t CIS_Handles[HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Handles_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->CIS_Count > HCI_MAX_PAYLOAD_SIZE/sizeof(CIS_Handles_t))
  {
    cp0->CIS_Count = 0;
    goto fail;
  }
  for (i = 0; i < cp0->CIS_Count; i++) {
    packed_CIS_Handles_t *CIS_Handles_tmp = (packed_CIS_Handles_t *)(((uint8_t *)cp0->CIS_Handles) + struct_length);
    CIS_Handles[i].CIS_Connection_Handle = CIS_Handles_tmp->CIS_Connection_Handle;
    struct_length += 2;
    CIS_Handles[i].ACL_Connection_Handle = CIS_Handles_tmp->ACL_Connection_Handle;
    struct_length += 2;
  }
  if(buffer_in_length != 1 + struct_length)
  {
    goto fail;
  }

  *status = hci_le_create_cis(cp0->CIS_Count /* 1 */,
                              CIS_Handles /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x64;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_CIG_ENABLED) || HCI_LE_REMOVE_CIG_ENABLED) && !HCI_LE_REMOVE_CIG_FORCE_DISABLED
/* tBleStatus hci_le_remove_cig(uint8_t CIG_ID);
 */
/* Command len: 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_remove_cig_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_cig_cp0 *cp0 = (hci_le_remove_cig_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_remove_cig_rp0 *rp0 = (hci_le_remove_cig_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_remove_cig(cp0->CIG_ID /* 1 */);
fail:
  rp0->CIG_ID = cp0->CIG_ID;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x65;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ACCEPT_CIS_REQUEST_ENABLED) || HCI_LE_ACCEPT_CIS_REQUEST_ENABLED) && !HCI_LE_ACCEPT_CIS_REQUEST_FORCE_DISABLED
/* tBleStatus hci_le_accept_cis_request(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_accept_cis_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_accept_cis_request_cp0 *cp0 = (hci_le_accept_cis_request_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_le_accept_cis_request(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x66;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REJECT_CIS_REQUEST_ENABLED) || HCI_LE_REJECT_CIS_REQUEST_ENABLED) && !HCI_LE_REJECT_CIS_REQUEST_FORCE_DISABLED
/* tBleStatus hci_le_reject_cis_request(uint16_t Connection_Handle,
                                     uint8_t Reason);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_reject_cis_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_reject_cis_request_cp0 *cp0 = (hci_le_reject_cis_request_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_reject_cis_request_rp0 *rp0 = (hci_le_reject_cis_request_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_reject_cis_request(cp0->Connection_Handle /* 2 */,
                                          cp0->Reason /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x67;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CREATE_BIG_ENABLED) || HCI_LE_CREATE_BIG_ENABLED) && !HCI_LE_CREATE_BIG_FORCE_DISABLED
/* tBleStatus hci_le_create_big(uint8_t BIG_Handle,
                             uint8_t Advertising_Handle,
                             uint8_t Num_BIS,
                             uint8_t SDU_Interval[3],
                             uint16_t Max_SDU,
                             uint16_t Max_Transport_Latency,
                             uint8_t RTN,
                             uint8_t PHY,
                             uint8_t Packing,
                             uint8_t Framing,
                             uint8_t Encryption,
                             uint8_t Broadcast_Code[16]);
 */
/* Command len: 1 + 1 + 1 + 3 + 2 + 2 + 1 + 1 + 1 + 1 + 1 + 16 */
/* Response len: 1 */
uint16_t hci_le_create_big_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_create_big_cp0 *cp0 = (hci_le_create_big_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 3 + 2 + 2 + 1 + 1 + 1 + 1 + 1 + 16)
  {
    goto fail;
  }

  *status = hci_le_create_big(cp0->BIG_Handle /* 1 */,
                              cp0->Advertising_Handle /* 1 */,
                              cp0->Num_BIS /* 1 */,
                              cp0->SDU_Interval /* 3 */,
                              cp0->Max_SDU /* 2 */,
                              cp0->Max_Transport_Latency /* 2 */,
                              cp0->RTN /* 1 */,
                              cp0->PHY /* 1 */,
                              cp0->Packing /* 1 */,
                              cp0->Framing /* 1 */,
                              cp0->Encryption /* 1 */,
                              cp0->Broadcast_Code /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x68;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_CREATE_BIG_TEST_ENABLED) || HCI_LE_CREATE_BIG_TEST_ENABLED) && !HCI_LE_CREATE_BIG_TEST_FORCE_DISABLED
/* tBleStatus hci_le_create_big_test(uint8_t BIG_Handle,
                                  uint8_t Advertising_Handle,
                                  uint8_t Num_BIS,
                                  uint8_t SDU_Interval[3],
                                  uint16_t ISO_Interval,
                                  uint8_t NSE,
                                  uint16_t Max_SDU,
                                  uint16_t Max_PDU,
                                  uint8_t PHY,
                                  uint8_t Packing,
                                  uint8_t Framing,
                                  uint8_t BN,
                                  uint8_t IRC,
                                  uint8_t PTO,
                                  uint8_t Encryption,
                                  uint8_t Broadcast_Code[16]);
 */
/* Command len: 1 + 1 + 1 + 3 + 2 + 1 + 2 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 */
/* Response len: 1 */
uint16_t hci_le_create_big_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_create_big_test_cp0 *cp0 = (hci_le_create_big_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 3 + 2 + 1 + 2 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16)
  {
    goto fail;
  }

  *status = hci_le_create_big_test(cp0->BIG_Handle /* 1 */,
                                   cp0->Advertising_Handle /* 1 */,
                                   cp0->Num_BIS /* 1 */,
                                   cp0->SDU_Interval /* 3 */,
                                   cp0->ISO_Interval /* 2 */,
                                   cp0->NSE /* 1 */,
                                   cp0->Max_SDU /* 2 */,
                                   cp0->Max_PDU /* 2 */,
                                   cp0->PHY /* 1 */,
                                   cp0->Packing /* 1 */,
                                   cp0->Framing /* 1 */,
                                   cp0->BN /* 1 */,
                                   cp0->IRC /* 1 */,
                                   cp0->PTO /* 1 */,
                                   cp0->Encryption /* 1 */,
                                   cp0->Broadcast_Code /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x69;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TERMINATE_BIG_ENABLED) || HCI_LE_TERMINATE_BIG_ENABLED) && !HCI_LE_TERMINATE_BIG_FORCE_DISABLED
/* tBleStatus hci_le_terminate_big(uint8_t BIG_Handle,
                                uint8_t Reason);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_terminate_big_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_terminate_big_cp0 *cp0 = (hci_le_terminate_big_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_terminate_big(cp0->BIG_Handle /* 1 */,
                                 cp0->Reason /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x6a;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_BIG_CREATE_SYNC_ENABLED) || HCI_LE_BIG_CREATE_SYNC_ENABLED) && !HCI_LE_BIG_CREATE_SYNC_FORCE_DISABLED
/* tBleStatus hci_le_big_create_sync(uint8_t BIG_Handle,
                                  uint16_t Sync_Handle,
                                  uint8_t Encryption,
                                  uint8_t Broadcast_Code[16],
                                  uint8_t MSE,
                                  uint16_t BIG_Sync_Timeout,
                                  uint8_t Num_BIS,
                                  uint8_t BIS[]);
 */
/* Command len: 1 + 2 + 1 + 16 + 1 + 2 + 1 + cp0->Num_BIS * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_big_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_big_create_sync_cp0 *cp0 = (hci_le_big_create_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 1 + 16 + 1 + 2 + 1 + cp0->Num_BIS * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = hci_le_big_create_sync(cp0->BIG_Handle /* 1 */,
                                   cp0->Sync_Handle /* 2 */,
                                   cp0->Encryption /* 1 */,
                                   cp0->Broadcast_Code /* 16 */,
                                   cp0->MSE /* 1 */,
                                   cp0->BIG_Sync_Timeout /* 2 */,
                                   cp0->Num_BIS /* 1 */,
                                   cp0->BIS /* cp0->Num_BIS * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x6b;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_BIG_TERMINATE_SYNC_ENABLED) || HCI_LE_BIG_TERMINATE_SYNC_ENABLED) && !HCI_LE_BIG_TERMINATE_SYNC_FORCE_DISABLED
/* tBleStatus hci_le_big_terminate_sync(uint8_t BIG_Handle);
 */
/* Command len: 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_big_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_big_terminate_sync_cp0 *cp0 = (hci_le_big_terminate_sync_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_big_terminate_sync_rp0 *rp0 = (hci_le_big_terminate_sync_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_big_terminate_sync(cp0->BIG_Handle /* 1 */);
fail:
  rp0->BIG_Handle = cp0->BIG_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x6c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REQUEST_PEER_SCA_ENABLED) || HCI_LE_REQUEST_PEER_SCA_ENABLED) && !HCI_LE_REQUEST_PEER_SCA_FORCE_DISABLED
/* tBleStatus hci_le_request_peer_sca(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_request_peer_sca_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_request_peer_sca_cp0 *cp0 = (hci_le_request_peer_sca_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = hci_le_request_peer_sca(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x6d;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SETUP_ISO_DATA_PATH_ENABLED) || HCI_LE_SETUP_ISO_DATA_PATH_ENABLED) && !HCI_LE_SETUP_ISO_DATA_PATH_FORCE_DISABLED
/* tBleStatus hci_le_setup_iso_data_path(uint16_t Connection_Handle,
                                      uint8_t Data_Path_Direction,
                                      uint8_t Data_Path_ID,
                                      uint8_t Codec_ID[5],
                                      uint8_t Controller_Delay[3],
                                      uint8_t Codec_Configuration_Length,
                                      uint8_t Codec_Configuration[]);
 */
/* Command len: 2 + 1 + 1 + 5 + 3 + 1 + cp0->Codec_Configuration_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_setup_iso_data_path_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_setup_iso_data_path_cp0 *cp0 = (hci_le_setup_iso_data_path_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_setup_iso_data_path_rp0 *rp0 = (hci_le_setup_iso_data_path_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 5 + 3 + 1 + cp0->Codec_Configuration_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_setup_iso_data_path(cp0->Connection_Handle /* 2 */,
                                           cp0->Data_Path_Direction /* 1 */,
                                           cp0->Data_Path_ID /* 1 */,
                                           cp0->Codec_ID /* 5 */,
                                           cp0->Controller_Delay /* 3 */,
                                           cp0->Codec_Configuration_Length /* 1 */,
                                           cp0->Codec_Configuration /* cp0->Codec_Configuration_Length * (sizeof(uint8_t)) */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x6e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_REMOVE_ISO_DATA_PATH_ENABLED) || HCI_LE_REMOVE_ISO_DATA_PATH_ENABLED) && !HCI_LE_REMOVE_ISO_DATA_PATH_FORCE_DISABLED
/* tBleStatus hci_le_remove_iso_data_path(uint16_t Connection_Handle,
                                       uint8_t Data_Path_Direction);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_remove_iso_data_path_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_iso_data_path_cp0 *cp0 = (hci_le_remove_iso_data_path_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_remove_iso_data_path_rp0 *rp0 = (hci_le_remove_iso_data_path_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_remove_iso_data_path(cp0->Connection_Handle /* 2 */,
                                            cp0->Data_Path_Direction /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x6f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ISO_TRANSMIT_TEST_ENABLED) || HCI_LE_ISO_TRANSMIT_TEST_ENABLED) && !HCI_LE_ISO_TRANSMIT_TEST_FORCE_DISABLED
/* tBleStatus hci_le_iso_transmit_test(uint16_t Connection_Handle,
                                    uint8_t Payload_Type);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_iso_transmit_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_iso_transmit_test_cp0 *cp0 = (hci_le_iso_transmit_test_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_iso_transmit_test_rp0 *rp0 = (hci_le_iso_transmit_test_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_iso_transmit_test(cp0->Connection_Handle /* 2 */,
                                         cp0->Payload_Type /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x70;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ISO_RECEIVE_TEST_ENABLED) || HCI_LE_ISO_RECEIVE_TEST_ENABLED) && !HCI_LE_ISO_RECEIVE_TEST_FORCE_DISABLED
/* tBleStatus hci_le_iso_receive_test(uint16_t Connection_Handle,
                                   uint8_t Payload_Type);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_iso_receive_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_iso_receive_test_cp0 *cp0 = (hci_le_iso_receive_test_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_iso_receive_test_rp0 *rp0 = (hci_le_iso_receive_test_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_iso_receive_test(cp0->Connection_Handle /* 2 */,
                                        cp0->Payload_Type /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x71;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ISO_READ_TEST_COUNTERS_ENABLED) || HCI_LE_ISO_READ_TEST_COUNTERS_ENABLED) && !HCI_LE_ISO_READ_TEST_COUNTERS_FORCE_DISABLED
/* tBleStatus hci_le_iso_read_test_counters(uint16_t Connection_Handle,
                                         uint32_t *Received_Packet_Count,
                                         uint32_t *Missed_Packet_Count,
                                         uint32_t *Failed_Packet_Count);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 4 + 4 + 4 */
uint16_t hci_le_iso_read_test_counters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_iso_read_test_counters_cp0 *cp0 = (hci_le_iso_read_test_counters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 4 + 4 + 4;
  /* Output params */
  hci_le_iso_read_test_counters_rp0 *rp0 = (hci_le_iso_read_test_counters_rp0 *) (buffer_out + 6);
  uint32_t Received_Packet_Count = 0;
  uint32_t Missed_Packet_Count = 0;
  uint32_t Failed_Packet_Count = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 4 + 4 + 4 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_iso_read_test_counters(cp0->Connection_Handle /* 2 */,
                                              &Received_Packet_Count,
                                              &Missed_Packet_Count,
                                              &Failed_Packet_Count);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Received_Packet_Count = Received_Packet_Count;
  rp0->Missed_Packet_Count = Missed_Packet_Count;
  rp0->Failed_Packet_Count = Failed_Packet_Count;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x72;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ISO_TEST_END_ENABLED) || HCI_LE_ISO_TEST_END_ENABLED) && !HCI_LE_ISO_TEST_END_FORCE_DISABLED
/* tBleStatus hci_le_iso_test_end(uint16_t Connection_Handle,
                               uint32_t *Received_Packet_Count,
                               uint32_t *Missed_Packet_Count,
                               uint32_t *Failed_Packet_Count);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 4 + 4 + 4 */
uint16_t hci_le_iso_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_iso_test_end_cp0 *cp0 = (hci_le_iso_test_end_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 4 + 4 + 4;
  /* Output params */
  hci_le_iso_test_end_rp0 *rp0 = (hci_le_iso_test_end_rp0 *) (buffer_out + 6);
  uint32_t Received_Packet_Count = 0;
  uint32_t Missed_Packet_Count = 0;
  uint32_t Failed_Packet_Count = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 4 + 4 + 4 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_iso_test_end(cp0->Connection_Handle /* 2 */,
                                    &Received_Packet_Count,
                                    &Missed_Packet_Count,
                                    &Failed_Packet_Count);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Received_Packet_Count = Received_Packet_Count;
  rp0->Missed_Packet_Count = Missed_Packet_Count;
  rp0->Failed_Packet_Count = Failed_Packet_Count;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x73;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_HOST_FEATURE_ENABLED) || HCI_LE_SET_HOST_FEATURE_ENABLED) && !HCI_LE_SET_HOST_FEATURE_FORCE_DISABLED
/* tBleStatus hci_le_set_host_feature(uint8_t Bit_Number,
                                   uint8_t Bit_Value);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_host_feature_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_host_feature_cp0 *cp0 = (hci_le_set_host_feature_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_host_feature(cp0->Bit_Number /* 1 */,
                                    cp0->Bit_Value /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x74;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_ISO_LINK_QUALITY_ENABLED) || HCI_LE_READ_ISO_LINK_QUALITY_ENABLED) && !HCI_LE_READ_ISO_LINK_QUALITY_FORCE_DISABLED
/* tBleStatus hci_le_read_iso_link_quality(uint16_t Connection_Handle,
                                        uint32_t *Tx_UnACKed_Packets,
                                        uint32_t *Tx_Flushed_Packets,
                                        uint32_t *Tx_Last_Subevent_Packets,
                                        uint32_t *Retransmitted_Packets,
                                        uint32_t *CRC_Error_Packets,
                                        uint32_t *Rx_Unreceived_Packets,
                                        uint32_t *Duplicate_Packets);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 */
uint16_t hci_le_read_iso_link_quality_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_iso_link_quality_cp0 *cp0 = (hci_le_read_iso_link_quality_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
  /* Output params */
  hci_le_read_iso_link_quality_rp0 *rp0 = (hci_le_read_iso_link_quality_rp0 *) (buffer_out + 6);
  uint32_t Tx_UnACKed_Packets = 0;
  uint32_t Tx_Flushed_Packets = 0;
  uint32_t Tx_Last_Subevent_Packets = 0;
  uint32_t Retransmitted_Packets = 0;
  uint32_t CRC_Error_Packets = 0;
  uint32_t Rx_Unreceived_Packets = 0;
  uint32_t Duplicate_Packets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_read_iso_link_quality(cp0->Connection_Handle /* 2 */,
                                             &Tx_UnACKed_Packets,
                                             &Tx_Flushed_Packets,
                                             &Tx_Last_Subevent_Packets,
                                             &Retransmitted_Packets,
                                             &CRC_Error_Packets,
                                             &Rx_Unreceived_Packets,
                                             &Duplicate_Packets);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Tx_UnACKed_Packets = Tx_UnACKed_Packets;
  rp0->Tx_Flushed_Packets = Tx_Flushed_Packets;
  rp0->Tx_Last_Subevent_Packets = Tx_Last_Subevent_Packets;
  rp0->Retransmitted_Packets = Retransmitted_Packets;
  rp0->CRC_Error_Packets = CRC_Error_Packets;
  rp0->Rx_Unreceived_Packets = Rx_Unreceived_Packets;
  rp0->Duplicate_Packets = Duplicate_Packets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x75;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
/* tBleStatus hci_le_enhanced_read_transmit_power_level(uint16_t Connection_Handle,
                                                     uint8_t PHY,
                                                     int8_t *Current_Transmit_Power_Level,
                                                     int8_t *Max_Transmit_Power_Level);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 1 + 1 + 1 */
uint16_t hci_le_enhanced_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_enhanced_read_transmit_power_level_cp0 *cp0 = (hci_le_enhanced_read_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1 + 1 + 1;
  /* Output params */
  hci_le_enhanced_read_transmit_power_level_rp0 *rp0 = (hci_le_enhanced_read_transmit_power_level_rp0 *) (buffer_out + 6);
  int8_t Current_Transmit_Power_Level = 0;
  int8_t Max_Transmit_Power_Level = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_enhanced_read_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                                          cp0->PHY /* 1 */,
                                                          &Current_Transmit_Power_Level,
                                                          &Max_Transmit_Power_Level);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->PHY = cp0->PHY;
  rp0->Current_Transmit_Power_Level = Current_Transmit_Power_Level;
  rp0->Max_Transmit_Power_Level = Max_Transmit_Power_Level;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x76;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_ENABLED) || HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_ENABLED) && !HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL_FORCE_DISABLED
/* tBleStatus hci_le_read_remote_transmit_power_level(uint16_t Connection_Handle,
                                                   uint8_t PHY);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_read_remote_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_remote_transmit_power_level_cp0 *cp0 = (hci_le_read_remote_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = hci_le_read_remote_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                                    cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x77;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_ENABLED) || HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_ENABLED) && !HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS_FORCE_DISABLED
/* tBleStatus hci_le_set_path_loss_reporting_parameters(uint16_t Connection_Handle,
                                                     uint8_t High_Threshold,
                                                     uint8_t High_Hysteresis,
                                                     uint8_t Low_Threshold,
                                                     uint8_t Low_Hysteresis,
                                                     uint16_t Min_Time_Spent);
 */
/* Command len: 2 + 1 + 1 + 1 + 1 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_path_loss_reporting_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_path_loss_reporting_parameters_cp0 *cp0 = (hci_le_set_path_loss_reporting_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_path_loss_reporting_parameters_rp0 *rp0 = (hci_le_set_path_loss_reporting_parameters_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 1 + 2)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_path_loss_reporting_parameters(cp0->Connection_Handle /* 2 */,
                                                          cp0->High_Threshold /* 1 */,
                                                          cp0->High_Hysteresis /* 1 */,
                                                          cp0->Low_Threshold /* 1 */,
                                                          cp0->Low_Hysteresis /* 1 */,
                                                          cp0->Min_Time_Spent /* 2 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x78;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_ENABLED) || HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_ENABLED) && !HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_path_loss_reporting_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_path_loss_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_path_loss_reporting_enable_cp0 *cp0 = (hci_le_set_path_loss_reporting_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_path_loss_reporting_enable_rp0 *rp0 = (hci_le_set_path_loss_reporting_enable_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_path_loss_reporting_enable(cp0->Connection_Handle /* 2 */,
                                                      cp0->Enable /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x79;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_ENABLED) || HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_ENABLED) && !HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE_FORCE_DISABLED
/* tBleStatus hci_le_set_transmit_power_reporting_enable(uint16_t Connection_Handle,
                                                      uint8_t Local_Enable,
                                                      uint8_t Remote_Enable);
 */
/* Command len: 2 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_transmit_power_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_transmit_power_reporting_enable_cp0 *cp0 = (hci_le_set_transmit_power_reporting_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_transmit_power_reporting_enable_rp0 *rp0 = (hci_le_set_transmit_power_reporting_enable_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_transmit_power_reporting_enable(cp0->Connection_Handle /* 2 */,
                                                           cp0->Local_Enable /* 1 */,
                                                           cp0->Remote_Enable /* 1 */);
fail:
  rp0->Connection_Handle = cp0->Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_TRANSMITTER_TEST_V4_ENABLED) || HCI_LE_TRANSMITTER_TEST_V4_ENABLED) && !HCI_LE_TRANSMITTER_TEST_V4_FORCE_DISABLED
/* tBleStatus hci_le_transmitter_test_v4(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[],
                                      int8_t Transmit_Power_Level);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) + 1 */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_v4_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_v4_cp0 *cp0 = (hci_le_transmitter_test_v4_cp0 *)(buffer_in + (0));
  hci_le_transmitter_test_v4_cp1 *cp1 = (hci_le_transmitter_test_v4_cp1 *)(buffer_in + (0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t))));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) + 1)
  {
    goto fail;
  }

  *status = hci_le_transmitter_test_v4(cp0->TX_Channel /* 1 */,
                                       cp0->Test_Data_Length /* 1 */,
                                       cp0->Packet_Payload /* 1 */,
                                       cp0->PHY /* 1 */,
                                       cp0->CTE_Length /* 1 */,
                                       cp0->CTE_Type /* 1 */,
                                       cp0->Switching_Pattern_Length /* 1 */,
                                       cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */,
                                       cp1->Transmit_Power_Level /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_ENABLED) || HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_ENABLED) && !HCI_LE_SET_DATA_RELATED_ADDRESS_CHANGES_FORCE_DISABLED
/* tBleStatus hci_le_set_data_related_address_changes(uint8_t Advertising_Handle,
                                                   uint8_t Change_Reasons);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_data_related_address_changes_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_data_related_address_changes_cp0 *cp0 = (hci_le_set_data_related_address_changes_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = hci_le_set_data_related_address_changes(cp0->Advertising_Handle /* 1 */,
                                                    cp0->Change_Reasons /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_DEFAULT_SUBRATE_ENABLED) || HCI_LE_SET_DEFAULT_SUBRATE_ENABLED) && !HCI_LE_SET_DEFAULT_SUBRATE_FORCE_DISABLED
/* tBleStatus hci_le_set_default_subrate(uint16_t Subrate_Min,
                                      uint16_t Subrate_Max,
                                      uint16_t Max_Latency,
                                      uint16_t Continuation_Number,
                                      uint16_t Supervision_Timeout);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_default_subrate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_default_subrate_cp0 *cp0 = (hci_le_set_default_subrate_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_set_default_subrate(cp0->Subrate_Min /* 2 */,
                                       cp0->Subrate_Max /* 2 */,
                                       cp0->Max_Latency /* 2 */,
                                       cp0->Continuation_Number /* 2 */,
                                       cp0->Supervision_Timeout /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SUBRATE_REQUEST_ENABLED) || HCI_LE_SUBRATE_REQUEST_ENABLED) && !HCI_LE_SUBRATE_REQUEST_FORCE_DISABLED
/* tBleStatus hci_le_subrate_request(uint16_t Connection_Handle,
                                  uint16_t Subrate_Min,
                                  uint16_t Subrate_Max,
                                  uint16_t Max_Latency,
                                  uint16_t Continuation_Number,
                                  uint16_t Supervision_Timeout);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_subrate_request_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_subrate_request_cp0 *cp0 = (hci_le_subrate_request_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = hci_le_subrate_request(cp0->Connection_Handle /* 2 */,
                                   cp0->Subrate_Min /* 2 */,
                                   cp0->Subrate_Max /* 2 */,
                                   cp0->Max_Latency /* 2 */,
                                   cp0->Continuation_Number /* 2 */,
                                   cp0->Supervision_Timeout /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x7e;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_ENABLED) || HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_ENABLED) && !HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2_FORCE_DISABLED
/* tBleStatus hci_le_set_extended_advertising_parameters_v2(uint8_t Advertising_Handle,
                                                         uint16_t Advertising_Event_Properties,
                                                         uint8_t Primary_Advertising_Interval_Min[3],
                                                         uint8_t Primary_Advertising_Interval_Max[3],
                                                         uint8_t Primary_Advertising_Channel_Map,
                                                         uint8_t Own_Address_Type,
                                                         uint8_t Peer_Address_Type,
                                                         uint8_t Peer_Address[6],
                                                         uint8_t Advertising_Filter_Policy,
                                                         int8_t Advertising_Tx_Power,
                                                         uint8_t Primary_Advertising_PHY,
                                                         uint8_t Secondary_Advertising_Max_Skip,
                                                         uint8_t Secondary_Advertising_PHY,
                                                         uint8_t Advertising_SID,
                                                         uint8_t Scan_Request_Notification_Enable,
                                                         uint8_t Primary_Advertising_PHY_Options,
                                                         uint8_t Secondary_Advertising_PHY_Options,
                                                         int8_t *Selected_Tx_Power);
 */
/* Command len: 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_set_extended_advertising_parameters_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_parameters_v2_cp0 *cp0 = (hci_le_set_extended_advertising_parameters_v2_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_set_extended_advertising_parameters_v2_rp0 *rp0 = (hci_le_set_extended_advertising_parameters_v2_rp0 *) (buffer_out + 6);
  int8_t Selected_Tx_Power = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_extended_advertising_parameters_v2(cp0->Advertising_Handle /* 1 */,
                                                              cp0->Advertising_Event_Properties /* 2 */,
                                                              cp0->Primary_Advertising_Interval_Min /* 3 */,
                                                              cp0->Primary_Advertising_Interval_Max /* 3 */,
                                                              cp0->Primary_Advertising_Channel_Map /* 1 */,
                                                              cp0->Own_Address_Type /* 1 */,
                                                              cp0->Peer_Address_Type /* 1 */,
                                                              cp0->Peer_Address /* 6 */,
                                                              cp0->Advertising_Filter_Policy /* 1 */,
                                                              cp0->Advertising_Tx_Power /* 1 */,
                                                              cp0->Primary_Advertising_PHY /* 1 */,
                                                              cp0->Secondary_Advertising_Max_Skip /* 1 */,
                                                              cp0->Secondary_Advertising_PHY /* 1 */,
                                                              cp0->Advertising_SID /* 1 */,
                                                              cp0->Scan_Request_Notification_Enable /* 1 */,
                                                              cp0->Primary_Advertising_PHY_Options /* 1 */,
                                                              cp0->Secondary_Advertising_PHY_Options /* 1 */,
                                                              &Selected_Tx_Power);
fail:
  rp0->Selected_Tx_Power = Selected_Tx_Power;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_subevent_data(uint8_t Advertising_Handle,
                                                         uint8_t Num_Subevents,
                                                         Subevent_Data_Parameters_t Subevent_Data_Parameters[]);
 */
/* Command len: 1 + 1 + struct_length */
/* Response len: 1 + 1 */
uint16_t hci_le_set_periodic_advertising_subevent_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_subevent_data_cp0 *cp0 = (hci_le_set_periodic_advertising_subevent_data_cp0 *)(buffer_in + (0));
  Subevent_Data_Parameters_t Subevent_Data_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Subevent_Data_Parameters_t)];

  int output_size = 1 + 1;
  /* Output params */
  hci_le_set_periodic_advertising_subevent_data_rp0 *rp0 = (hci_le_set_periodic_advertising_subevent_data_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->Num_Subevents > HCI_MAX_PAYLOAD_SIZE/sizeof(Subevent_Data_Parameters_t))
  {
    cp0->Num_Subevents = 0;
    goto fail;
  }
  for (i = 0; i < cp0->Num_Subevents; i++) {
    packed_Subevent_Data_Parameters_t *Subevent_Data_Parameters_tmp = (packed_Subevent_Data_Parameters_t *)(((uint8_t *)cp0->Subevent_Data_Parameters) + struct_length);
    Subevent_Data_Parameters[i].Subevent = Subevent_Data_Parameters_tmp->Subevent;
    struct_length += 1;
    Subevent_Data_Parameters[i].Response_Slot_Start = Subevent_Data_Parameters_tmp->Response_Slot_Start;
    struct_length += 1;
    Subevent_Data_Parameters[i].Response_Slot_Count = Subevent_Data_Parameters_tmp->Response_Slot_Count;
    struct_length += 1;
    Subevent_Data_Parameters[i].Subevent_Data_Length = Subevent_Data_Parameters_tmp->Subevent_Data_Length;
    struct_length += 1;
    Subevent_Data_Parameters[i].Subevent_Data = Subevent_Data_Parameters_tmp->Subevent_Data;
    struct_length += Subevent_Data_Parameters_tmp->Subevent_Data_Length;
  }
  if(buffer_in_length != 1 + 1 + struct_length)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_advertising_subevent_data(cp0->Advertising_Handle /* 1 */,
                                                              cp0->Num_Subevents /* 1 */,
                                                              Subevent_Data_Parameters /* struct_length */);
fail:
  rp0->Advertising_Handle = cp0->Advertising_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x82;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_response_data(uint16_t Sync_Handle,
                                                         uint16_t Request_Event,
                                                         uint8_t Request_Subevent,
                                                         uint8_t Response_Subevent,
                                                         uint8_t Response_Slot,
                                                         uint8_t Response_Data_Length,
                                                         uint8_t Response_Data[]);
 */
/* Command len: 2 + 2 + 1 + 1 + 1 + 1 + cp0->Response_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_periodic_advertising_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_response_data_cp0 *cp0 = (hci_le_set_periodic_advertising_response_data_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_periodic_advertising_response_data_rp0 *rp0 = (hci_le_set_periodic_advertising_response_data_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 1 + 1 + cp0->Response_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_advertising_response_data(cp0->Sync_Handle /* 2 */,
                                                              cp0->Request_Event /* 2 */,
                                                              cp0->Request_Subevent /* 1 */,
                                                              cp0->Response_Subevent /* 1 */,
                                                              cp0->Response_Slot /* 1 */,
                                                              cp0->Response_Data_Length /* 1 */,
                                                              cp0->Response_Data /* cp0->Response_Data_Length * (sizeof(uint8_t)) */);
fail:
  rp0->Sync_Handle = cp0->Sync_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x83;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_ENABLED) || HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_ENABLED) && !HCI_LE_SET_PERIODIC_SYNC_SUBEVENT_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_sync_subevent(uint16_t Sync_Handle,
                                             uint16_t Periodic_Advertising_Properties,
                                             uint8_t Num_Subevents,
                                             uint8_t Subevent[]);
 */
/* Command len: 2 + 2 + 1 + cp0->Num_Subevents * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_periodic_sync_subevent_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_sync_subevent_cp0 *cp0 = (hci_le_set_periodic_sync_subevent_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_periodic_sync_subevent_rp0 *rp0 = (hci_le_set_periodic_sync_subevent_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + cp0->Num_Subevents * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_sync_subevent(cp0->Sync_Handle /* 2 */,
                                                  cp0->Periodic_Advertising_Properties /* 2 */,
                                                  cp0->Num_Subevents /* 1 */,
                                                  cp0->Subevent /* cp0->Num_Subevents * (sizeof(uint8_t)) */);
fail:
  rp0->Sync_Handle = cp0->Sync_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x84;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_EXTENDED_CREATE_CONNECTION_V2_ENABLED) || HCI_LE_EXTENDED_CREATE_CONNECTION_V2_ENABLED) && !HCI_LE_EXTENDED_CREATE_CONNECTION_V2_FORCE_DISABLED
/* tBleStatus hci_le_extended_create_connection_v2(uint8_t Advertising_Handle,
                                                uint8_t Subevent,
                                                uint8_t Initiator_Filter_Policy,
                                                uint8_t Own_Address_Type,
                                                uint8_t Peer_Address_Type,
                                                uint8_t Peer_Address[6],
                                                uint8_t Initiating_PHYs,
                                                Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 6 + 1 + struct_length */
/* Response len: 1 */
uint16_t hci_le_extended_create_connection_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_extended_create_connection_v2_cp0 *cp0 = (hci_le_extended_create_connection_v2_cp0 *)(buffer_in + (0));
  Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Create_Connection_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  int len = 0;

  for (i = 0; i < sizeof( cp0->Initiating_PHYs)*8; i++) {
    if((cp0->Initiating_PHYs >> i) & 0x01){
      len++;
    }
  }
  if(len > HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Create_Connection_Parameters_t))
  {
    len = 0;
    goto fail;
  }
  for (i = 0; i < len; i++) {
    packed_Extended_Create_Connection_Parameters_t *Extended_Create_Connection_Parameters_tmp = (packed_Extended_Create_Connection_Parameters_t *)(((uint8_t *)cp0->Extended_Create_Connection_Parameters) + struct_length);
    Extended_Create_Connection_Parameters[i].Scan_Interval = Extended_Create_Connection_Parameters_tmp->Scan_Interval;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Scan_Window = Extended_Create_Connection_Parameters_tmp->Scan_Window;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Connection_Interval_Min = Extended_Create_Connection_Parameters_tmp->Connection_Interval_Min;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Connection_Interval_Max = Extended_Create_Connection_Parameters_tmp->Connection_Interval_Max;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Max_Latency = Extended_Create_Connection_Parameters_tmp->Max_Latency;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Supervision_Timeout = Extended_Create_Connection_Parameters_tmp->Supervision_Timeout;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Min_CE_Length = Extended_Create_Connection_Parameters_tmp->Min_CE_Length;
    struct_length += 2;
    Extended_Create_Connection_Parameters[i].Max_CE_Length = Extended_Create_Connection_Parameters_tmp->Max_CE_Length;
    struct_length += 2;
  }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 6 + 1 + struct_length)
  {
    goto fail;
  }

  *status = hci_le_extended_create_connection_v2(cp0->Advertising_Handle /* 1 */,
                                                 cp0->Subevent /* 1 */,
                                                 cp0->Initiator_Filter_Policy /* 1 */,
                                                 cp0->Own_Address_Type /* 1 */,
                                                 cp0->Peer_Address_Type /* 1 */,
                                                 cp0->Peer_Address /* 6 */,
                                                 cp0->Initiating_PHYs /* 1 */,
                                                 Extended_Create_Connection_Parameters /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x85;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_ENABLED) || HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_ENABLED) && !HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2_FORCE_DISABLED
/* tBleStatus hci_le_set_periodic_advertising_parameters_v2(uint8_t Advertising_Handle,
                                                         uint16_t Periodic_Advertising_Interval_Min,
                                                         uint16_t Periodic_Advertising_Interval_Max,
                                                         uint16_t Periodic_Advertising_Properties,
                                                         uint8_t Num_Subevents,
                                                         uint8_t Subevent_Interval,
                                                         uint8_t Response_Slot_Delay,
                                                         uint8_t Response_Slot_Spacing,
                                                         uint8_t Num_Response_Slots);
 */
/* Command len: 1 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_set_periodic_advertising_parameters_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_parameters_v2_cp0 *cp0 = (hci_le_set_periodic_advertising_parameters_v2_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_set_periodic_advertising_parameters_v2_rp0 *rp0 = (hci_le_set_periodic_advertising_parameters_v2_rp0 *) (buffer_out + 6);

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_advertising_parameters_v2(cp0->Advertising_Handle /* 1 */,
                                                              cp0->Periodic_Advertising_Interval_Min /* 2 */,
                                                              cp0->Periodic_Advertising_Interval_Max /* 2 */,
                                                              cp0->Periodic_Advertising_Properties /* 2 */,
                                                              cp0->Num_Subevents /* 1 */,
                                                              cp0->Subevent_Interval /* 1 */,
                                                              cp0->Response_Slot_Delay /* 1 */,
                                                              cp0->Response_Slot_Spacing /* 1 */,
                                                              cp0->Num_Response_Slots /* 1 */);
fail:
  rp0->Advertising_Handle = cp0->Advertising_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x86;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_GET_FW_BUILD_NUMBER_ENABLED) || ACI_HAL_GET_FW_BUILD_NUMBER_ENABLED) && !ACI_HAL_GET_FW_BUILD_NUMBER_FORCE_DISABLED
/* tBleStatus aci_hal_get_fw_build_number(uint16_t *Build_Number);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t aci_hal_get_fw_build_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  aci_hal_get_fw_build_number_rp0 *rp0 = (aci_hal_get_fw_build_number_rp0 *) (buffer_out + 6);
  uint16_t Build_Number = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_hal_get_fw_build_number(&Build_Number);
fail:
  rp0->Build_Number = Build_Number;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x00;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_GET_FIRMWARE_DETAILS_ENABLED) || ACI_HAL_GET_FIRMWARE_DETAILS_ENABLED) && !ACI_HAL_GET_FIRMWARE_DETAILS_FORCE_DISABLED
/* tBleStatus aci_hal_get_firmware_details(uint8_t *DTM_version_major,
                                        uint8_t *DTM_version_minor,
                                        uint8_t *DTM_version_patch,
                                        uint8_t *DTM_variant,
                                        uint16_t *DTM_Build_Number,
                                        uint8_t *BTLE_Stack_version_major,
                                        uint8_t *BTLE_Stack_version_minor,
                                        uint8_t *BTLE_Stack_version_patch,
                                        uint8_t *BTLE_Stack_development,
                                        uint16_t *BTLE_Stack_variant,
                                        uint16_t *BTLE_Stack_Build_Number);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 */
uint16_t aci_hal_get_firmware_details_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2;
  /* Output params */
  aci_hal_get_firmware_details_rp0 *rp0 = (aci_hal_get_firmware_details_rp0 *) (buffer_out + 6);
  uint8_t DTM_version_major = 0;
  uint8_t DTM_version_minor = 0;
  uint8_t DTM_version_patch = 0;
  uint8_t DTM_variant = 0;
  uint16_t DTM_Build_Number = 0;
  uint8_t BTLE_Stack_version_major = 0;
  uint8_t BTLE_Stack_version_minor = 0;
  uint8_t BTLE_Stack_version_patch = 0;
  uint8_t BTLE_Stack_development = 0;
  uint16_t BTLE_Stack_variant = 0;
  uint16_t BTLE_Stack_Build_Number = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_hal_get_firmware_details(&DTM_version_major,
                                             &DTM_version_minor,
                                             &DTM_version_patch,
                                             &DTM_variant,
                                             &DTM_Build_Number,
                                             &BTLE_Stack_version_major,
                                             &BTLE_Stack_version_minor,
                                             &BTLE_Stack_version_patch,
                                             &BTLE_Stack_development,
                                             &BTLE_Stack_variant,
                                             &BTLE_Stack_Build_Number);
fail:
  rp0->DTM_version_major = DTM_version_major;
  rp0->DTM_version_minor = DTM_version_minor;
  rp0->DTM_version_patch = DTM_version_patch;
  rp0->DTM_variant = DTM_variant;
  rp0->DTM_Build_Number = DTM_Build_Number;
  rp0->BTLE_Stack_version_major = BTLE_Stack_version_major;
  rp0->BTLE_Stack_version_minor = BTLE_Stack_version_minor;
  rp0->BTLE_Stack_version_patch = BTLE_Stack_version_patch;
  rp0->BTLE_Stack_development = BTLE_Stack_development;
  rp0->BTLE_Stack_variant = BTLE_Stack_variant;
  rp0->BTLE_Stack_Build_Number = BTLE_Stack_Build_Number;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_GET_FIRMWARE_DETAILS_V2_ENABLED) || ACI_HAL_GET_FIRMWARE_DETAILS_V2_ENABLED) && !ACI_HAL_GET_FIRMWARE_DETAILS_V2_FORCE_DISABLED
/* tBleStatus aci_hal_get_firmware_details_v2(uint8_t *DTM_version_major,
                                           uint8_t *DTM_version_minor,
                                           uint8_t *DTM_version_patch,
                                           uint8_t *DTM_variant,
                                           uint16_t *DTM_Build_Number,
                                           uint8_t *BTLE_Stack_version_major,
                                           uint8_t *BTLE_Stack_version_minor,
                                           uint8_t *BTLE_Stack_version_patch,
                                           uint8_t *BTLE_Stack_development,
                                           uint32_t *BTLE_Stack_variant,
                                           uint16_t *BTLE_Stack_Build_Number);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 4 + 2 */
uint16_t aci_hal_get_firmware_details_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 4 + 2;
  /* Output params */
  aci_hal_get_firmware_details_v2_rp0 *rp0 = (aci_hal_get_firmware_details_v2_rp0 *) (buffer_out + 6);
  uint8_t DTM_version_major = 0;
  uint8_t DTM_version_minor = 0;
  uint8_t DTM_version_patch = 0;
  uint8_t DTM_variant = 0;
  uint16_t DTM_Build_Number = 0;
  uint8_t BTLE_Stack_version_major = 0;
  uint8_t BTLE_Stack_version_minor = 0;
  uint8_t BTLE_Stack_version_patch = 0;
  uint8_t BTLE_Stack_development = 0;
  uint32_t BTLE_Stack_variant = 0;
  uint16_t BTLE_Stack_Build_Number = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 4 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_hal_get_firmware_details_v2(&DTM_version_major,
                                                &DTM_version_minor,
                                                &DTM_version_patch,
                                                &DTM_variant,
                                                &DTM_Build_Number,
                                                &BTLE_Stack_version_major,
                                                &BTLE_Stack_version_minor,
                                                &BTLE_Stack_version_patch,
                                                &BTLE_Stack_development,
                                                &BTLE_Stack_variant,
                                                &BTLE_Stack_Build_Number);
fail:
  rp0->DTM_version_major = DTM_version_major;
  rp0->DTM_version_minor = DTM_version_minor;
  rp0->DTM_version_patch = DTM_version_patch;
  rp0->DTM_variant = DTM_variant;
  rp0->DTM_Build_Number = DTM_Build_Number;
  rp0->BTLE_Stack_version_major = BTLE_Stack_version_major;
  rp0->BTLE_Stack_version_minor = BTLE_Stack_version_minor;
  rp0->BTLE_Stack_version_patch = BTLE_Stack_version_patch;
  rp0->BTLE_Stack_development = BTLE_Stack_development;
  rp0->BTLE_Stack_variant = BTLE_Stack_variant;
  rp0->BTLE_Stack_Build_Number = BTLE_Stack_Build_Number;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_WRITE_CONFIG_DATA_ENABLED) || ACI_HAL_WRITE_CONFIG_DATA_ENABLED) && !ACI_HAL_WRITE_CONFIG_DATA_FORCE_DISABLED
/* tBleStatus aci_hal_write_config_data(uint8_t Offset,
                                     uint8_t Length,
                                     uint8_t Value[]);
 */
/* Command len: 1 + 1 + cp0->Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_write_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + cp0->Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_hal_write_config_data(cp0->Offset /* 1 */,
                                      cp0->Length /* 1 */,
                                      cp0->Value /* cp0->Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_READ_CONFIG_DATA_ENABLED) || ACI_HAL_READ_CONFIG_DATA_ENABLED) && !ACI_HAL_READ_CONFIG_DATA_FORCE_DISABLED
/* tBleStatus aci_hal_read_config_data(uint8_t Offset,
                                    uint8_t *Data_Length,
                                    uint8_t Data[]);
 */
/* Command len: 1 */
/* Response len: 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
uint16_t aci_hal_read_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_read_config_data_cp0 *cp0 = (aci_hal_read_config_data_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_hal_read_config_data_rp0 *rp0 = (aci_hal_read_config_data_rp0 *) (buffer_out + 6);
  uint8_t Data_Length = 0;
  uint8_t Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = aci_hal_read_config_data(cp0->Offset /* 1 */,
                                         &Data_Length,
                                         Data);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Data_Length = Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, rp0->Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Data_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0d;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_SET_TX_POWER_LEVEL_ENABLED) || ACI_HAL_SET_TX_POWER_LEVEL_ENABLED) && !ACI_HAL_SET_TX_POWER_LEVEL_FORCE_DISABLED
tBleStatus aci_hal_set_tx_power_level_preprocess(uint8_t En_High_Power,
                                                 uint8_t PA_Level);
/* tBleStatus aci_hal_set_tx_power_level(uint8_t En_High_Power,
                                      uint8_t PA_Level);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_tx_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = aci_hal_set_tx_power_level_preprocess(cp0->En_High_Power /* 1 */,
                                                  cp0->PA_Level /* 1 */);
  if(*status)
    goto fail;

  *status = aci_hal_set_tx_power_level(cp0->En_High_Power /* 1 */,
                                       cp0->PA_Level /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0f;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_LE_TX_TEST_PACKET_NUMBER_ENABLED) || ACI_HAL_LE_TX_TEST_PACKET_NUMBER_ENABLED) && !ACI_HAL_LE_TX_TEST_PACKET_NUMBER_FORCE_DISABLED
/* tBleStatus aci_hal_le_tx_test_packet_number(uint32_t *Number_Of_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 4 */
uint16_t aci_hal_le_tx_test_packet_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 4;
  /* Output params */
  aci_hal_le_tx_test_packet_number_rp0 *rp0 = (aci_hal_le_tx_test_packet_number_rp0 *) (buffer_out + 6);
  uint32_t Number_Of_Packets = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 4 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_hal_le_tx_test_packet_number(&Number_Of_Packets);
fail:
  rp0->Number_Of_Packets = Number_Of_Packets;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x14;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_TONE_START_ENABLED) || ACI_HAL_TONE_START_ENABLED) && !ACI_HAL_TONE_START_FORCE_DISABLED
/* tBleStatus aci_hal_tone_start(uint8_t RF_Channel,
                              uint8_t Offset);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_tone_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_tone_start_cp0 *cp0 = (aci_hal_tone_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = aci_hal_tone_start(cp0->RF_Channel /* 1 */,
                               cp0->Offset /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x15;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_TONE_STOP_ENABLED) || ACI_HAL_TONE_STOP_ENABLED) && !ACI_HAL_TONE_STOP_FORCE_DISABLED
/* tBleStatus aci_hal_tone_stop(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_hal_tone_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = aci_hal_tone_stop();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x16;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_GET_LINK_STATUS_ENABLED) || ACI_HAL_GET_LINK_STATUS_ENABLED) && !ACI_HAL_GET_LINK_STATUS_FORCE_DISABLED
/* tBleStatus aci_hal_get_link_status(uint8_t Bank_index,
                                   uint8_t Link_Status[8],
                                   uint16_t Link_Connection_Handle[16 / 2]);
 */
/* Command len: 1 */
/* Response len: 1 + 8 + 16 */
uint16_t aci_hal_get_link_status_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_get_link_status_cp0 *cp0 = (aci_hal_get_link_status_cp0 *)(buffer_in + (0));

  int output_size = 1 + 8 + 16;
  /* Output params */
  aci_hal_get_link_status_rp0 *rp0 = (aci_hal_get_link_status_rp0 *) (buffer_out + 6);
  uint8_t Link_Status[8] = {0};
  uint16_t Link_Connection_Handle[16 / 2] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 8 + 16 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = aci_hal_get_link_status(cp0->Bank_index /* 1 */,
                                        Link_Status,
                                        Link_Connection_Handle);
fail:
  Osal_MemCpy((void *) rp0->Link_Status,(const void *) Link_Status, 8);
  Osal_MemCpy((void *) rp0->Link_Connection_Handle,(const void *) Link_Connection_Handle, 16);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x17;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_SET_RADIO_ACTIVITY_MASK_ENABLED) || ACI_HAL_SET_RADIO_ACTIVITY_MASK_ENABLED) && !ACI_HAL_SET_RADIO_ACTIVITY_MASK_FORCE_DISABLED
/* tBleStatus aci_hal_set_radio_activity_mask(uint16_t Radio_Activity_Mask);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_hal_set_radio_activity_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_radio_activity_mask_cp0 *cp0 = (aci_hal_set_radio_activity_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = aci_hal_set_radio_activity_mask(cp0->Radio_Activity_Mask /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x18;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_SET_LE_POWER_CONTROL_ENABLED) || ACI_HAL_SET_LE_POWER_CONTROL_ENABLED) && !ACI_HAL_SET_LE_POWER_CONTROL_FORCE_DISABLED
/* tBleStatus aci_hal_set_le_power_control(uint8_t Enable,
                                        uint8_t PHY,
                                        int8_t RSSI_Target,
                                        uint8_t RSSI_Hysteresis,
                                        int8_t Initial_TX_Power,
                                        uint8_t RSSI_Filtering_Coefficient);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_le_power_control_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_le_power_control_cp0 *cp0 = (aci_hal_set_le_power_control_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_hal_set_le_power_control(cp0->Enable /* 1 */,
                                         cp0->PHY /* 1 */,
                                         cp0->RSSI_Target /* 1 */,
                                         cp0->RSSI_Hysteresis /* 1 */,
                                         cp0->Initial_TX_Power /* 1 */,
                                         cp0->RSSI_Filtering_Coefficient /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_TRANSMITTER_TEST_PACKETS_ENABLED) || ACI_HAL_TRANSMITTER_TEST_PACKETS_ENABLED) && !ACI_HAL_TRANSMITTER_TEST_PACKETS_FORCE_DISABLED
/* tBleStatus aci_hal_transmitter_test_packets(uint8_t TX_Frequency,
                                            uint8_t Length_Of_Test_Data,
                                            uint8_t Packet_Payload,
                                            uint16_t Number_Of_Packets,
                                            uint8_t PHY);
 */
/* Command len: 1 + 1 + 1 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_hal_transmitter_test_packets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_transmitter_test_packets_cp0 *cp0 = (aci_hal_transmitter_test_packets_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 2 + 1)
  {
    goto fail;
  }

  *status = aci_hal_transmitter_test_packets(cp0->TX_Frequency /* 1 */,
                                             cp0->Length_Of_Test_Data /* 1 */,
                                             cp0->Packet_Payload /* 1 */,
                                             cp0->Number_Of_Packets /* 2 */,
                                             cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x2b;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_ENABLED) || ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_ENABLED) && !ACI_HAL_TRANSMITTER_TEST_PACKETS_V2_FORCE_DISABLED
/* tBleStatus aci_hal_transmitter_test_packets_v2(uint8_t TX_Channel,
                                               uint8_t Test_Data_Length,
                                               uint8_t Packet_Payload,
                                               uint16_t Number_Of_Packets,
                                               uint8_t PHY,
                                               uint8_t CTE_Length,
                                               uint8_t CTE_Type,
                                               uint8_t Switching_Pattern_Length,
                                               uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_transmitter_test_packets_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_transmitter_test_packets_v2_cp0 *cp0 = (aci_hal_transmitter_test_packets_v2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_hal_transmitter_test_packets_v2(cp0->TX_Channel /* 1 */,
                                                cp0->Test_Data_Length /* 1 */,
                                                cp0->Packet_Payload /* 1 */,
                                                cp0->Number_Of_Packets /* 2 */,
                                                cp0->PHY /* 1 */,
                                                cp0->CTE_Length /* 1 */,
                                                cp0->CTE_Type /* 1 */,
                                                cp0->Switching_Pattern_Length /* 1 */,
                                                cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_WRITE_RADIO_REG_ENABLED) || ACI_HAL_WRITE_RADIO_REG_ENABLED) && !ACI_HAL_WRITE_RADIO_REG_FORCE_DISABLED
/* tBleStatus aci_hal_write_radio_reg(uint32_t Start_Address,
                                   uint8_t Num_Bytes,
                                   uint8_t Data[]);
 */
/* Command len: 4 + 1 + cp0->Num_Bytes * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_write_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_write_radio_reg_cp0 *cp0 = (aci_hal_write_radio_reg_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4 + 1 + cp0->Num_Bytes * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_hal_write_radio_reg(cp0->Start_Address /* 4 */,
                                    cp0->Num_Bytes /* 1 */,
                                    cp0->Data /* cp0->Num_Bytes * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_READ_RADIO_REG_ENABLED) || ACI_HAL_READ_RADIO_REG_ENABLED) && !ACI_HAL_READ_RADIO_REG_FORCE_DISABLED
/* tBleStatus aci_hal_read_radio_reg(uint32_t Start_Address,
                                  uint8_t Num_Bytes,
                                  uint8_t *Data_Length,
                                  uint8_t Data[]);
 */
/* Command len: 4 + 1 */
/* Response len: 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
uint16_t aci_hal_read_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_read_radio_reg_cp0 *cp0 = (aci_hal_read_radio_reg_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_hal_read_radio_reg_rp0 *rp0 = (aci_hal_read_radio_reg_rp0 *) (buffer_out + 6);
  uint8_t Data_Length = 0;
  uint8_t Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_hal_read_radio_reg(cp0->Start_Address /* 4 */,
                                       cp0->Num_Bytes /* 1 */,
                                       &Data_Length,
                                       Data);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Data_Length = Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, rp0->Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Data_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_ENABLED) || ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_ENABLED) && !ACI_HAL_SET_ANTENNA_SWITCH_PARAMETERS_FORCE_DISABLED
/* tBleStatus aci_hal_set_antenna_switch_parameters(uint8_t Antenna_IDs,
                                                 uint8_t Antenna_ID_Shift,
                                                 uint8_t Default_Antenna_ID,
                                                 uint8_t RF_Activity_Enable);
 */
/* Command len: 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_antenna_switch_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_antenna_switch_parameters_cp0 *cp0 = (aci_hal_set_antenna_switch_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_hal_set_antenna_switch_parameters(cp0->Antenna_IDs /* 1 */,
                                                  cp0->Antenna_ID_Shift /* 1 */,
                                                  cp0->Default_Antenna_ID /* 1 */,
                                                  cp0->RF_Activity_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_PERIPHERAL_LATENCY_ENABLE_ENABLED) || ACI_HAL_PERIPHERAL_LATENCY_ENABLE_ENABLED) && !ACI_HAL_PERIPHERAL_LATENCY_ENABLE_FORCE_DISABLED
/* tBleStatus aci_hal_peripheral_latency_enable(uint16_t Connection_Handle,
                                             uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_hal_peripheral_latency_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_peripheral_latency_enable_cp0 *cp0 = (aci_hal_peripheral_latency_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_hal_peripheral_latency_enable(cp0->Connection_Handle /* 2 */,
                                              cp0->Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x38;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_ENABLED) || ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_ENABLED) && !ACI_HAL_GET_EVT_FIFO_MAX_LEVEL_FORCE_DISABLED
/* tBleStatus aci_hal_get_evt_fifo_max_level(uint16_t *ISR0_FIFO_Max_Level,
                                          uint16_t *ISR1_FIFO_Max_Level,
                                          uint16_t *User_FIFO_Max_Level);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 + 2 */
uint16_t aci_hal_get_evt_fifo_max_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2 + 2;
  /* Output params */
  aci_hal_get_evt_fifo_max_level_rp0 *rp0 = (aci_hal_get_evt_fifo_max_level_rp0 *) (buffer_out + 6);
  uint16_t ISR0_FIFO_Max_Level = 0;
  uint16_t ISR1_FIFO_Max_Level = 0;
  uint16_t User_FIFO_Max_Level = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_hal_get_evt_fifo_max_level(&ISR0_FIFO_Max_Level,
                                               &ISR1_FIFO_Max_Level,
                                               &User_FIFO_Max_Level);
fail:
  rp0->ISR0_FIFO_Max_Level = ISR0_FIFO_Max_Level;
  rp0->ISR1_FIFO_Max_Level = ISR1_FIFO_Max_Level;
  rp0->User_FIFO_Max_Level = User_FIFO_Max_Level;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x60;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if BLESTACK_CONTROLLER_ONLY==0

#if (!defined(ACI_GAP_INIT_ENABLED) || ACI_GAP_INIT_ENABLED) && !ACI_GAP_INIT_FORCE_DISABLED
/* tBleStatus aci_gap_init(uint8_t Privacy_Type,
                        uint8_t Identity_Address_Type);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  *status = aci_gap_init(cp0->Privacy_Type /* 1 */,
                         cp0->Identity_Address_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x81;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_IO_CAPABILITY_ENABLED) || ACI_GAP_SET_IO_CAPABILITY_ENABLED) && !ACI_GAP_SET_IO_CAPABILITY_FORCE_DISABLED
/* tBleStatus aci_gap_set_io_capability(uint8_t IO_Capability);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_set_io_capability_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = aci_gap_set_io_capability(cp0->IO_Capability /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x85;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_SECURITY_REQUIREMENTS_ENABLED) || ACI_GAP_SET_SECURITY_REQUIREMENTS_ENABLED) && !ACI_GAP_SET_SECURITY_REQUIREMENTS_FORCE_DISABLED
/* tBleStatus aci_gap_set_security_requirements(uint8_t Bonding_Mode,
                                             uint8_t MITM_Mode,
                                             uint8_t SC_Support,
                                             uint8_t KeyPress_Notification_Support,
                                             uint8_t Min_Encryption_Key_Size,
                                             uint8_t Max_Encryption_Key_Size,
                                             uint8_t Pairing_Response);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_security_requirements_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_security_requirements_cp0 *cp0 = (aci_gap_set_security_requirements_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_gap_set_security_requirements(cp0->Bonding_Mode /* 1 */,
                                              cp0->MITM_Mode /* 1 */,
                                              cp0->SC_Support /* 1 */,
                                              cp0->KeyPress_Notification_Support /* 1 */,
                                              cp0->Min_Encryption_Key_Size /* 1 */,
                                              cp0->Max_Encryption_Key_Size /* 1 */,
                                              cp0->Pairing_Response /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x86;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_PASSKEY_RESP_ENABLED) || ACI_GAP_PASSKEY_RESP_ENABLED) && !ACI_GAP_PASSKEY_RESP_FORCE_DISABLED
/* tBleStatus aci_gap_passkey_resp(uint16_t Connection_Handle,
                                uint32_t Passkey);
 */
/* Command len: 2 + 4 */
/* Response len: 1 */
uint16_t aci_gap_passkey_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_passkey_resp_cp0 *cp0 = (aci_gap_passkey_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 4)
  {
    goto fail;
  }

  *status = aci_gap_passkey_resp(cp0->Connection_Handle /* 2 */,
                                 cp0->Passkey /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x88;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_PROFILE_INIT_ENABLED) || ACI_GAP_PROFILE_INIT_ENABLED) && !ACI_GAP_PROFILE_INIT_FORCE_DISABLED
/* tBleStatus aci_gap_profile_init(uint8_t Role,
                                uint8_t Privacy_Type,
                                uint16_t *Dev_Name_Char_Handle,
                                uint16_t *Appearance_Char_Handle,
                                uint16_t *Periph_Pref_Conn_Param_Char_Handle);
 */
/* Command len: 1 + 1 */
/* Response len: 1 + 2 + 2 + 2 */
uint16_t aci_gap_profile_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_profile_init_cp0 *cp0 = (aci_gap_profile_init_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 2 + 2;
  /* Output params */
  aci_gap_profile_init_rp0 *rp0 = (aci_gap_profile_init_rp0 *) (buffer_out + 6);
  uint16_t Dev_Name_Char_Handle = 0;
  uint16_t Appearance_Char_Handle = 0;
  uint16_t Periph_Pref_Conn_Param_Char_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gap_profile_init(cp0->Role /* 1 */,
                                     cp0->Privacy_Type /* 1 */,
                                     &Dev_Name_Char_Handle,
                                     &Appearance_Char_Handle,
                                     &Periph_Pref_Conn_Param_Char_Handle);
fail:
  rp0->Dev_Name_Char_Handle = Dev_Name_Char_Handle;
  rp0->Appearance_Char_Handle = Appearance_Char_Handle;
  rp0->Periph_Pref_Conn_Param_Char_Handle = Periph_Pref_Conn_Param_Char_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x8a;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_SECURITY_ENABLED) || ACI_GAP_SET_SECURITY_ENABLED) && !ACI_GAP_SET_SECURITY_FORCE_DISABLED
/* tBleStatus aci_gap_set_security(uint16_t Connection_Handle,
                                uint8_t Security_Level,
                                uint8_t Force_Pairing);
 */
/* Command len: 2 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_security_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_security_cp0 *cp0 = (aci_gap_set_security_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_gap_set_security(cp0->Connection_Handle /* 2 */,
                                 cp0->Security_Level /* 1 */,
                                 cp0->Force_Pairing /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x8d;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_GET_SECURITY_LEVEL_ENABLED) || ACI_GAP_GET_SECURITY_LEVEL_ENABLED) && !ACI_GAP_GET_SECURITY_LEVEL_FORCE_DISABLED
/* tBleStatus aci_gap_get_security_level(uint16_t Connection_Handle,
                                      uint8_t *Security_Mode,
                                      uint8_t *Security_Level);
 */
/* Command len: 2 */
/* Response len: 1 + 1 + 1 */
uint16_t aci_gap_get_security_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_security_level_cp0 *cp0 = (aci_gap_get_security_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1 + 1;
  /* Output params */
  aci_gap_get_security_level_rp0 *rp0 = (aci_gap_get_security_level_rp0 *) (buffer_out + 6);
  uint8_t Security_Mode = 0;
  uint8_t Security_Level = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  rp0->Status = aci_gap_get_security_level(cp0->Connection_Handle /* 2 */,
                                           &Security_Mode,
                                           &Security_Level);
fail:
  rp0->Security_Mode = Security_Mode;
  rp0->Security_Level = Security_Level;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x90;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_LE_EVENT_MASK_ENABLED) || ACI_GAP_SET_LE_EVENT_MASK_ENABLED) && !ACI_GAP_SET_LE_EVENT_MASK_FORCE_DISABLED
/* tBleStatus aci_gap_set_le_event_mask(uint8_t LE_Event_Mask[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t aci_gap_set_le_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_le_event_mask_cp0 *cp0 = (aci_gap_set_le_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    goto fail;
  }

  *status = aci_gap_set_le_event_mask(cp0->LE_Event_Mask /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x92;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_TERMINATE_ENABLED) || ACI_GAP_TERMINATE_ENABLED) && !ACI_GAP_TERMINATE_FORCE_DISABLED
/* tBleStatus aci_gap_terminate(uint16_t Connection_Handle,
                             uint8_t Reason);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_terminate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gap_terminate(cp0->Connection_Handle /* 2 */,
                              cp0->Reason /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x93;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_CLEAR_SECURITY_DB_ENABLED) || ACI_GAP_CLEAR_SECURITY_DB_ENABLED) && !ACI_GAP_CLEAR_SECURITY_DB_FORCE_DISABLED
/* tBleStatus aci_gap_clear_security_db(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_clear_security_db_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = aci_gap_clear_security_db();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x94;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_PAIRING_RESP_ENABLED) || ACI_GAP_PAIRING_RESP_ENABLED) && !ACI_GAP_PAIRING_RESP_FORCE_DISABLED
/* tBleStatus aci_gap_pairing_resp(uint16_t Connection_Handle,
                                uint8_t Accept);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_pairing_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_pairing_resp_cp0 *cp0 = (aci_gap_pairing_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gap_pairing_resp(cp0->Connection_Handle /* 2 */,
                                 cp0->Accept /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x96;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_CREATE_CONNECTION_ENABLED) || ACI_GAP_CREATE_CONNECTION_ENABLED) && !ACI_GAP_CREATE_CONNECTION_FORCE_DISABLED
/* tBleStatus aci_gap_create_connection(uint8_t Initiating_PHY,
                                     uint8_t Peer_Address_Type,
                                     uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_create_connection_cp0 *cp0 = (aci_gap_create_connection_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6)
  {
    goto fail;
  }

  *status = aci_gap_create_connection(cp0->Initiating_PHY /* 1 */,
                                      cp0->Peer_Address_Type /* 1 */,
                                      cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9c;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_TERMINATE_PROC_ENABLED) || ACI_GAP_TERMINATE_PROC_ENABLED) && !ACI_GAP_TERMINATE_PROC_FORCE_DISABLED
/* tBleStatus aci_gap_terminate_proc(uint8_t Procedure_Code);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_terminate_proc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_terminate_proc_cp0 *cp0 = (aci_gap_terminate_proc_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = aci_gap_terminate_proc(cp0->Procedure_Code /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9d;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_START_CONNECTION_UPDATE_ENABLED) || ACI_GAP_START_CONNECTION_UPDATE_ENABLED) && !ACI_GAP_START_CONNECTION_UPDATE_FORCE_DISABLED
/* tBleStatus aci_gap_start_connection_update(uint16_t Connection_Handle,
                                           uint16_t Connection_Interval_Min,
                                           uint16_t Connection_Interval_Max,
                                           uint16_t Max_Latency,
                                           uint16_t Supervision_Timeout,
                                           uint16_t Min_CE_Length,
                                           uint16_t Max_CE_Length);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_start_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_start_connection_update_cp0 *cp0 = (aci_gap_start_connection_update_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gap_start_connection_update(cp0->Connection_Handle /* 2 */,
                                            cp0->Connection_Interval_Min /* 2 */,
                                            cp0->Connection_Interval_Max /* 2 */,
                                            cp0->Max_Latency /* 2 */,
                                            cp0->Supervision_Timeout /* 2 */,
                                            cp0->Min_CE_Length /* 2 */,
                                            cp0->Max_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9e;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_RESOLVE_PRIVATE_ADDR_ENABLED) || ACI_GAP_RESOLVE_PRIVATE_ADDR_ENABLED) && !ACI_GAP_RESOLVE_PRIVATE_ADDR_FORCE_DISABLED
/* tBleStatus aci_gap_resolve_private_addr(uint8_t Address[6],
                                        uint8_t Actual_Address[6]);
 */
/* Command len: 6 */
/* Response len: 1 + 6 */
uint16_t aci_gap_resolve_private_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_resolve_private_addr_cp0 *cp0 = (aci_gap_resolve_private_addr_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  aci_gap_resolve_private_addr_rp0 *rp0 = (aci_gap_resolve_private_addr_rp0 *) (buffer_out + 6);
  uint8_t Actual_Address[6] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 6)
  {
    goto fail;
  }

  rp0->Status = aci_gap_resolve_private_addr(cp0->Address /* 6 */,
                                             Actual_Address);
fail:
  Osal_MemCpy((void *) rp0->Actual_Address,(const void *) Actual_Address, 6);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa0;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_GET_BONDED_DEVICES_ENABLED) || ACI_GAP_GET_BONDED_DEVICES_ENABLED) && !ACI_GAP_GET_BONDED_DEVICES_FORCE_DISABLED
/* tBleStatus aci_gap_get_bonded_devices(uint8_t Offset,
                                      uint8_t Max_Num_Of_Addresses,
                                      uint8_t *Num_of_Addresses,
                                      Bonded_Device_Entry_t Bonded_Device_Entry[]);
 */
/* Command len: 1 + 1 */
/* Response len: 1 + 1 + struct_length */
uint16_t aci_gap_get_bonded_devices_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_bonded_devices_cp0 *cp0 = (aci_gap_get_bonded_devices_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gap_get_bonded_devices_rp0 *rp0 = (aci_gap_get_bonded_devices_rp0 *) (buffer_out + 6);
  uint8_t Num_of_Addresses = 0;
  Bonded_Device_Entry_t Bonded_Device_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Bonded_Device_Entry_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gap_get_bonded_devices(cp0->Offset /* 1 */,
                                           cp0->Max_Num_Of_Addresses /* 1 */,
                                           &Num_of_Addresses,
                                           Bonded_Device_Entry);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Num_of_Addresses = Num_of_Addresses;
  output_size += 1;
  {
    int i;
    for (i = 0; i < rp0->Num_of_Addresses; i++) {
      if (buffer_out_max_length < (output_size + (sizeof(uint8_t)) + 6)) { return 0; }
      rp0->Bonded_Device_Entry[i].Address_Type = Bonded_Device_Entry[i].Address_Type;
      output_size += sizeof(uint8_t);
      if (buffer_out_max_length < (output_size + (6) + 6)) { return 0; }
      Osal_MemCpy((void *) &rp0->Bonded_Device_Entry[i].Address, (const void *) Bonded_Device_Entry[i].Address, 6);
      output_size += 6;
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa3;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_IS_DEVICE_BONDED_ENABLED) || ACI_GAP_IS_DEVICE_BONDED_ENABLED) && !ACI_GAP_IS_DEVICE_BONDED_FORCE_DISABLED
/* tBleStatus aci_gap_is_device_bonded(uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_is_device_bonded_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = aci_gap_is_device_bonded(cp0->Peer_Address_Type /* 1 */,
                                     cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa4;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_ENABLED) || ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_ENABLED) && !ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_FORCE_DISABLED
/* tBleStatus aci_gap_numeric_comparison_value_confirm_yesno(uint16_t Connection_Handle,
                                                          uint8_t Confirm_Yes_No);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_numeric_comparison_value_confirm_yesno_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gap_numeric_comparison_value_confirm_yesno(cp0->Connection_Handle /* 2 */,
                                                           cp0->Confirm_Yes_No /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa5;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_PASSKEY_INPUT_ENABLED) || ACI_GAP_PASSKEY_INPUT_ENABLED) && !ACI_GAP_PASSKEY_INPUT_FORCE_DISABLED
/* tBleStatus aci_gap_passkey_input(uint16_t Connection_Handle,
                                 uint8_t Input_Type);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_passkey_input_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_passkey_input_cp0 *cp0 = (aci_gap_passkey_input_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gap_passkey_input(cp0->Connection_Handle /* 2 */,
                                  cp0->Input_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa6;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_GET_OOB_DATA_ENABLED) || ACI_GAP_GET_OOB_DATA_ENABLED) && !ACI_GAP_GET_OOB_DATA_FORCE_DISABLED
/* tBleStatus aci_gap_get_oob_data(uint8_t OOB_Data_Type,
                                uint8_t *Address_Type,
                                uint8_t Address[6],
                                uint8_t *OOB_Data_Len,
                                uint8_t OOB_Data[16]);
 */
/* Command len: 1 */
/* Response len: 1 + 1 + 6 + 1 + 1 + 16 */
uint16_t aci_gap_get_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_oob_data_cp0 *cp0 = (aci_gap_get_oob_data_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1 + 6 + 1 + 1 + 16;
  /* Output params */
  aci_gap_get_oob_data_rp0 *rp0 = (aci_gap_get_oob_data_rp0 *) (buffer_out + 6);
  uint8_t Address_Type = 0;
  uint8_t Address[6] = {0};
  uint8_t OOB_Data_Len = 0;
  uint8_t OOB_Data[16] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 1 + 6 + 1 + 1 + 16 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = aci_gap_get_oob_data(cp0->OOB_Data_Type /* 1 */,
                                     &Address_Type,
                                     Address,
                                     &OOB_Data_Len,
                                     OOB_Data);
fail:
  rp0->Address_Type = Address_Type;
  Osal_MemCpy((void *) rp0->Address,(const void *) Address, 6);
  rp0->OOB_Data_Type = cp0->OOB_Data_Type;
  rp0->OOB_Data_Len = OOB_Data_Len;
  Osal_MemCpy((void *) rp0->OOB_Data,(const void *) OOB_Data, 16);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa7;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_OOB_DATA_ENABLED) || ACI_GAP_SET_OOB_DATA_ENABLED) && !ACI_GAP_SET_OOB_DATA_FORCE_DISABLED
/* tBleStatus aci_gap_set_oob_data(uint8_t Device_Type,
                                uint8_t Address_Type,
                                uint8_t Address[6],
                                uint8_t OOB_Data_Type,
                                uint8_t OOB_Data_Len,
                                uint8_t OOB_Data[16]);
 */
/* Command len: 1 + 1 + 6 + 1 + 1 + 16 */
/* Response len: 1 */
uint16_t aci_gap_set_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_oob_data_cp0 *cp0 = (aci_gap_set_oob_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6 + 1 + 1 + 16)
  {
    goto fail;
  }

  *status = aci_gap_set_oob_data(cp0->Device_Type /* 1 */,
                                 cp0->Address_Type /* 1 */,
                                 cp0->Address /* 6 */,
                                 cp0->OOB_Data_Type /* 1 */,
                                 cp0->OOB_Data_Len /* 1 */,
                                 cp0->OOB_Data /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa8;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_REMOVE_BONDED_DEVICE_ENABLED) || ACI_GAP_REMOVE_BONDED_DEVICE_ENABLED) && !ACI_GAP_REMOVE_BONDED_DEVICE_FORCE_DISABLED
/* tBleStatus aci_gap_remove_bonded_device(uint8_t Peer_Identity_Address_Type,
                                        uint8_t Peer_Identity_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_remove_bonded_device_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_remove_bonded_device_cp0 *cp0 = (aci_gap_remove_bonded_device_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    goto fail;
  }

  *status = aci_gap_remove_bonded_device(cp0->Peer_Identity_Address_Type /* 1 */,
                                         cp0->Peer_Identity_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xaa;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_ADVERTISING_CONFIGURATION_ENABLED) || ACI_GAP_SET_ADVERTISING_CONFIGURATION_ENABLED) && !ACI_GAP_SET_ADVERTISING_CONFIGURATION_FORCE_DISABLED
/* tBleStatus aci_gap_set_advertising_configuration(uint8_t Advertising_Handle,
                                                 uint8_t Discoverable_Mode,
                                                 uint16_t Advertising_Event_Properties,
                                                 uint32_t Primary_Advertising_Interval_Min,
                                                 uint32_t Primary_Advertising_Interval_Max,
                                                 uint8_t Primary_Advertising_Channel_Map,
                                                 uint8_t Peer_Address_Type,
                                                 uint8_t Peer_Address[6],
                                                 uint8_t Advertising_Filter_Policy,
                                                 int8_t Advertising_Tx_Power,
                                                 uint8_t Primary_Advertising_PHY,
                                                 uint8_t Secondary_Advertising_Max_Skip,
                                                 uint8_t Secondary_Advertising_PHY,
                                                 uint8_t Advertising_SID,
                                                 uint8_t Scan_Request_Notification_Enable);
 */
/* Command len: 1 + 1 + 2 + 4 + 4 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_configuration_cp0 *cp0 = (aci_gap_set_advertising_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 4 + 4 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_gap_set_advertising_configuration(cp0->Advertising_Handle /* 1 */,
                                                  cp0->Discoverable_Mode /* 1 */,
                                                  cp0->Advertising_Event_Properties /* 2 */,
                                                  cp0->Primary_Advertising_Interval_Min /* 4 */,
                                                  cp0->Primary_Advertising_Interval_Max /* 4 */,
                                                  cp0->Primary_Advertising_Channel_Map /* 1 */,
                                                  cp0->Peer_Address_Type /* 1 */,
                                                  cp0->Peer_Address /* 6 */,
                                                  cp0->Advertising_Filter_Policy /* 1 */,
                                                  cp0->Advertising_Tx_Power /* 1 */,
                                                  cp0->Primary_Advertising_PHY /* 1 */,
                                                  cp0->Secondary_Advertising_Max_Skip /* 1 */,
                                                  cp0->Secondary_Advertising_PHY /* 1 */,
                                                  cp0->Advertising_SID /* 1 */,
                                                  cp0->Scan_Request_Notification_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xab;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_ADVERTISING_ENABLE_ENABLED) || ACI_GAP_SET_ADVERTISING_ENABLE_ENABLED) && !ACI_GAP_SET_ADVERTISING_ENABLE_FORCE_DISABLED
tBleStatus aci_gap_set_advertising_enable_preprocess(uint8_t Enable,
                                                     uint8_t Number_of_Sets,
                                                     Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/* tBleStatus aci_gap_set_advertising_enable(uint8_t Enable,
                                          uint8_t Number_of_Sets,
                                          Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
 */
/* Command len: 1 + 1 + struct_length */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_enable_cp0 *cp0 = (aci_gap_set_advertising_enable_cp0 *)(buffer_in + (0));
  Advertising_Set_Parameters_t Advertising_Set_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->Number_of_Sets > HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t))
  {
    cp0->Number_of_Sets = 0;
    goto fail;
  }
  for (i = 0; i < cp0->Number_of_Sets; i++) {
    packed_Advertising_Set_Parameters_t *Advertising_Set_Parameters_tmp = (packed_Advertising_Set_Parameters_t *)(((uint8_t *)cp0->Advertising_Set_Parameters) + struct_length);
    Advertising_Set_Parameters[i].Advertising_Handle = Advertising_Set_Parameters_tmp->Advertising_Handle;
    struct_length += 1;
    Advertising_Set_Parameters[i].Duration = Advertising_Set_Parameters_tmp->Duration;
    struct_length += 2;
    Advertising_Set_Parameters[i].Max_Extended_Advertising_Events = Advertising_Set_Parameters_tmp->Max_Extended_Advertising_Events;
    struct_length += 1;
  }
  if(buffer_in_length != 1 + 1 + struct_length)
  {
    goto fail;
  }

  *status = aci_gap_set_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                      cp0->Number_of_Sets /* 1 */,
                                                      Advertising_Set_Parameters /* struct_length */);
  if(*status)
    goto fail;

  *status = aci_gap_set_advertising_enable(cp0->Enable /* 1 */,
                                           cp0->Number_of_Sets /* 1 */,
                                           Advertising_Set_Parameters /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xac;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_ADVERTISING_DATA_NWK_ENABLED) || ACI_GAP_SET_ADVERTISING_DATA_NWK_ENABLED) && !ACI_GAP_SET_ADVERTISING_DATA_NWK_FORCE_DISABLED
/* tBleStatus aci_gap_set_advertising_data_nwk(uint8_t Advertising_Handle,
                                            uint8_t Operation,
                                            uint8_t Advertising_Data_Length,
                                            uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_data_nwk_cp0 *cp0 = (aci_gap_set_advertising_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gap_set_advertising_data_nwk(cp0->Advertising_Handle /* 1 */,
                                             cp0->Operation /* 1 */,
                                             cp0->Advertising_Data_Length /* 1 */,
                                             cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xad;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_ENABLED) || ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_ENABLED) && !ACI_GAP_SET_SCAN_RESPONSE_DATA_NWK_FORCE_DISABLED
/* tBleStatus aci_gap_set_scan_response_data_nwk(uint8_t Advertising_Handle,
                                              uint8_t Operation,
                                              uint8_t Scan_Response_Data_Length,
                                              uint8_t Scan_Response_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_scan_response_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_scan_response_data_nwk_cp0 *cp0 = (aci_gap_set_scan_response_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gap_set_scan_response_data_nwk(cp0->Advertising_Handle /* 1 */,
                                               cp0->Operation /* 1 */,
                                               cp0->Scan_Response_Data_Length /* 1 */,
                                               cp0->Scan_Response_Data /* cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xae;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_SCAN_CONFIGURATION_ENABLED) || ACI_GAP_SET_SCAN_CONFIGURATION_ENABLED) && !ACI_GAP_SET_SCAN_CONFIGURATION_FORCE_DISABLED
/* tBleStatus aci_gap_set_scan_configuration(uint8_t Filter_Duplicates,
                                          uint8_t Scanning_Filter_Policy,
                                          uint8_t Scanning_PHY,
                                          uint8_t Scan_Type,
                                          uint16_t Scan_Interval,
                                          uint16_t Scan_Window);
 */
/* Command len: 1 + 1 + 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_set_scan_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_scan_configuration_cp0 *cp0 = (aci_gap_set_scan_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gap_set_scan_configuration(cp0->Filter_Duplicates /* 1 */,
                                           cp0->Scanning_Filter_Policy /* 1 */,
                                           cp0->Scanning_PHY /* 1 */,
                                           cp0->Scan_Type /* 1 */,
                                           cp0->Scan_Interval /* 2 */,
                                           cp0->Scan_Window /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xaf;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_SET_CONNECTION_CONFIGURATION_ENABLED) || ACI_GAP_SET_CONNECTION_CONFIGURATION_ENABLED) && !ACI_GAP_SET_CONNECTION_CONFIGURATION_FORCE_DISABLED
/* tBleStatus aci_gap_set_connection_configuration(uint8_t Initiating_PHY,
                                                uint16_t Connection_Interval_Min,
                                                uint16_t Connection_Interval_Max,
                                                uint16_t Max_Latency,
                                                uint16_t Supervision_Timeout,
                                                uint16_t Min_CE_Length,
                                                uint16_t Max_CE_Length);
 */
/* Command len: 1 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_set_connection_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_connection_configuration_cp0 *cp0 = (aci_gap_set_connection_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gap_set_connection_configuration(cp0->Initiating_PHY /* 1 */,
                                                 cp0->Connection_Interval_Min /* 2 */,
                                                 cp0->Connection_Interval_Max /* 2 */,
                                                 cp0->Max_Latency /* 2 */,
                                                 cp0->Supervision_Timeout /* 2 */,
                                                 cp0->Min_CE_Length /* 2 */,
                                                 cp0->Max_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb0;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_START_PROCEDURE_ENABLED) || ACI_GAP_START_PROCEDURE_ENABLED) && !ACI_GAP_START_PROCEDURE_FORCE_DISABLED
/* tBleStatus aci_gap_start_procedure(uint8_t Procedure_Code,
                                   uint8_t PHYs,
                                   uint16_t Duration,
                                   uint16_t Period);
 */
/* Command len: 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_start_procedure_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_start_procedure_cp0 *cp0 = (aci_gap_start_procedure_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gap_start_procedure(cp0->Procedure_Code /* 1 */,
                                    cp0->PHYs /* 1 */,
                                    cp0->Duration /* 2 */,
                                    cp0->Period /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb1;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_DISCOVER_NAME_ENABLED) || ACI_GAP_DISCOVER_NAME_ENABLED) && !ACI_GAP_DISCOVER_NAME_FORCE_DISABLED
/* tBleStatus aci_gap_discover_name(uint8_t PHYs,
                                 uint8_t Peer_Address_Type,
                                 uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_discover_name_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_discover_name_cp0 *cp0 = (aci_gap_discover_name_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6)
  {
    goto fail;
  }

  *status = aci_gap_discover_name(cp0->PHYs /* 1 */,
                                  cp0->Peer_Address_Type /* 1 */,
                                  cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb2;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) || ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) && !ACI_GAP_ADD_DEVICES_TO_FILTER_ACCEPT_AND_RESOLVING_LIST_FORCE_DISABLED
/* tBleStatus aci_gap_add_devices_to_filter_accept_and_resolving_list(uint8_t Lists,
                                                                   uint8_t Clear_Lists,
                                                                   uint8_t Num_of_List_Entries,
                                                                   List_Entry_t List_Entry[]);
 */
/* Command len: 1 + 1 + 1 + struct_length */
/* Response len: 1 */
uint16_t aci_gap_add_devices_to_filter_accept_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0 *cp0 = (aci_gap_add_devices_to_filter_accept_and_resolving_list_cp0 *)(buffer_in + (0));
  List_Entry_t List_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(List_Entry_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->Num_of_List_Entries > HCI_MAX_PAYLOAD_SIZE/sizeof(List_Entry_t))
  {
    cp0->Num_of_List_Entries = 0;
    goto fail;
  }
  for (i = 0; i < cp0->Num_of_List_Entries; i++) {
    packed_List_Entry_t *List_Entry_tmp = (packed_List_Entry_t *)(((uint8_t *)cp0->List_Entry) + struct_length);
    List_Entry[i].Peer_Address_Type = List_Entry_tmp->Peer_Address_Type;
    struct_length += 1;
    Osal_MemCpy((void *) &List_Entry[i].Peer_Address, (const void *) &cp0->List_Entry[i].Peer_Address, 6);
    struct_length += 6;
  }
  if(buffer_in_length != 1 + 1 + 1 + struct_length)
  {
    goto fail;
  }

  *status = aci_gap_add_devices_to_filter_accept_and_resolving_list(cp0->Lists /* 1 */,
                                                                    cp0->Clear_Lists /* 1 */,
                                                                    cp0->Num_of_List_Entries /* 1 */,
                                                                    List_Entry /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb3;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) || ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_ENABLED) && !ACI_GAP_CONFIGURE_FILTER_ACCEPT_AND_RESOLVING_LIST_FORCE_DISABLED
/* tBleStatus aci_gap_configure_filter_accept_and_resolving_list(uint8_t Lists);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_configure_filter_accept_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_configure_filter_accept_and_resolving_list_cp0 *cp0 = (aci_gap_configure_filter_accept_and_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = aci_gap_configure_filter_accept_and_resolving_list(cp0->Lists /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb4;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_REMOVE_ADVERTISING_SET_ENABLED) || ACI_GAP_REMOVE_ADVERTISING_SET_ENABLED) && !ACI_GAP_REMOVE_ADVERTISING_SET_FORCE_DISABLED
/* tBleStatus aci_gap_remove_advertising_set(uint8_t Advertising_Handle);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_remove_advertising_set_cp0 *cp0 = (aci_gap_remove_advertising_set_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = aci_gap_remove_advertising_set(cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xba;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_CLEAR_ADVERTISING_SETS_ENABLED) || ACI_GAP_CLEAR_ADVERTISING_SETS_ENABLED) && !ACI_GAP_CLEAR_ADVERTISING_SETS_FORCE_DISABLED
/* tBleStatus aci_gap_clear_advertising_sets(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  *status = aci_gap_clear_advertising_sets();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xbb;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_ENABLED) || ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_ENABLED) && !ACI_GAP_CREATE_PERIODIC_ADVERTISING_CONNECTION_FORCE_DISABLED
/* tBleStatus aci_gap_create_periodic_advertising_connection(uint8_t Advertising_Handle,
                                                          uint8_t Subevent,
                                                          uint8_t Initiator_Filter_Policy,
                                                          uint8_t Own_Address_Type,
                                                          uint8_t Peer_Address_Type,
                                                          uint8_t Peer_Address[6],
                                                          uint16_t Connection_Interval_Min,
                                                          uint16_t Connection_Interval_Max,
                                                          uint16_t Max_Latency,
                                                          uint16_t Supervision_Timeout,
                                                          uint16_t Min_CE_Length,
                                                          uint16_t Max_CE_Length);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 6 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_create_periodic_advertising_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_create_periodic_advertising_connection_cp0 *cp0 = (aci_gap_create_periodic_advertising_connection_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 6 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gap_create_periodic_advertising_connection(cp0->Advertising_Handle /* 1 */,
                                                           cp0->Subevent /* 1 */,
                                                           cp0->Initiator_Filter_Policy /* 1 */,
                                                           cp0->Own_Address_Type /* 1 */,
                                                           cp0->Peer_Address_Type /* 1 */,
                                                           cp0->Peer_Address /* 6 */,
                                                           cp0->Connection_Interval_Min /* 2 */,
                                                           cp0->Connection_Interval_Max /* 2 */,
                                                           cp0->Max_Latency /* 2 */,
                                                           cp0->Supervision_Timeout /* 2 */,
                                                           cp0->Min_CE_Length /* 2 */,
                                                           cp0->Max_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xca;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_ENCRYPT_ADV_DATA_NWK_ENABLED) || ACI_GAP_ENCRYPT_ADV_DATA_NWK_ENABLED) && !ACI_GAP_ENCRYPT_ADV_DATA_NWK_FORCE_DISABLED
/* tBleStatus aci_gap_encrypt_adv_data_nwk(uint8_t Session_Key[16],
                                        uint8_t IV[8],
                                        uint8_t Data_Length,
                                        uint8_t Data[],
                                        uint8_t *Encrypted_Data_Length,
                                        uint8_t Encrypted_Data[]);
 */
/* Command len: 16 + 8 + 1 + cp0->Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 1 + rp0->Encrypted_Data_Length * (sizeof(uint8_t)) */
uint16_t aci_gap_encrypt_adv_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_encrypt_adv_data_nwk_cp0 *cp0 = (aci_gap_encrypt_adv_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gap_encrypt_adv_data_nwk_rp0 *rp0 = (aci_gap_encrypt_adv_data_nwk_rp0 *) (buffer_out + 6);
  uint8_t Encrypted_Data_Length = 0;
  uint8_t Encrypted_Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 16 + 8 + 1 + cp0->Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = aci_gap_encrypt_adv_data_nwk(cp0->Session_Key /* 16 */,
                                             cp0->IV /* 8 */,
                                             cp0->Data_Length /* 1 */,
                                             cp0->Data /* cp0->Data_Length * (sizeof(uint8_t)) */,
                                             &Encrypted_Data_Length,
                                             Encrypted_Data);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Encrypted_Data_Length = Encrypted_Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Encrypted_Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Encrypted_Data,(const void *) Encrypted_Data, rp0->Encrypted_Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Encrypted_Data_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xcb;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GAP_DECRYPT_ADV_DATA_NWK_ENABLED) || ACI_GAP_DECRYPT_ADV_DATA_NWK_ENABLED) && !ACI_GAP_DECRYPT_ADV_DATA_NWK_FORCE_DISABLED
/* tBleStatus aci_gap_decrypt_adv_data_nwk(uint8_t Session_Key[16],
                                        uint8_t IV[8],
                                        uint8_t Encrypted_Data_Length,
                                        uint8_t Encrypted_Data[],
                                        uint8_t *Decrypted_Data_Length,
                                        uint8_t Decrypted_Data[]);
 */
/* Command len: 16 + 8 + 1 + cp0->Encrypted_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 1 + rp0->Decrypted_Data_Length * (sizeof(uint8_t)) */
uint16_t aci_gap_decrypt_adv_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_decrypt_adv_data_nwk_cp0 *cp0 = (aci_gap_decrypt_adv_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gap_decrypt_adv_data_nwk_rp0 *rp0 = (aci_gap_decrypt_adv_data_nwk_rp0 *) (buffer_out + 6);
  uint8_t Decrypted_Data_Length = 0;
  uint8_t Decrypted_Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 16 + 8 + 1 + cp0->Encrypted_Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  rp0->Status = aci_gap_decrypt_adv_data_nwk(cp0->Session_Key /* 16 */,
                                             cp0->IV /* 8 */,
                                             cp0->Encrypted_Data_Length /* 1 */,
                                             cp0->Encrypted_Data /* cp0->Encrypted_Data_Length * (sizeof(uint8_t)) */,
                                             &Decrypted_Data_Length,
                                             Decrypted_Data);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Decrypted_Data_Length = Decrypted_Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Decrypted_Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Decrypted_Data,(const void *) Decrypted_Data, rp0->Decrypted_Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Decrypted_Data_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xcc;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_PROFILE_INIT_ENABLED) || ACI_GATT_SRV_PROFILE_INIT_ENABLED) && !ACI_GATT_SRV_PROFILE_INIT_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_profile_init(uint8_t Characteristics,
                                     uint16_t *Service_Changed_Handle);
 */
/* Command len: 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_profile_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_profile_init_cp0 *cp0 = (aci_gatt_srv_profile_init_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_profile_init_rp0 *rp0 = (aci_gatt_srv_profile_init_rp0 *) (buffer_out + 6);
  uint16_t Service_Changed_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_profile_init(cp0->Characteristics /* 1 */,
                                          &Service_Changed_Handle);
fail:
  rp0->Service_Changed_Handle = Service_Changed_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_ADD_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_ADD_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_ADD_SERVICE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_add_service_nwk(uint8_t Service_UUID_Type,
                                        Service_UUID_t *Service_UUID,
                                        uint8_t Service_Type,
                                        uint8_t Max_Attribute_Records,
                                        uint16_t *Service_Handle);
 */
/* Command len: 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_service_nwk_cp0 *cp0 = (aci_gatt_srv_add_service_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_service_nwk_cp1 *cp1 = (aci_gatt_srv_add_service_nwk_cp1 *)(buffer_in + (0 + 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0))));
  Service_UUID_t Service_UUID;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_service_nwk_rp0 *rp0 = (aci_gatt_srv_add_service_nwk_rp0 *) (buffer_out + 6);
  uint16_t Service_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Service_UUID.Service_UUID_16, (const void *) &cp0->Service_UUID.Service_UUID_16, (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_service_nwk(cp0->Service_UUID_Type /* 1 */,
                                             &Service_UUID /* (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) */,
                                             cp1->Service_Type /* 1 */,
                                             cp1->Max_Attribute_Records /* 1 */,
                                             &Service_Handle);
fail:
  rp0->Service_Handle = Service_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_INCLUDE_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_INCLUDE_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_INCLUDE_SERVICE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_include_service_nwk(uint16_t Service_Handle,
                                            uint16_t Included_Service_Handle,
                                            uint16_t *Include_Handle);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_include_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_include_service_nwk_rp0 *rp0 = (aci_gatt_srv_include_service_nwk_rp0 *) (buffer_out + 6);
  uint16_t Include_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_include_service_nwk(cp0->Service_Handle /* 2 */,
                                                 cp0->Included_Service_Handle /* 2 */,
                                                 &Include_Handle);
fail:
  rp0->Include_Handle = Include_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_ADD_CHAR_NWK_ENABLED) || ACI_GATT_SRV_ADD_CHAR_NWK_ENABLED) && !ACI_GATT_SRV_ADD_CHAR_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_add_char_nwk(uint16_t Service_Handle,
                                     uint8_t Char_UUID_Type,
                                     Char_UUID_t *Char_UUID,
                                     uint16_t Char_Value_Length,
                                     uint8_t Char_Properties,
                                     uint8_t Security_Permissions,
                                     uint8_t GATT_Evt_Mask,
                                     uint8_t Enc_Key_Size,
                                     uint8_t Is_Variable,
                                     uint16_t *Char_Handle);
 */
/* Command len: 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) + 2 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_char_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_char_nwk_cp1 *cp1 = (aci_gatt_srv_add_char_nwk_cp1 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0))));
  Char_UUID_t Char_UUID;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_char_nwk_rp0 *rp0 = (aci_gatt_srv_add_char_nwk_rp0 *) (buffer_out + 6);
  uint16_t Char_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Char_UUID.Char_UUID_16, (const void *) &cp0->Char_UUID.Char_UUID_16, (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) + 2 + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_char_nwk(cp0->Service_Handle /* 2 */,
                                          cp0->Char_UUID_Type /* 1 */,
                                          &Char_UUID /* (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) */,
                                          cp1->Char_Value_Length /* 2 */,
                                          cp1->Char_Properties /* 1 */,
                                          cp1->Security_Permissions /* 1 */,
                                          cp1->GATT_Evt_Mask /* 1 */,
                                          cp1->Enc_Key_Size /* 1 */,
                                          cp1->Is_Variable /* 1 */,
                                          &Char_Handle);
fail:
  rp0->Char_Handle = Char_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x04;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_ADD_CHAR_DESC_NWK_ENABLED) || ACI_GATT_SRV_ADD_CHAR_DESC_NWK_ENABLED) && !ACI_GATT_SRV_ADD_CHAR_DESC_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_add_char_desc_nwk(uint16_t Char_Handle,
                                          uint8_t Char_Desc_Uuid_Type,
                                          Char_Desc_Uuid_t *Char_Desc_Uuid,
                                          uint16_t Char_Desc_Value_Max_Len,
                                          uint16_t Char_Desc_Value_Length,
                                          uint8_t Char_Desc_Value[],
                                          uint8_t Security_Permissions,
                                          uint8_t Access_Permissions,
                                          uint8_t GATT_Evt_Mask,
                                          uint8_t Enc_Key_Size,
                                          uint8_t Is_Variable,
                                          uint16_t *Char_Desc_Handle);
 */
/* Command len: 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_char_desc_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_char_desc_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_desc_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_char_desc_nwk_cp1 *cp1 = (aci_gatt_srv_add_char_desc_nwk_cp1 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0))));
  aci_gatt_srv_add_char_desc_nwk_cp2 *cp2 = (aci_gatt_srv_add_char_desc_nwk_cp2 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t))));
  Char_Desc_Uuid_t Char_Desc_Uuid;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_char_desc_nwk_rp0 *rp0 = (aci_gatt_srv_add_char_desc_nwk_rp0 *) (buffer_out + 6);
  uint16_t Char_Desc_Handle = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Char_Desc_Uuid.Char_UUID_16, (const void *) &cp0->Char_Desc_Uuid.Char_UUID_16, (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) + 1 + 1 + 1 + 1 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_char_desc_nwk(cp0->Char_Handle /* 2 */,
                                               cp0->Char_Desc_Uuid_Type /* 1 */,
                                               &Char_Desc_Uuid /* (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) */,
                                               cp1->Char_Desc_Value_Max_Len /* 2 */,
                                               cp1->Char_Desc_Value_Length /* 2 */,
                                               cp1->Char_Desc_Value /* cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) */,
                                               cp2->Security_Permissions /* 1 */,
                                               cp2->Access_Permissions /* 1 */,
                                               cp2->GATT_Evt_Mask /* 1 */,
                                               cp2->Enc_Key_Size /* 1 */,
                                               cp2->Is_Variable /* 1 */,
                                               &Char_Desc_Handle);
fail:
  rp0->Char_Desc_Handle = Char_Desc_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_WRITE_HANDLE_VALUE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_write_handle_value_nwk(uint16_t Attr_Handle,
                                               uint16_t Val_Offset,
                                               uint16_t Value_Length,
                                               uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_write_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_write_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_write_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_srv_write_handle_value_nwk(cp0->Attr_Handle /* 2 */,
                                                cp0->Val_Offset /* 2 */,
                                                cp0->Value_Length /* 2 */,
                                                cp0->Value /* cp0->Value_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x06;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_RM_CHAR_NWK_ENABLED) || ACI_GATT_SRV_RM_CHAR_NWK_ENABLED) && !ACI_GATT_SRV_RM_CHAR_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_rm_char_nwk(uint16_t Char_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_char_nwk_cp0 *cp0 = (aci_gatt_srv_rm_char_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = aci_gatt_srv_rm_char_nwk(cp0->Char_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x07;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_RM_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_RM_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_RM_SERVICE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_rm_service_nwk(uint16_t Serv_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = aci_gatt_srv_rm_service_nwk(cp0->Serv_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x08;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_ENABLED) || ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_ENABLED) && !ACI_GATT_SRV_RM_INCLUDE_SERVICE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_rm_include_service_nwk(uint16_t Include_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_include_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = aci_gatt_srv_rm_include_service_nwk(cp0->Include_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SET_EVENT_MASK_ENABLED) || ACI_GATT_SET_EVENT_MASK_ENABLED) && !ACI_GATT_SET_EVENT_MASK_FORCE_DISABLED
/* tBleStatus aci_gatt_set_event_mask(uint32_t GATT_Evt_Mask);
 */
/* Command len: 4 */
/* Response len: 1 */
uint16_t aci_gatt_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_set_event_mask_cp0 *cp0 = (aci_gatt_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4)
  {
    goto fail;
  }

  *status = aci_gatt_set_event_mask(cp0->GATT_Evt_Mask /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_EXCHANGE_CONFIG_ENABLED) || ACI_GATT_CLT_EXCHANGE_CONFIG_ENABLED) && !ACI_GATT_CLT_EXCHANGE_CONFIG_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_exchange_config(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_exchange_config_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_exchange_config_cp0 *cp0 = (aci_gatt_clt_exchange_config_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_exchange_config(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0b;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_PREPARE_WRITE_REQ_ENABLED) || ACI_GATT_CLT_PREPARE_WRITE_REQ_ENABLED) && !ACI_GATT_CLT_PREPARE_WRITE_REQ_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_prepare_write_req(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint16_t Attr_Handle,
                                          uint16_t Val_Offset,
                                          uint16_t Attribute_Val_Length,
                                          uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_prepare_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_prepare_write_req_cp0 *cp0 = (aci_gatt_clt_prepare_write_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_prepare_write_req(cp0->Connection_Handle /* 2 */,
                                           cp0->CID /* 2 */,
                                           cp0->Attr_Handle /* 2 */,
                                           cp0->Val_Offset /* 2 */,
                                           cp0->Attribute_Val_Length /* 2 */,
                                           cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x10;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_EXECUTE_WRITE_REQ_ENABLED) || ACI_GATT_CLT_EXECUTE_WRITE_REQ_ENABLED) && !ACI_GATT_CLT_EXECUTE_WRITE_REQ_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_execute_write_req(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint8_t Execute);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_clt_execute_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_execute_write_req_cp0 *cp0 = (aci_gatt_clt_execute_write_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    goto fail;
  }

  *status = aci_gatt_clt_execute_write_req(cp0->Connection_Handle /* 2 */,
                                           cp0->CID /* 2 */,
                                           cp0->Execute /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x11;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_ENABLED) || ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_ENABLED) && !ACI_GATT_CLT_DISC_ALL_PRIMARY_SERVICES_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_disc_all_primary_services(uint16_t Connection_Handle,
                                                  uint16_t CID);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_primary_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_primary_services_cp0 *cp0 = (aci_gatt_clt_disc_all_primary_services_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_primary_services(cp0->Connection_Handle /* 2 */,
                                                   cp0->CID /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x12;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_ENABLED) || ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_ENABLED) && !ACI_GATT_CLT_DISC_PRIMARY_SERVICE_BY_UUID_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_disc_primary_service_by_uuid(uint16_t Connection_Handle,
                                                     uint16_t CID,
                                                     uint8_t UUID_Type,
                                                     UUID_t *UUID);
 */
/* Command len: 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_primary_service_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_primary_service_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_primary_service_by_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_disc_primary_service_by_uuid(cp0->Connection_Handle /* 2 */,
                                                      cp0->CID /* 2 */,
                                                      cp0->UUID_Type /* 1 */,
                                                      &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x13;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_FIND_INCLUDED_SERVICES_ENABLED) || ACI_GATT_CLT_FIND_INCLUDED_SERVICES_ENABLED) && !ACI_GATT_CLT_FIND_INCLUDED_SERVICES_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_find_included_services(uint16_t Connection_Handle,
                                               uint16_t CID,
                                               uint16_t Start_Handle,
                                               uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_find_included_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_find_included_services_cp0 *cp0 = (aci_gatt_clt_find_included_services_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_find_included_services(cp0->Connection_Handle /* 2 */,
                                                cp0->CID /* 2 */,
                                                cp0->Start_Handle /* 2 */,
                                                cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x14;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_ENABLED) || ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_ENABLED) && !ACI_GATT_CLT_DISC_ALL_CHAR_OF_SERVICE_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_disc_all_char_of_service(uint16_t Connection_Handle,
                                                 uint16_t CID,
                                                 uint16_t Start_Handle,
                                                 uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_char_of_service_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_char_of_service_cp0 *cp0 = (aci_gatt_clt_disc_all_char_of_service_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_char_of_service(cp0->Connection_Handle /* 2 */,
                                                  cp0->CID /* 2 */,
                                                  cp0->Start_Handle /* 2 */,
                                                  cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x15;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_DISC_CHAR_BY_UUID_ENABLED) || ACI_GATT_CLT_DISC_CHAR_BY_UUID_ENABLED) && !ACI_GATT_CLT_DISC_CHAR_BY_UUID_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_disc_char_by_uuid(uint16_t Connection_Handle,
                                          uint16_t CID,
                                          uint16_t Start_Handle,
                                          uint16_t End_Handle,
                                          uint8_t UUID_Type,
                                          UUID_t *UUID);
 */
/* Command len: 2 + 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_char_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_char_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_char_by_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_disc_char_by_uuid(cp0->Connection_Handle /* 2 */,
                                           cp0->CID /* 2 */,
                                           cp0->Start_Handle /* 2 */,
                                           cp0->End_Handle /* 2 */,
                                           cp0->UUID_Type /* 1 */,
                                           &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x16;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_DISC_ALL_CHAR_DESC_ENABLED) || ACI_GATT_CLT_DISC_ALL_CHAR_DESC_ENABLED) && !ACI_GATT_CLT_DISC_ALL_CHAR_DESC_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_disc_all_char_desc(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t Char_Handle,
                                           uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_char_desc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_char_desc_cp0 *cp0 = (aci_gatt_clt_disc_all_char_desc_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_char_desc(cp0->Connection_Handle /* 2 */,
                                            cp0->CID /* 2 */,
                                            cp0->Char_Handle /* 2 */,
                                            cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x17;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_READ_ENABLED) || ACI_GATT_CLT_READ_ENABLED) && !ACI_GATT_CLT_READ_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_read(uint16_t Connection_Handle,
                             uint16_t CID,
                             uint16_t Attr_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_cp0 *cp0 = (aci_gatt_clt_read_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_read(cp0->Connection_Handle /* 2 */,
                              cp0->CID /* 2 */,
                              cp0->Attr_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x18;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_READ_USING_CHAR_UUID_ENABLED) || ACI_GATT_CLT_READ_USING_CHAR_UUID_ENABLED) && !ACI_GATT_CLT_READ_USING_CHAR_UUID_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_read_using_char_uuid(uint16_t Connection_Handle,
                                             uint16_t CID,
                                             uint16_t Start_Handle,
                                             uint16_t End_Handle,
                                             uint8_t UUID_Type,
                                             UUID_t *UUID);
 */
/* Command len: 2 + 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_using_char_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_using_char_uuid_cp0 *cp0 = (aci_gatt_clt_read_using_char_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_read_using_char_uuid(cp0->Connection_Handle /* 2 */,
                                              cp0->CID /* 2 */,
                                              cp0->Start_Handle /* 2 */,
                                              cp0->End_Handle /* 2 */,
                                              cp0->UUID_Type /* 1 */,
                                              &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x19;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_READ_LONG_ENABLED) || ACI_GATT_CLT_READ_LONG_ENABLED) && !ACI_GATT_CLT_READ_LONG_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_read_long(uint16_t Connection_Handle,
                                  uint16_t CID,
                                  uint16_t Attr_Handle,
                                  uint16_t Val_Offset);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_long_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_long_cp0 *cp0 = (aci_gatt_clt_read_long_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_read_long(cp0->Connection_Handle /* 2 */,
                                   cp0->CID /* 2 */,
                                   cp0->Attr_Handle /* 2 */,
                                   cp0->Val_Offset /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1a;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_ENABLED) || ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_ENABLED) && !ACI_GATT_CLT_READ_MULTIPLE_CHAR_VALUE_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_read_multiple_char_value(uint16_t Connection_Handle,
                                                 uint16_t CID,
                                                 uint8_t Number_of_Handles,
                                                 uint16_t Handle[]);
 */
/* Command len: 2 + 2 + 1 + cp0->Number_of_Handles * (sizeof(uint16_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_multiple_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_multiple_char_value_cp0 *cp0 = (aci_gatt_clt_read_multiple_char_value_cp0 *)(buffer_in + (0));
  uint16_t Handle[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy(Handle, cp0->Handle, cp0->Number_of_Handles * (sizeof(uint16_t)));
  if(buffer_in_length != 2 + 2 + 1 + cp0->Number_of_Handles * (sizeof(uint16_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_read_multiple_char_value(cp0->Connection_Handle /* 2 */,
                                                  cp0->CID /* 2 */,
                                                  cp0->Number_of_Handles /* 1 */,
                                                  Handle /* cp0->Number_of_Handles * (sizeof(uint16_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1b;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_WRITE_NWK_ENABLED) || ACI_GATT_CLT_WRITE_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_write_nwk(uint16_t Connection_Handle,
                                  uint16_t CID,
                                  uint16_t Attr_Handle,
                                  uint16_t Attribute_Val_Length,
                                  uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_nwk_cp0 *cp0 = (aci_gatt_clt_write_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_write_nwk(cp0->Connection_Handle /* 2 */,
                                   cp0->CID /* 2 */,
                                   cp0->Attr_Handle /* 2 */,
                                   cp0->Attribute_Val_Length /* 2 */,
                                   cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1c;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_WRITE_LONG_NWK_ENABLED) || ACI_GATT_CLT_WRITE_LONG_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_LONG_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_write_long_nwk(uint16_t Connection_Handle,
                                       uint16_t CID,
                                       uint16_t Attr_Handle,
                                       uint16_t Val_Offset,
                                       uint16_t Attribute_Val_Length,
                                       uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_long_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_long_nwk_cp0 *cp0 = (aci_gatt_clt_write_long_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_write_long_nwk(cp0->Connection_Handle /* 2 */,
                                        cp0->CID /* 2 */,
                                        cp0->Attr_Handle /* 2 */,
                                        cp0->Val_Offset /* 2 */,
                                        cp0->Attribute_Val_Length /* 2 */,
                                        cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1d;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_ENABLED) || ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_ENABLED) && !ACI_GATT_CLT_WRITE_CHAR_RELIABLE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_write_char_reliable_nwk(uint16_t Connection_Handle,
                                                uint16_t CID,
                                                uint16_t Attr_Handle,
                                                uint16_t Val_Offset,
                                                uint16_t Attribute_Val_Length,
                                                uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_char_reliable_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_char_reliable_nwk_cp0 *cp0 = (aci_gatt_clt_write_char_reliable_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_write_char_reliable_nwk(cp0->Connection_Handle /* 2 */,
                                                 cp0->CID /* 2 */,
                                                 cp0->Attr_Handle /* 2 */,
                                                 cp0->Val_Offset /* 2 */,
                                                 cp0->Attribute_Val_Length /* 2 */,
                                                 cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1e;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_WRITE_WITHOUT_RESP_ENABLED) || ACI_GATT_CLT_WRITE_WITHOUT_RESP_ENABLED) && !ACI_GATT_CLT_WRITE_WITHOUT_RESP_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_write_without_resp(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t Attr_Handle,
                                           uint16_t Attribute_Val_Length,
                                           uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_without_resp_cp0 *cp0 = (aci_gatt_clt_write_without_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_write_without_resp(cp0->Connection_Handle /* 2 */,
                                            cp0->CID /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Attribute_Val_Length /* 2 */,
                                            cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x23;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_ENABLED) || ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_ENABLED) && !ACI_GATT_CLT_SIGNED_WRITE_WITHOUT_RESP_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_signed_write_without_resp(uint16_t Connection_Handle,
                                                  uint16_t Attr_Handle,
                                                  uint16_t Attribute_Val_Length,
                                                  uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_signed_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_signed_write_without_resp_cp0 *cp0 = (aci_gatt_clt_signed_write_without_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_signed_write_without_resp(cp0->Connection_Handle /* 2 */,
                                                   cp0->Attr_Handle /* 2 */,
                                                   cp0->Attribute_Val_Length /* 2 */,
                                                   cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x24;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_CONFIRM_INDICATION_ENABLED) || ACI_GATT_CLT_CONFIRM_INDICATION_ENABLED) && !ACI_GATT_CLT_CONFIRM_INDICATION_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_confirm_indication(uint16_t Connection_Handle,
                                           uint16_t CID);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_confirm_indication_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_confirm_indication_cp0 *cp0 = (aci_gatt_clt_confirm_indication_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  *status = aci_gatt_clt_confirm_indication(cp0->Connection_Handle /* 2 */,
                                            cp0->CID /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x25;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_ENABLED) || ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_ENABLED) && !ACI_GATT_SRV_SET_SECURITY_PERMISSION_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_set_security_permission_nwk(uint16_t Attr_Handle,
                                                    uint8_t Security_Permissions);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_set_security_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_set_security_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_security_permission_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gatt_srv_set_security_permission_nwk(cp0->Attr_Handle /* 2 */,
                                                     cp0->Security_Permissions /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x28;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_HANDLE_VALUE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_read_handle_value_nwk(uint16_t Attr_Handle,
                                              uint16_t Offset,
                                              uint16_t Value_Length_Requested,
                                              uint16_t *Length,
                                              uint16_t *Value_Length,
                                              uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_read_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_handle_value_nwk_rp0 *rp0 = (aci_gatt_srv_read_handle_value_nwk_rp0 *) (buffer_out + 6);
  uint16_t Length = 0;
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_handle_value_nwk(cp0->Attr_Handle /* 2 */,
                                                   cp0->Offset /* 2 */,
                                                   cp0->Value_Length_Requested /* 2 */,
                                                   &Length,
                                                   &Value_Length,
                                                   Value);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Length = Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_ENABLED) || ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_ENABLED) && !ACI_GATT_SRV_SET_ACCESS_PERMISSION_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_set_access_permission_nwk(uint16_t Attr_Handle,
                                                  uint8_t Access_Permissions);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_set_access_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_set_access_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_access_permission_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  *status = aci_gatt_srv_set_access_permission_nwk(cp0->Attr_Handle /* 2 */,
                                                   cp0->Access_Permissions /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2e;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_NOTIFY_ENABLED) || ACI_GATT_SRV_NOTIFY_ENABLED) && !ACI_GATT_SRV_NOTIFY_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_notify(uint16_t Connection_Handle,
                               uint16_t CID,
                               uint16_t Attr_Handle,
                               uint8_t Flags,
                               uint16_t Val_Length,
                               uint8_t Val[]);
 */
/* Command len: 2 + 2 + 2 + 1 + 2 + cp0->Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_notify_cp0 *cp0 = (aci_gatt_srv_notify_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 1 + 2 + cp0->Val_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_srv_notify(cp0->Connection_Handle /* 2 */,
                                cp0->CID /* 2 */,
                                cp0->Attr_Handle /* 2 */,
                                cp0->Flags /* 1 */,
                                cp0->Val_Length /* 2 */,
                                cp0->Val /* cp0->Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2f;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_ENABLED) || ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_ENABLED) && !ACI_GATT_SRV_EXEC_WRITE_RESP_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_exec_write_resp_nwk(uint16_t Conn_Handle,
                                            uint16_t CID,
                                            uint8_t Exec);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_exec_write_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_exec_write_resp_nwk_cp0 *cp0 = (aci_gatt_srv_exec_write_resp_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    goto fail;
  }

  *status = aci_gatt_srv_exec_write_resp_nwk(cp0->Conn_Handle /* 2 */,
                                             cp0->CID /* 2 */,
                                             cp0->Exec /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x31;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_AUTHORIZE_RESP_NWK_ENABLED) || ACI_GATT_SRV_AUTHORIZE_RESP_NWK_ENABLED) && !ACI_GATT_SRV_AUTHORIZE_RESP_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_authorize_resp_nwk(uint16_t Conn_Handle,
                                           uint16_t CID,
                                           uint16_t Attr_Handle,
                                           uint8_t Operation_Type,
                                           uint8_t Error_Code,
                                           uint16_t Attr_Val_Offset,
                                           uint16_t Data_Length,
                                           uint8_t Data[]);
 */
/* Command len: 2 + 2 + 2 + 1 + 1 + 2 + 2 + cp0->Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_authorize_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_authorize_resp_nwk_cp0 *cp0 = (aci_gatt_srv_authorize_resp_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 1 + 1 + 2 + 2 + cp0->Data_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_srv_authorize_resp_nwk(cp0->Conn_Handle /* 2 */,
                                            cp0->CID /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Operation_Type /* 1 */,
                                            cp0->Error_Code /* 1 */,
                                            cp0->Attr_Val_Offset /* 2 */,
                                            cp0->Data_Length /* 2 */,
                                            cp0->Data /* cp0->Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x33;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_ENABLED) || ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_PREPARE_QUEUE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_read_prepare_queue_nwk(uint16_t Conn_Handle,
                                               uint8_t Item_Index,
                                               uint16_t *Attr_Handle,
                                               uint16_t *Value_Offset,
                                               uint16_t *Value_Length,
                                               uint8_t Value[]);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 2 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_prepare_queue_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_prepare_queue_nwk_cp0 *cp0 = (aci_gatt_srv_read_prepare_queue_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_prepare_queue_nwk_rp0 *rp0 = (aci_gatt_srv_read_prepare_queue_nwk_rp0 *) (buffer_out + 6);
  uint16_t Attr_Handle = 0;
  uint16_t Value_Offset = 0;
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_prepare_queue_nwk(cp0->Conn_Handle /* 2 */,
                                                    cp0->Item_Index /* 1 */,
                                                    &Attr_Handle,
                                                    &Value_Offset,
                                                    &Value_Length,
                                                    Value);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Attr_Handle = Attr_Handle;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Offset = Value_Offset;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_ENABLED) || ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_ENABLED) && !ACI_GATT_SRV_WRITE_MULTIPLE_INSTANCE_HANDLE_VALUE_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_write_multiple_instance_handle_value(uint16_t Connection_Handle,
                                                             uint16_t Attr_Handle,
                                                             uint16_t Value_Length,
                                                             uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_write_multiple_instance_handle_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_write_multiple_instance_handle_value_cp0 *cp0 = (aci_gatt_srv_write_multiple_instance_handle_value_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_gatt_srv_write_multiple_instance_handle_value(cp0->Connection_Handle /* 2 */,
                                                              cp0->Attr_Handle /* 2 */,
                                                              cp0->Value_Length /* 2 */,
                                                              cp0->Value /* cp0->Value_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_ENABLED) || ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_ENABLED) && !ACI_GATT_SRV_READ_MULTIPLE_INSTANCE_HANDLE_VALUE_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_read_multiple_instance_handle_value_nwk(uint16_t Connection_Handle,
                                                                uint16_t Attr_Handle,
                                                                uint16_t *Value_Length,
                                                                uint8_t Value[]);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_multiple_instance_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0 *rp0 = (aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0 *) (buffer_out + 6);
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_multiple_instance_handle_value_nwk(cp0->Connection_Handle /* 2 */,
                                                                     cp0->Attr_Handle /* 2 */,
                                                                     &Value_Length,
                                                                     Value);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_SRV_MULTI_NOTIFY_ENABLED) || ACI_GATT_SRV_MULTI_NOTIFY_ENABLED) && !ACI_GATT_SRV_MULTI_NOTIFY_FORCE_DISABLED
/* tBleStatus aci_gatt_srv_multi_notify(uint16_t Connection_Handle,
                                     uint16_t CID,
                                     uint8_t Flags,
                                     uint8_t Num_Of_Attr,
                                     Gatt_Srv_Notify_Attr_t Gatt_Srv_Notify_Attr[]);
 */
/* Command len: 2 + 2 + 1 + 1 + struct_length */
/* Response len: 1 */
uint16_t aci_gatt_srv_multi_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_multi_notify_cp0 *cp0 = (aci_gatt_srv_multi_notify_cp0 *)(buffer_in + (0));
  Gatt_Srv_Notify_Attr_t Gatt_Srv_Notify_Attr[HCI_MAX_PAYLOAD_SIZE/sizeof(Gatt_Srv_Notify_Attr_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int struct_length = 0;
  if(cp0->Num_Of_Attr > HCI_MAX_PAYLOAD_SIZE/sizeof(Gatt_Srv_Notify_Attr_t))
  {
    cp0->Num_Of_Attr = 0;
    goto fail;
  }
  for (i = 0; i < cp0->Num_Of_Attr; i++) {
    packed_Gatt_Srv_Notify_Attr_t *Gatt_Srv_Notify_Attr_tmp = (packed_Gatt_Srv_Notify_Attr_t *)(((uint8_t *)cp0->Gatt_Srv_Notify_Attr) + struct_length);
    Gatt_Srv_Notify_Attr[i].Handle = Gatt_Srv_Notify_Attr_tmp->Handle;
    struct_length += 2;
    Gatt_Srv_Notify_Attr[i].Val_Length = Gatt_Srv_Notify_Attr_tmp->Val_Length;
    struct_length += 2;
    Gatt_Srv_Notify_Attr[i].Val = Gatt_Srv_Notify_Attr_tmp->Val;
    struct_length += Gatt_Srv_Notify_Attr_tmp->Val_Length;
  }
  if(buffer_in_length != 2 + 2 + 1 + 1 + struct_length)
  {
    goto fail;
  }

  *status = aci_gatt_srv_multi_notify(cp0->Connection_Handle /* 2 */,
                                      cp0->CID /* 2 */,
                                      cp0->Flags /* 1 */,
                                      cp0->Num_Of_Attr /* 1 */,
                                      Gatt_Srv_Notify_Attr /* struct_length */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x38;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_ENABLED) || ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_ENABLED) && !ACI_GATT_CLT_READ_MULTIPLE_VAR_LEN_CHAR_VALUE_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_read_multiple_var_len_char_value(uint16_t Connection_Handle,
                                                         uint16_t CID,
                                                         uint8_t Number_of_Handles,
                                                         uint16_t Handle[]);
 */
/* Command len: 2 + 2 + 1 + cp0->Number_of_Handles * (sizeof(uint16_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_multiple_var_len_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_multiple_var_len_char_value_cp0 *cp0 = (aci_gatt_clt_read_multiple_var_len_char_value_cp0 *)(buffer_in + (0));
  uint16_t Handle[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy(Handle, cp0->Handle, cp0->Number_of_Handles * (sizeof(uint16_t)));
  if(buffer_in_length != 2 + 2 + 1 + cp0->Number_of_Handles * (sizeof(uint16_t)))
  {
    goto fail;
  }

  *status = aci_gatt_clt_read_multiple_var_len_char_value(cp0->Connection_Handle /* 2 */,
                                                          cp0->CID /* 2 */,
                                                          cp0->Number_of_Handles /* 1 */,
                                                          Handle /* cp0->Number_of_Handles * (sizeof(uint16_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x39;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_ENABLED) || ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_ENABLED) && !ACI_GATT_CLT_ADD_SUBSCRIPTION_SECURITY_LEVEL_NWK_FORCE_DISABLED
/* tBleStatus aci_gatt_clt_add_subscription_security_level_nwk(uint16_t Conn_Handle,
                                                            uint16_t Char_Value_Handle,
                                                            uint8_t Sec_Level);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_clt_add_subscription_security_level_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_add_subscription_security_level_nwk_cp0 *cp0 = (aci_gatt_clt_add_subscription_security_level_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    goto fail;
  }

  *status = aci_gatt_clt_add_subscription_security_level_nwk(cp0->Conn_Handle /* 2 */,
                                                             cp0->Char_Value_Handle /* 2 */,
                                                             cp0->Sec_Level /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_ENABLED) || ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_ENABLED) && !ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_FORCE_DISABLED
/* tBleStatus aci_l2cap_connection_parameter_update_req(uint16_t Connection_Handle,
                                                     uint16_t Connection_Interval_Min,
                                                     uint16_t Connection_Interval_Max,
                                                     uint16_t Peripheral_Latency,
                                                     uint16_t Timeout_Multiplier);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_l2cap_connection_parameter_update_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_connection_parameter_update_req_cp0 *cp0 = (aci_l2cap_connection_parameter_update_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_l2cap_connection_parameter_update_req(cp0->Connection_Handle /* 2 */,
                                                      cp0->Connection_Interval_Min /* 2 */,
                                                      cp0->Connection_Interval_Max /* 2 */,
                                                      cp0->Peripheral_Latency /* 2 */,
                                                      cp0->Timeout_Multiplier /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x81;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_ENABLED) || ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_ENABLED) && !ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_FORCE_DISABLED
/* tBleStatus aci_l2cap_connection_parameter_update_resp(uint16_t Connection_Handle,
                                                      uint16_t Connection_Interval_Min,
                                                      uint16_t Connection_Interval_Max,
                                                      uint16_t Peripheral_Latency,
                                                      uint16_t Timeout_Multiplier,
                                                      uint16_t Min_CE_Length,
                                                      uint16_t Max_CE_Length,
                                                      uint8_t Identifier,
                                                      uint8_t Accept);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_l2cap_connection_parameter_update_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_connection_parameter_update_resp_cp0 *cp0 = (aci_l2cap_connection_parameter_update_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_l2cap_connection_parameter_update_resp(cp0->Connection_Handle /* 2 */,
                                                       cp0->Connection_Interval_Min /* 2 */,
                                                       cp0->Connection_Interval_Max /* 2 */,
                                                       cp0->Peripheral_Latency /* 2 */,
                                                       cp0->Timeout_Multiplier /* 2 */,
                                                       cp0->Min_CE_Length /* 2 */,
                                                       cp0->Max_CE_Length /* 2 */,
                                                       cp0->Identifier /* 1 */,
                                                       cp0->Accept /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x82;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_CONNECTION_REQ_ENABLED) || ACI_L2CAP_COS_CONNECTION_REQ_ENABLED) && !ACI_L2CAP_COS_CONNECTION_REQ_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_connection_req(uint16_t Connection_Handle,
                                        uint16_t SPSM,
                                        uint16_t MTU,
                                        uint16_t MPS,
                                        uint8_t Channel_Type,
                                        uint8_t CID_Count);
 */
/* Command len: 2 + 2 + 2 + 2 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_l2cap_cos_connection_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_connection_req_cp0 *cp0 = (aci_l2cap_cos_connection_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 1 + 1)
  {
    goto fail;
  }

  *status = aci_l2cap_cos_connection_req(cp0->Connection_Handle /* 2 */,
                                         cp0->SPSM /* 2 */,
                                         cp0->MTU /* 2 */,
                                         cp0->MPS /* 2 */,
                                         cp0->Channel_Type /* 1 */,
                                         cp0->CID_Count /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x83;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_CONNECTION_RESP_ENABLED) || ACI_L2CAP_COS_CONNECTION_RESP_ENABLED) && !ACI_L2CAP_COS_CONNECTION_RESP_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_connection_resp(uint16_t Connection_Handle,
                                         uint8_t Identifier,
                                         uint16_t MTU,
                                         uint16_t MPS,
                                         uint16_t Result,
                                         uint8_t CID_Count,
                                         uint16_t CID[]);
 */
/* Command len: 2 + 1 + 2 + 2 + 2 + 1 */
/* Response len: 1 + 1 + rp0->CID_Count * (sizeof(uint16_t)) */
uint16_t aci_l2cap_cos_connection_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_connection_resp_cp0 *cp0 = (aci_l2cap_cos_connection_resp_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_l2cap_cos_connection_resp_rp0 *rp0 = (aci_l2cap_cos_connection_resp_rp0 *) (buffer_out + 6);
  uint16_t CID[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)] = {0};

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 2 + 2 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_l2cap_cos_connection_resp(cp0->Connection_Handle /* 2 */,
                                              cp0->Identifier /* 1 */,
                                              cp0->MTU /* 2 */,
                                              cp0->MPS /* 2 */,
                                              cp0->Result /* 2 */,
                                              cp0->CID_Count /* 1 */,
                                              CID);
fail:
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->CID_Count = cp0->CID_Count;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->CID_Count * (sizeof(uint16_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->CID,(const void *) CID, rp0->CID_Count * (sizeof(uint16_t)));
  output_size += rp0->CID_Count * (sizeof(uint16_t));
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x84;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_ENABLED) || ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_ENABLED) && !ACI_L2CAP_COS_FLOW_CONTROL_CREDITS_IND_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_flow_control_credits_ind(uint16_t Connection_Handle,
                                                  uint16_t CID,
                                                  uint16_t RX_Credits,
                                                  uint8_t CFC_Policy,
                                                  uint16_t *RX_Credit_Balance);
 */
/* Command len: 2 + 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_l2cap_cos_flow_control_credits_ind_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_flow_control_credits_ind_cp0 *cp0 = (aci_l2cap_cos_flow_control_credits_ind_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_l2cap_cos_flow_control_credits_ind_rp0 *rp0 = (aci_l2cap_cos_flow_control_credits_ind_rp0 *) (buffer_out + 6);
  uint16_t RX_Credit_Balance = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 1)
  {
    goto fail;
  }

  rp0->Status = aci_l2cap_cos_flow_control_credits_ind(cp0->Connection_Handle /* 2 */,
                                                       cp0->CID /* 2 */,
                                                       cp0->RX_Credits /* 2 */,
                                                       cp0->CFC_Policy /* 1 */,
                                                       &RX_Credit_Balance);
fail:
  rp0->RX_Credit_Balance = RX_Credit_Balance;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x85;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_DISCONNECT_REQ_ENABLED) || ACI_L2CAP_COS_DISCONNECT_REQ_ENABLED) && !ACI_L2CAP_COS_DISCONNECT_REQ_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_disconnect_req(uint16_t Connection_Handle,
                                        uint16_t CID);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t aci_l2cap_cos_disconnect_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_disconnect_req_cp0 *cp0 = (aci_l2cap_cos_disconnect_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    goto fail;
  }

  *status = aci_l2cap_cos_disconnect_req(cp0->Connection_Handle /* 2 */,
                                         cp0->CID /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x86;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_SDU_DATA_TRANSMIT_ENABLED) || ACI_L2CAP_COS_SDU_DATA_TRANSMIT_ENABLED) && !ACI_L2CAP_COS_SDU_DATA_TRANSMIT_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_sdu_data_transmit(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t SDU_Length,
                                           uint8_t SDU_Data[]);
 */
/* Command len: 2 + 2 + 2 + cp0->SDU_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_l2cap_cos_sdu_data_transmit_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_sdu_data_transmit_cp0 *cp0 = (aci_l2cap_cos_sdu_data_transmit_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->SDU_Length * (sizeof(uint8_t)))
  {
    goto fail;
  }

  *status = aci_l2cap_cos_sdu_data_transmit(cp0->Connection_Handle /* 2 */,
                                            cp0->CID /* 2 */,
                                            cp0->SDU_Length /* 2 */,
                                            cp0->SDU_Data /* cp0->SDU_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x87;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_RECONFIGURE_REQ_ENABLED) || ACI_L2CAP_COS_RECONFIGURE_REQ_ENABLED) && !ACI_L2CAP_COS_RECONFIGURE_REQ_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_reconfigure_req(uint16_t Connection_Handle,
                                         uint16_t MTU,
                                         uint16_t MPS,
                                         uint8_t CID_Count,
                                         uint16_t CID[]);
 */
/* Command len: 2 + 2 + 2 + 1 + cp0->CID_Count * (sizeof(uint16_t)) */
/* Response len: 1 */
uint16_t aci_l2cap_cos_reconfigure_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_reconfigure_req_cp0 *cp0 = (aci_l2cap_cos_reconfigure_req_cp0 *)(buffer_in + (0));
  uint16_t CID[HCI_MAX_PAYLOAD_SIZE/sizeof(uint16_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy(CID, cp0->CID, cp0->CID_Count * (sizeof(uint16_t)));
  if(buffer_in_length != 2 + 2 + 2 + 1 + cp0->CID_Count * (sizeof(uint16_t)))
  {
    goto fail;
  }

  *status = aci_l2cap_cos_reconfigure_req(cp0->Connection_Handle /* 2 */,
                                          cp0->MTU /* 2 */,
                                          cp0->MPS /* 2 */,
                                          cp0->CID_Count /* 1 */,
                                          CID /* cp0->CID_Count * (sizeof(uint16_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x8a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_L2CAP_COS_RECONFIGURE_RESP_ENABLED) || ACI_L2CAP_COS_RECONFIGURE_RESP_ENABLED) && !ACI_L2CAP_COS_RECONFIGURE_RESP_FORCE_DISABLED
/* tBleStatus aci_l2cap_cos_reconfigure_resp(uint16_t Connection_Handle,
                                          uint8_t Identifier,
                                          uint16_t Result);
 */
/* Command len: 2 + 1 + 2 */
/* Response len: 1 */
uint16_t aci_l2cap_cos_reconfigure_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cos_reconfigure_resp_cp0 *cp0 = (aci_l2cap_cos_reconfigure_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2)
  {
    goto fail;
  }

  *status = aci_l2cap_cos_reconfigure_resp(cp0->Connection_Handle /* 2 */,
                                           cp0->Identifier /* 1 */,
                                           cp0->Result /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x8b;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_TEST_TX_NOTIFICATION_START_ENABLED) || ACI_TEST_TX_NOTIFICATION_START_ENABLED) && !ACI_TEST_TX_NOTIFICATION_START_FORCE_DISABLED
/* tBleStatus aci_test_tx_notification_start(uint16_t Connection_Handle,
                                          uint16_t Service_Handle,
                                          uint16_t Char_Handle,
                                          uint16_t Value_Length);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_test_tx_notification_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_tx_notification_start_cp0 *cp0 = (aci_test_tx_notification_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_test_tx_notification_start(cp0->Connection_Handle /* 2 */,
                                           cp0->Service_Handle /* 2 */,
                                           cp0->Char_Handle /* 2 */,
                                           cp0->Value_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x00;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_TEST_TX_WRITE_COMMAND_START_ENABLED) || ACI_TEST_TX_WRITE_COMMAND_START_ENABLED) && !ACI_TEST_TX_WRITE_COMMAND_START_FORCE_DISABLED
/* tBleStatus aci_test_tx_write_command_start(uint16_t Connection_Handle,
                                           uint16_t Attr_Handle,
                                           uint16_t Value_Length);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_test_tx_write_command_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_tx_write_command_start_cp0 *cp0 = (aci_test_tx_write_command_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    goto fail;
  }

  *status = aci_test_tx_write_command_start(cp0->Connection_Handle /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Value_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_TEST_RX_START_ENABLED) || ACI_TEST_RX_START_ENABLED) && !ACI_TEST_RX_START_FORCE_DISABLED
/* tBleStatus aci_test_rx_start(uint16_t Connection_Handle,
                             uint16_t Attr_Handle,
                             uint8_t Notifications_WriteCmds);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_test_rx_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_rx_start_cp0 *cp0 = (aci_test_rx_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    goto fail;
  }

  *status = aci_test_rx_start(cp0->Connection_Handle /* 2 */,
                              cp0->Attr_Handle /* 2 */,
                              cp0->Notifications_WriteCmds /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_TEST_STOP_ENABLED) || ACI_TEST_STOP_ENABLED) && !ACI_TEST_STOP_FORCE_DISABLED
/* tBleStatus aci_test_stop(uint8_t TX_RX);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_test_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_stop_cp0 *cp0 = (aci_test_stop_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    goto fail;
  }

  *status = aci_test_stop(cp0->TX_RX /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
#endif

#if (!defined(ACI_TEST_REPORT_ENABLED) || ACI_TEST_REPORT_ENABLED) && !ACI_TEST_REPORT_FORCE_DISABLED
/* tBleStatus aci_test_report(uint32_t *TX_Packets,
                           uint32_t *RX_Packets,
                           uint16_t *RX_Data_Length,
                           uint32_t *RX_Sequence_Errors);
 */
/* Command len: 0 */
/* Response len: 1 + 4 + 4 + 2 + 4 */
uint16_t aci_test_report_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 4 + 4 + 2 + 4;
  /* Output params */
  aci_test_report_rp0 *rp0 = (aci_test_report_rp0 *) (buffer_out + 6);
  uint32_t TX_Packets = 0;
  uint32_t RX_Packets = 0;
  uint16_t RX_Data_Length = 0;
  uint32_t RX_Sequence_Errors = 0;

  rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
  if (buffer_out_max_length < (1 + 4 + 4 + 2 + 4 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    goto fail;
  }

  rp0->Status = aci_test_report(&TX_Packets,
                                &RX_Packets,
                                &RX_Data_Length,
                                &RX_Sequence_Errors);
fail:
  rp0->TX_Packets = TX_Packets;
  rp0->RX_Packets = RX_Packets;
  rp0->RX_Data_Length = RX_Data_Length;
  rp0->RX_Sequence_Errors = RX_Sequence_Errors;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x04;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
#endif

#endif /* if BLESTACK_CONTROLLER_ONLY==0 */
/* aci_blue_initialized_event */
/* Event len: 1 */
/**
 * @brief This event inform the application that the network coprocessor has
 *        been reset. If the reason code is a system crash, a following event
 *        @ref aci_blue_crash_info_event will provide more information regarding
 *        the system crash details.
 * @param Reason_Code Reason code describing why device was reset and in which
 *        mode is operating (Updater or Normal mode)
 *        Values:
 *        - 0x01: Firmware started properly
 *        - 0x02: Updater mode entered with ACI command
 *        - 0x03: Updater mode entered due to bad Blue Flag
 *        - 0x04: Updater mode entered due to boot pin
 *        - 0x05: System reset due to watchdog
 *        - 0x06: System reset due to lockup
 *        - 0x07: System reset due to brownout reset
 *        - 0x08: System reset due to crash
 *        - 0x09: System reset due to ECC error
 * @retval None
 */
void aci_blue_initialized_event(uint8_t Reason_Code)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *) (buffer_out + 6);
  rp0->Reason_Code = Reason_Code;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 6, 8);
}

void aci_blue_initialized_legacy_event(uint8_t Reason_Code)
{
  uint8_t buffer_out[258];
  /* Output params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *) (buffer_out + 5);
  rp0->Reason_Code = Reason_Code;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0xFF;
  buffer_out[2] = 1 + 2;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x00;
  send_event(buffer_out, 1 + 5, 8);
}

/* aci_blue_crash_info_event */
/* Event len: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + rp0->Debug_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is given to the application after the @ref
 *        aci_blue_initialized_event when a system crash is detected. This
 *        events returns system crash information for debugging purposes.
 *        Information reported are useful to understand the root cause of the
 *        crash.
 * @param Crash_Type Crash type
 *        Values:
 *        - 0x00: Assert failed
 *        - 0x01: NMI fault
 *        - 0x02: Hard fault
 * @param SP Stack pointer
 * @param R0 Register R0
 * @param R1 Register R1
 * @param R2 Register R2
 * @param R3 Register R3
 * @param R12 Register R12
 * @param LR Link register
 * @param PC Program counter where crash occurred
 * @param xPSR xPSR register
 * @param Debug_Data_Length Length of Debug_Data field
 * @param Debug_Data Debug data
 * @retval None
 */
void aci_blue_crash_info_event(uint8_t Crash_Type,
                               uint32_t SP,
                               uint32_t R0,
                               uint32_t R1,
                               uint32_t R2,
                               uint32_t R3,
                               uint32_t R12,
                               uint32_t LR,
                               uint32_t PC,
                               uint32_t xPSR,
                               uint8_t Debug_Data_Length,
                               uint8_t Debug_Data[])
{
  uint8_t buffer_out[258];
  /* Output params */
  aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *) (buffer_out + 5);
  rp0->Crash_Type = Crash_Type;
  rp0->SP = SP;
  rp0->R0 = R0;
  rp0->R1 = R1;
  rp0->R2 = R2;
  rp0->R3 = R3;
  rp0->R12 = R12;
  rp0->LR = LR;
  rp0->PC = PC;
  rp0->xPSR = xPSR;
  rp0->Debug_Data_Length = Debug_Data_Length;
  Osal_MemCpy((void *) rp0->Debug_Data,(const void *) Debug_Data, Debug_Data_Length);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0xFF;
  buffer_out[2] = 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + Debug_Data_Length + 2;
  buffer_out[3] = 0x03;
  buffer_out[4] = 0x00;
  send_event(buffer_out, 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + Debug_Data_Length + 5, -1);
}

/* aci_hal_le_test_end_event */
/* Event len: 2 */
/**
 * @brief This event is generated when the amount of transmitted test packets
 *        specified with aci_hal_transmitter_test_packets() has been reached.
 * @param Number_Of_Packets The number of test packets actually transmitted.
 * @retval None
 */
void aci_hal_le_test_end_event(uint16_t Number_Of_Packets)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_hal_le_test_end_event_rp0 *rp0 = (aci_hal_le_test_end_event_rp0 *) (buffer_out + 6);
  rp0->Number_Of_Packets = Number_Of_Packets;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 2 + 6, -1);
}

/* aci_l2cap_cos_sdu_data_rx_nwk_event */
/* Event len: 2 + 2 + 2 + 2 + rp0->SDU_Length * (sizeof(uint8_t)) */
/**
 * @brief Event raised when an SDU has been received.
 * @param Connection_Handle Handle identifying the connection.
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param RX_Credit_Balance Remaining number of K-frames that local L2CAP layer
 *        entity can currently receive from the peer. If automatic management of
 *        credits is enabled, this number is automatically changed after the SDU
 *        is extracted.
 * @param SDU_Length
 * @param SDU_Data
 * @retval None
 */
void aci_l2cap_cos_sdu_data_rx_nwk_event(uint16_t Connection_Handle,
                                         uint16_t CID,
                                         uint16_t RX_Credit_Balance,
                                         uint16_t SDU_Length,
                                         uint8_t SDU_Data[])
{
  uint8_t buffer_out[6+ sizeof(aci_l2cap_cos_sdu_data_rx_nwk_event_rp0)-sizeof(((aci_l2cap_cos_sdu_data_rx_nwk_event_rp0*)0)->SDU_Data)];
  /* Output params */
  aci_l2cap_cos_sdu_data_rx_nwk_event_rp0 *rp0 = (aci_l2cap_cos_sdu_data_rx_nwk_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  rp0->RX_Credit_Balance = RX_Credit_Balance;
  rp0->SDU_Length = SDU_Length;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + SDU_Length + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x08;
  send_event_2buffers(buffer_out, 6 + sizeof(aci_l2cap_cos_sdu_data_rx_nwk_event_rp0)-sizeof(((aci_l2cap_cos_sdu_data_rx_nwk_event_rp0*)0)->SDU_Data), SDU_Data, SDU_Length, -1);
}

/* aci_gatt_srv_authorize_nwk_event */
/* Event len: 2 + 2 + 2 + 1 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated if authorization is needed to access the
 *        attribute value. aci_gatt_srv_authorize_resp_nwk command must be sent
 *        in response to this event.
 * @param Conn_Handle Connection handle to be used to identify the connection
 *        with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param CID If equal to 0x0004, the event is related to an unenhanced ATT
 *        bearer. Otherwise, the value is the local endpoint identifying the
 *        enhanced ATT bearer.
 * @param Attr_Handle
 * @param Operation_Type
 *        Values:
 *        - 0x00: Read
 *        - 0x10: Write Request
 *        - 0x11: Write Command or Signed Write Command
 *        - 0x12: Prepare Write Request
 * @param Attr_Val_Offset Offset from which the value needs to be read or write
 *        Values:
 *        - 0 ... 511
 * @param Data_Length Length of Data field
 * @param Data The data that the client has requested to write
 * @retval None
 */
void aci_gatt_srv_authorize_nwk_event(uint16_t Conn_Handle,
                                      uint16_t CID,
                                      uint16_t Attr_Handle,
                                      uint8_t Operation_Type,
                                      uint16_t Attr_Val_Offset,
                                      uint8_t Data_Length,
                                      uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_srv_authorize_nwk_event_rp0 *rp0 = (aci_gatt_srv_authorize_nwk_event_rp0 *) (buffer_out + 6);
  rp0->Conn_Handle = Conn_Handle;
  rp0->CID = CID;
  rp0->Attr_Handle = Attr_Handle;
  rp0->Operation_Type = Operation_Type;
  rp0->Attr_Val_Offset = Attr_Val_Offset;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 1 + 2 + 1 + Data_Length + 2);
  buffer_out[4] = 0x1d;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + 1 + 2 + 1 + Data_Length + 6, -1);
}

/* aci_gatt_srv_attribute_modified_event */
/* Event len: 2 + 2 + 2 + 2 + rp0->Attr_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated to the application by the GATT server when a
 *        client modifies any attribute on the server, as consequence of one of
 *        the following GATT procedures: - write without response - signed write
 *        without response - write characteristic value - write long
 *        characteristic value - reliable write.
 * @param Connection_Handle The connection handle which modified the attribute.
 * @param CID If equal to 0x0004, the event is related to an unenhanced ATT
 *        bearer. Otherwise, the value is the local endpoint identifying the
 *        enhanced ATT bearer.
 * @param Attr_Handle Handle of the attribute that was modified.
 * @param Attr_Data_Length Length of Attr_Data in octets
 * @param Attr_Data A concatenation of Handle, Length and Values for each of the
 *        attributes being notified.
 * @retval None
 */
void aci_gatt_srv_attribute_modified_event(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t Attr_Handle,
                                           uint16_t Attr_Data_Length,
                                           uint8_t Attr_Data[])
{
  uint8_t buffer_out[532];

  /* Output params */
  aci_gatt_srv_attribute_modified_event_rp0 *rp0 = (aci_gatt_srv_attribute_modified_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  rp0->Attr_Handle = Attr_Handle;
  rp0->Attr_Data_Length = Attr_Data_Length;
  Osal_MemCpy((void *) rp0->Attr_Data,(const void *) Attr_Data, Attr_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + Attr_Data_Length + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + 2 + Attr_Data_Length + 6, 20);
}
